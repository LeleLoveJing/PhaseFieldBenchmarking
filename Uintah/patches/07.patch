diff --git a/src/CCA/Components/Heat/AMRCCHeat2D.cc b/src/CCA/Components/Heat/AMRCCHeat2D.cc
deleted file mode 100644
index 3dbf05cc..00000000
--- a/src/CCA/Components/Heat/AMRCCHeat2D.cc
+++ /dev/null
@@ -1,536 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <CCA/Components/Heat/AMRCCHeat2D.h>
-
-#include <Core/Exceptions/InvalidValue.h>
-#include <Core/Grid/Variables/PerPatch.h>
-#include <CCA/Components/Heat/blockrange_io.h>
-#include <Core/Grid/Variables/PerPatchVars.h>
-#include <CCA/Ports/Regridder.h>
-
-using namespace Uintah;
-
-AMRCCHeat2D::AMRCCHeat2D ( ProcessorGroup const * myworld,
-			   const MaterialManagerP materialManager,
-			   int verbosity )
-  : CCHeat2D ( myworld, materialManager, verbosity )
-{}
-
-AMRCCHeat2D::~AMRCCHeat2D ()
-{}
-
-void AMRCCHeat2D::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid )
-{
-    CCHeat2D::problemSetup ( params, restart_prob_spec, grid );
-
-    ProblemSpecP diffusion = params->findBlock ( "FDHeat" );
-    diffusion->require ( "refine_threshold", refine_threshold );
-}
-
-void AMRCCHeat2D::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    GridP grid = level->getGrid();
-
-    switch ( time_scheme )
-    {
-    case TimeScheme::ForwardEuler:
-        if ( level->hasCoarserLevel() )
-        {
-            scheduleTimeAdvance_forward_euler_refinement ( level, sched );
-        }
-        else
-        {
-            scheduleTimeAdvance_forward_euler ( level, sched );
-        }
-        break;
-    case TimeScheme::BackwardEuler:
-        if ( solver->getName() == "hypre" )
-        {
-            scheduleTimeAdvance_backward_euler_assemble ( level, sched );
-            scheduleTimeAdvance_backward_euler_solve ( level, sched );
-        }
-        if ( solver->getName() == "hypreamr" )
-        {
-            if ( level->getIndex() != 0 )
-            {
-                return;    // only schedule on the coarsest level.
-            }
-
-            // all assemble task must be sent to the scheduler before the solve task
-            for ( int l = 0; l < grid->numLevels(); ++l )
-            {
-                scheduleTimeAdvance_backward_euler_assemble ( grid->getLevel ( l ), sched );
-            }
-
-            scheduleTimeAdvance_backward_euler_solve ( level, sched );
-        }
-        break;
-    default:
-        throw InternalError ( "\n ERROR: Unknown time scheme\n", __FILE__, __LINE__ );
-    }
-}
-
-void AMRCCHeat2D::scheduleRefine ( PatchSet const * patches, SchedulerP & sched )
-{
-    if ( getLevel ( patches )->hasCoarserLevel() )
-    {
-        Task * task = scinew Task ( "AMRCCHeat2D::task_refine", this, &AMRCCHeat2D::task_refine );
-        task->requires ( Task::NewDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-        task->computes ( u_label );
-        sched->addTask ( task, patches, m_materialManager->allMaterials() );
-    }
-}
-
-void AMRCCHeat2D::scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRCCHeat2D::task_coarsen", this, &AMRCCHeat2D::task_coarsen );
-    task->requires ( Task::NewDW, u_label, 0, Task::FineLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-    task->modifies ( u_label );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRCCHeat2D::scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRCCHeat2D::task_error_estimate", this, &AMRCCHeat2D::task_error_estimate );
-    task->requires ( Task::NewDW, u_label, Ghost::Ghost::None, 0 ); // this is actually the old value of this
-    task->modifies ( m_regridder->getRefineFlagLabel(), m_regridder->refineFlagMaterials() );
-    task->modifies ( m_regridder->getRefinePatchFlagLabel(), m_regridder->refineFlagMaterials() );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRCCHeat2D::scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    scheduleErrorEstimate ( level_coarse, sched );
-}
-
-void AMRCCHeat2D::scheduleTimeAdvance_forward_euler_refinement ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRCCHeat2D::task_forward_euler_time_advance_refinement", this, &AMRCCHeat2D::task_forward_euler_time_advance_refinement );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundCells, 1 );
-    task->requires ( Task::OldDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::AroundCells, 1 );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRCCHeat2D::task_forward_euler_time_advance_refinement ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRCCHeat2D::task_farward_euler_time_advance_refinement ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u_old;
-        dw_old->get ( u_old, u_label, 0, patch, Ghost::AroundCells, 1 );
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-
-        Variable u_new;
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ) ); } );
-
-        std::string bc_kind[4];
-        double bc_value[4];
-        ConstVariable u_coarse_old[4];
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                if ( patch->getBCType ( face ) == Patch::Coarse )
-                {
-                    const Level * level = patch->getLevel();
-                    const Level * level_coarse = level->getCoarserLevel().get_rep();
-                    IntVector l = { range.begin ( 0 ), range.begin ( 1 ), range.begin ( 2 ) };
-                    IntVector h = { range.end ( 0 ), range.end ( 1 ), range.end ( 2 ) };
-                    IntVector l_coarse = map_to_coarser ( level, l ) + patch->faceDirection ( face );
-                    IntVector h_coarse = map_to_coarser ( level, h - IntVector ( 1, 1, 1 ) ) + patch->faceDirection ( face ) + IntVector ( 1, 1, 1 ) ;
-
-                    dw_old->getRegion ( u_coarse_old[face], u_label, 0, level_coarse, l_coarse, h_coarse );
-                }
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " - BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u_old, &u_coarse_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance_refinement ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ), face, bc_kind, bc_value, u_coarse_old ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRCCHeat2D::task_refine ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches_fine, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRCCHeat2D::task_refine ====" << std::endl;
-
-    const Level * level_fine = getLevel ( patches_fine );
-    const Level * level_coarse = level_fine->getCoarserLevel().get_rep();
-
-    for ( int p = 0; p < patches_fine->size(); ++p )
-    {
-        const Patch * patch_fine = patches_fine->get ( p );
-        dbg_out2 << "== Fine Patch: " << *patch_fine << std::endl;
-
-        Variable u_fine;
-        dw_new->allocateAndPut ( u_fine, u_label, 0, patch_fine );
-        dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-        IntVector l_fine = get_low ( patch_fine );
-        IntVector h_fine = get_high ( patch_fine );
-
-        IntVector l_coarse = map_to_coarser ( level_fine, l_fine );
-        IntVector h_coarse = map_to_coarser ( level_fine, h_fine );
-
-        dbg_out4 << "fine range" << BlockRange ( l_fine, h_fine ) << std::endl;
-        dbg_out4 << "coarse range" << BlockRange ( l_coarse, h_coarse ) << std::endl;
-
-        ConstVariable u_coarse;
-        dw_new->getRegion ( u_coarse, u_label, 0, level_coarse, l_coarse, h_coarse );
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        BlockRange range_fine ( l_fine, h_fine );
-        dbg_out3 << "= Iterating over fine range" << range_fine << std::endl;
-        parallel_for ( range_fine, [level_fine, level_coarse, &u_coarse, &u_fine, this] ( int i, int j, int k )->void { refine ( i, j, k, level_fine, level_coarse, get_view ( u_coarse ), get_view ( u_fine ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRCCHeat2D::task_coarsen ( ProcessorGroup const * /*myworld*/, const PatchSubset * patches_coarse, const MaterialSubset * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRCCHeat2D::task_coarsen " << std::endl;
-
-    const Level * level_coarse = getLevel ( patches_coarse );
-    const Level * level_fine = level_coarse->getFinerLevel().get_rep();
-
-    for ( int p = 0; p < patches_coarse->size(); ++p )
-    {
-        const Patch * patch_coarse = patches_coarse->get ( p );
-        dbg_out2 << "== Coarse Patch: " << *patch_coarse << std::endl;
-
-        Variable u_coarse;
-        dw_new->getModifiable ( u_coarse, u_label, 0, patch_coarse );
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        IntVector l_coarse = get_low ( patch_coarse );
-        IntVector h_coarse = get_high ( patch_coarse );
-
-        IntVector l_fine = map_to_finer ( level_coarse, l_coarse );
-        IntVector h_fine = map_to_finer ( level_coarse, h_coarse );
-
-        Level::selectType patches_fine;
-        level_fine->selectPatches ( l_fine, h_fine, patches_fine );
-
-        for ( unsigned int i = 0; i < patches_fine.size(); ++i )
-        {
-            const Patch * patch_fine = patches_fine[i];
-            dbg_out3 << "= Fine Patch " << *patch_fine << std::endl;
-
-            ConstVariable u_fine;
-            dw_new->get ( u_fine, u_label, 0, patch_fine, Ghost::None, 0 );
-            dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-            BlockRange range_coarse (
-                Max ( l_coarse, map_to_coarser ( level_fine, get_low ( patch_fine ) ) ),
-                Min ( h_coarse, map_to_coarser ( level_fine, get_high ( patch_fine ) ) )
-            );
-
-            dbg_out3 << "= Iterating over coarse cells window " << range_coarse << std::endl;
-            parallel_for ( range_coarse, [level_coarse, level_fine, &u_fine, &u_coarse, this] ( int i, int j, int k )->void { coarsen ( i, j, k, level_coarse, level_fine, get_view ( u_fine ), get_view ( u_coarse ) ); } );
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRCCHeat2D::task_error_estimate ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRCCHeat2D::task_error_estimate " << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        FlagVariable flag_refine;
-        PerPatch<PatchFlagP> flag_refine_patch;
-        dw_new->getModifiable ( flag_refine, m_regridder->getRefineFlagLabel(), 0, patch );
-        dw_new->get ( flag_refine_patch, m_regridder->getRefinePatchFlagLabel(), 0, patch );
-        dbg_out4 << "flag_refine \t window " << flag_refine.getLowIndex() << flag_refine.getHighIndex() << std::endl;
-
-        PatchFlag * patch_flag_refine = flag_refine_patch.get().get_rep();
-        ConstVariable u;
-        dw_new->get ( u, u_label, 0, patch, Ghost::None, 0 );
-        dbg_out4 << "u \t window " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        bool refine_patch = false;
-        BlockRange range = get_inner_range ( patch );
-        dbg_out3 << "= Iterating over inner cells window " << range << std::endl;
-        Uintah::parallel_reduce_sum ( range, [patch, &u, &flag_refine, this] ( int i, int j, int k, bool & refine_patch )->void { error_estimate ( i, j, k, patch, get_view ( u ), get_view ( flag_refine ), refine_patch, refine_threshold ); }, refine_patch );
-
-        if ( refine_patch )
-        {
-            patch_flag_refine->set();
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRCCHeat2D::forward_euler_time_advance_refinement ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4], ConstVariable u_coarse_old[4] )
-{
-    const Level * level = patch->getLevel();
-
-    const double d ( face / 2 );
-    const double h ( level->dCell() [d] );
-
-    const double dx ( level->dCell().x() );
-//  const double dy ( level->dCell().y() );
-
-    const IntVector cl = get_low ( patch );
-    const IntVector ch = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    const IntVector c0 ( i, j, k );
-    const IntVector cm = c0 - patch->faceDirection ( face );
-    const IntVector cp = c0 + patch->faceDirection ( face );
-
-    const IntVector cw ( i - 1, j, k );
-    const IntVector ce ( i + 1, j, k );
-//  const IntVector cs ( i, j - 1, k );
-//  const IntVector cn ( i, j + 1, k );
-
-    if ( bc_kind[face] == "Dirichlet" )
-    {
-        u_new[c0] = bc_value[face];
-        if ( is_internal ( patch, cm, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on nm
-        {
-            u_new[cm] += ( delt * alpha * ( bc_value[face] - u_old[c0] ) ) / ( h * h );
-        }
-        return;
-    }
-
-    if ( bc_kind[face] == "Neumann" )
-    {
-        double delta_u = delt * alpha;
-        const double sgn ( patch->faceDirection ( face ) [d] );
-        double uxx = 0.;
-        double uyy = 0.;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            uxx = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_cw = interpolate_coarser ( cw, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xminus] );
-                    uxx = ( u_old[ce] + u_old_cw - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old[cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ce = interpolate_coarser ( ce, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xplus] );
-                    uxx = ( u_old_ce + u_old[cw] - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            uyy = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            delta_u *=  uxx + uyy;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[c0] = u_old[c0] + delta_u;
-        return;
-    }
-
-    if ( bc_kind[face] == "FineCoarseInterface" )
-    {
-        double delta_u = delt * alpha;
-        double uxx = 0.;
-        double uyy = 0.;
-
-        double u_old_cp;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            u_old_cp = interpolate_coarser ( cp, level, level->getCoarserLevel().get_rep(), u_coarse_old[face] );
-            uxx = ( u_old[cm] + u_old_cp - 2. * u_old[c0] ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_cw = interpolate_coarser ( cw, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xminus] );
-                    uxx = ( u_old[ce] + u_old_cw - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old[cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ce = interpolate_coarser ( ce, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xplus] );
-                    uxx = ( u_old_ce + u_old[cw] - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            u_old_cp = interpolate_coarser ( cp, level, level->getCoarserLevel().get_rep(), u_coarse_old[face] );
-            uyy = ( u_old[cm] + u_old_cp - 2. * u_old[c0] ) / ( h * h );
-            delta_u *= uxx + uyy;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[c0] = u_old[c0] + delta_u;
-        return;
-    }
-
-    std::ostringstream msg;
-    msg << "\n ERROR: Unknown BC condition (" << bc_kind[face] << ") on patch " << *patch << " face " << face << "\n";
-    throw InvalidValue ( msg.str(), __FILE__, __LINE__ );
-}
-
-void AMRCCHeat2D::refine ( int i_fine, int j_fine, int k_fine, const Uintah::Level * level_fine, const Uintah::Level * level_coarse, ConstVariableView u_coarse, VariableView u_fine )
-{
-    IntVector cell_fine ( i_fine, j_fine, k_fine );
-    u_fine[cell_fine] = interpolate_coarser ( cell_fine, level_fine, level_coarse, u_coarse );
-}
-
-void AMRCCHeat2D::coarsen ( int i_coarse, int j_coarse, int k_coarse, const Uintah::Level * level_coarse, const Uintah::Level * level_fine, ConstVariableView u_fine, VariableView u_coarse )
-{
-    IntVector cell_coarse ( i_coarse, j_coarse, k_coarse );
-    u_coarse[cell_coarse] = restrict_finer ( cell_coarse, level_coarse, level_fine, u_fine );
-}
-
-void AMRCCHeat2D::error_estimate ( int i, int j, int k, const Uintah::Patch * patch, ConstVariableView u, FlagView flag_refine, bool & refine_patch, const double & refine_threshold )
-{
-    const IntVector l = u.getLowIndex();
-    const IntVector h = u.getHighIndex() - IntVector ( 1, 1, 1 );
-    Vector d ( patch->dCell() );
-
-    int im = ( i > l.x() ) ? i - 1 : i, ip = ( i < h.x() ) ? i + 1 : i;
-    int jm = ( j > l.y() ) ? j - 1 : j, jp = ( j < h.y() ) ? j + 1 : j;
-    double u_x = ( u ( ip, j, k ) - u ( im, j, k ) ) / ( d.x() * ( ip - im ) );
-    double u_y = ( u ( i, jp, k ) - u ( i, jm, k ) ) / ( d.y() * ( jp - jm ) );
-
-    bool tmp = u_x * u_x > refine_threshold ||
-               u_y * u_y > refine_threshold;
-
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-double AMRCCHeat2D::interpolate_coarser ( const IntVector & cell_fine, const Uintah::Level * level_fine, const Uintah::Level * level_coarse, ConstVariableView u_coarse )
-{
-    IntVector cell_coarse ( level_fine->mapCellToCoarser ( cell_fine ) );
-    return u_coarse[cell_coarse];
-}
-
-double AMRCCHeat2D::restrict_finer ( const IntVector & cell_coarse, const Uintah::Level * level_coarse, const Uintah::Level * level_fine, ConstVariableView u_fine )
-{
-    const IntVector & l_coarse ( cell_coarse ); // bottom-left-lower corner
-    const IntVector h_coarse = l_coarse + IntVector ( 1, 1, 1 );
-    const IntVector l_fine ( level_coarse->mapNodeToFiner ( l_coarse ) );
-    const IntVector h_fine = l_fine + level_fine->getRefinementRatio(); // TODO check this
-
-    double sum_u ( 0. ), cnt ( 0. );
-    for ( CellIterator it ( l_fine, h_fine ); !it.done(); ++it )
-    {
-        sum_u += u_fine[*it];
-        cnt += 1.;
-    }
-    return sum_u / cnt;
-}
diff --git a/src/CCA/Components/Heat/AMRCCHeat2D.h b/src/CCA/Components/Heat/AMRCCHeat2D.h
deleted file mode 100644
index 4d425e85..00000000
--- a/src/CCA/Components/Heat/AMRCCHeat2D.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_AMRCCHeat2D_h
-#define Packages_Uintah_CCA_Components_Heat_AMRCCHeat2D_h
-
-#include <CCA/Components/Heat/CCHeat2D.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-namespace Uintah
-{
-
-class AMRCCHeat2D : public CCHeat2D
-{
-protected:
-    using FlagVariable = CCVariable<int>;
-#ifdef UINTAH_ENABLE_KOKKOS
-    using FlagView = KokkosView3<int>;
-#else
-    using FlagView = FlagVariable & ;
-#endif
-
-    using CCHeat2D::get_view;
-    static constexpr inline FlagView get_view ( FlagVariable & var );
-
-    static inline IntVector map_to_coarser ( Level const * level, IntVector const & i );
-    static inline IntVector map_to_finer ( Level const * level, IntVector const & i );
-
-protected:
-    double refine_threshold;
-
-public:
-    AMRCCHeat2D ( const ProcessorGroup * myworld,
-		  const MaterialManagerP materialManager,
-		  int verbosity = 0 );
-  
-    virtual ~AMRCCHeat2D ();
-
-protected:
-    AMRCCHeat2D ( AMRCCHeat2D const & ) = delete;
-    AMRCCHeat2D & operator= ( AMRCCHeat2D const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-    virtual void scheduleRefine ( PatchSet const * patches, SchedulerP & sched ) override;
-    virtual void scheduleRefineInterface ( LevelP const & /*level_fine*/, SchedulerP & /*sched*/, bool /*need_old_coarse*/, bool /*need_new_coarse*/ ) override {};
-    virtual void scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-
-    void scheduleTimeAdvance_forward_euler_refinement ( LevelP const & level, SchedulerP & );
-
-    void task_forward_euler_time_advance_refinement ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_refine ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_coarsen ( ProcessorGroup const * myworld, PatchSubset const * patches_coarse, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_error_estimate ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-
-    void forward_euler_time_advance_refinement ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4], ConstVariable u_coarse_old[4] );
-    void refine ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstVariableView u_coarse, VariableView u_fine );
-    void coarsen ( int i_coarse, int j_coarse, int k_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine, VariableView u_coarse );
-    void error_estimate ( int i, int j, int k, Patch const * patch, ConstVariableView u, FlagView flag_refine, bool & refine_patch, double const & refine_threshold );
-
-    double interpolate_coarser ( const IntVector & cell_fine, Level const * level_fine, Level const * level_coarse, ConstVariableView u_coarse );
-    double restrict_finer ( const IntVector & cell_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine );
-}; // class AMRCCHeat2D
-
-} // namespace Uintah
-
-constexpr inline Uintah::AMRCCHeat2D::FlagView Uintah::AMRCCHeat2D::get_view ( FlagVariable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-inline Uintah::IntVector Uintah::AMRCCHeat2D::map_to_coarser ( Level const * level, IntVector const & i )
-{
-    return level->mapCellToCoarser ( i );
-}
-
-inline Uintah::IntVector Uintah::AMRCCHeat2D::map_to_finer ( Level const * level, IntVector const & i )
-{
-    return level->mapCellToFiner ( i );
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_AMRCCHeat2D_h
diff --git a/src/CCA/Components/Heat/AMRCCHeat3D.cc b/src/CCA/Components/Heat/AMRCCHeat3D.cc
deleted file mode 100644
index d58d6238..00000000
--- a/src/CCA/Components/Heat/AMRCCHeat3D.cc
+++ /dev/null
@@ -1,735 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <CCA/Components/Heat/AMRCCHeat3D.h>
-
-#include <Core/Exceptions/InvalidValue.h>
-#include <Core/Grid/Variables/PerPatch.h>
-#include <CCA/Components/Heat/blockrange_io.h>
-#include <Core/Grid/Variables/PerPatchVars.h>
-#include <CCA/Ports/Regridder.h>
-
-using namespace Uintah;
-
-AMRCCHeat3D::AMRCCHeat3D ( const ProcessorGroup * myworld,
-			   const MaterialManagerP materialManager,
-			   int verbosity )
-  : CCHeat3D ( myworld, materialManager, verbosity )
-{}
-
-AMRCCHeat3D::~AMRCCHeat3D ()
-{}
-
-void AMRCCHeat3D::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid )
-{
-    CCHeat3D::problemSetup ( params, restart_prob_spec, grid );
-
-    ProblemSpecP diffusion = params->findBlock ( "FDHeat" );
-    diffusion->require ( "refine_threshold", refine_threshold );
-}
-
-void AMRCCHeat3D::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    GridP grid = level->getGrid();
-
-    switch ( time_scheme )
-    {
-    case TimeScheme::ForwardEuler:
-        if ( level->hasCoarserLevel() )
-        {
-            scheduleTimeAdvance_forward_euler_refinement ( level, sched );
-        }
-        else
-        {
-            scheduleTimeAdvance_forward_euler ( level, sched );
-        }
-        break;
-    case TimeScheme::BackwardEuler:
-        if ( solver->getName() == "hypre" )
-        {
-            scheduleTimeAdvance_backward_euler_assemble ( level, sched );
-            scheduleTimeAdvance_backward_euler_solve ( level, sched );
-        }
-        if ( solver->getName() == "hypreamr" )
-        {
-            if ( level->getIndex() != 0 )
-            {
-                return;    // only schedule on the coarsest level.
-            }
-
-            // all assemble task must be sent to the scheduler before the solve task
-            for ( int l = 0; l < grid->numLevels(); ++l )
-            {
-                scheduleTimeAdvance_backward_euler_assemble ( grid->getLevel ( l ), sched );
-            }
-
-            scheduleTimeAdvance_backward_euler_solve ( level, sched );
-        }
-        break;
-    default:
-        throw InternalError ( "\n ERROR: Unknown time scheme\n", __FILE__, __LINE__ );
-    }
-}
-
-void AMRCCHeat3D::scheduleRefine ( PatchSet const * patches, SchedulerP & sched )
-{
-    if ( getLevel ( patches )->hasCoarserLevel() )
-    {
-        Task * task = scinew Task ( "AMRCCHeat3D::task_refine", this, &AMRCCHeat3D::task_refine );
-        task->requires ( Task::NewDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-        task->computes ( u_label );
-        sched->addTask ( task, patches, m_materialManager->allMaterials() );
-    }
-}
-
-void AMRCCHeat3D::scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRCCHeat3D::task_coarsen", this, &AMRCCHeat3D::task_coarsen );
-    task->requires ( Task::NewDW, u_label, 0, Task::FineLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-    task->modifies ( u_label );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRCCHeat3D::scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRCCHeat3D::task_error_estimate", this, &AMRCCHeat3D::task_error_estimate );
-    task->requires ( Task::NewDW, u_label, Ghost::Ghost::None, 0 ); // this is actually the old value of this
-    task->modifies ( m_regridder->getRefineFlagLabel(), m_regridder->refineFlagMaterials() );
-    task->modifies ( m_regridder->getRefinePatchFlagLabel(), m_regridder->refineFlagMaterials() );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRCCHeat3D::scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    scheduleErrorEstimate ( level_coarse, sched );
-}
-
-void AMRCCHeat3D::scheduleTimeAdvance_forward_euler_refinement ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRCCHeat3D::task_forward_euler_time_advance_refinement", this, &AMRCCHeat3D::task_forward_euler_time_advance_refinement );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundCells, 1 );
-    task->requires ( Task::OldDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::AroundCells, 1 );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRCCHeat3D::task_forward_euler_time_advance_refinement ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRCCHeat3D::task_farward_euler_time_advance_refinement ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u_old;
-        dw_old->get ( u_old, u_label, 0, patch, Ghost::AroundCells, 1 );
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-
-        Variable u_new;
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ) ); } );
-
-        std::string bc_kind[6];
-        double bc_value[6];
-        ConstVariable u_coarse_old[6];
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                if ( patch->getBCType ( face ) == Patch::Coarse )
-                {
-                    const Level * level = patch->getLevel();
-                    const Level * level_coarse = level->getCoarserLevel().get_rep();
-                    IntVector l = { range.begin ( 0 ), range.begin ( 1 ), range.begin ( 2 ) };
-                    IntVector h = { range.end ( 0 ), range.end ( 1 ), range.end ( 2 ) };
-                    IntVector l_coarse = map_to_coarser ( level, l ) + patch->faceDirection ( face );
-                    IntVector h_coarse = map_to_coarser ( level, h - IntVector ( 1, 1, 1 ) ) + patch->faceDirection ( face ) + IntVector ( 1, 1, 1 ) ;
-
-                    dw_old->getRegion ( u_coarse_old[face], u_label, 0, level_coarse, l_coarse, h_coarse );
-                }
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " - BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u_old, &u_coarse_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance_refinement ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ), face, bc_kind, bc_value, u_coarse_old ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRCCHeat3D::task_refine ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches_fine, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRCCHeat3D::task_refine ====" << std::endl;
-
-    const Level * level_fine = getLevel ( patches_fine );
-    const Level * level_coarse = level_fine->getCoarserLevel().get_rep();
-
-    for ( int p = 0; p < patches_fine->size(); ++p )
-    {
-        const Patch * patch_fine = patches_fine->get ( p );
-        dbg_out2 << "== Fine Patch: " << *patch_fine << std::endl;
-
-        Variable u_fine;
-        dw_new->allocateAndPut ( u_fine, u_label, 0, patch_fine );
-        dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-        IntVector l_fine = get_low ( patch_fine );
-        IntVector h_fine = get_high ( patch_fine );
-
-        IntVector l_coarse = map_to_coarser ( level_fine, l_fine );
-        IntVector h_coarse = map_to_coarser ( level_fine, h_fine );
-
-        dbg_out4 << "fine range" << BlockRange ( l_fine, h_fine ) << std::endl;
-        dbg_out4 << "coarse range" << BlockRange ( l_coarse, h_coarse ) << std::endl;
-
-        ConstVariable u_coarse;
-        dw_new->getRegion ( u_coarse, u_label, 0, level_coarse, l_coarse, h_coarse );
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        BlockRange range_fine ( l_fine, h_fine );
-        dbg_out3 << "= Iterating over fine range" << range_fine << std::endl;
-        parallel_for ( range_fine, [level_fine, level_coarse, &u_coarse, &u_fine, this] ( int i, int j, int k )->void { refine ( i, j, k, level_fine, level_coarse, get_view ( u_coarse ), get_view ( u_fine ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRCCHeat3D::task_coarsen ( ProcessorGroup const * /*myworld*/, const PatchSubset * patches_coarse, const MaterialSubset * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRCCHeat3D::task_coarsen " << std::endl;
-
-    const Level * level_coarse = getLevel ( patches_coarse );
-    const Level * level_fine = level_coarse->getFinerLevel().get_rep();
-
-    for ( int p = 0; p < patches_coarse->size(); ++p )
-    {
-        const Patch * patch_coarse = patches_coarse->get ( p );
-        dbg_out2 << "== Coarse Patch: " << *patch_coarse << std::endl;
-
-        Variable u_coarse;
-        dw_new->getModifiable ( u_coarse, u_label, 0, patch_coarse );
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        IntVector l_coarse = get_low ( patch_coarse );
-        IntVector h_coarse = get_high ( patch_coarse );
-
-        IntVector l_fine = map_to_finer ( level_coarse, l_coarse );
-        IntVector h_fine = map_to_finer ( level_coarse, h_coarse );
-
-        Level::selectType patches_fine;
-        level_fine->selectPatches ( l_fine, h_fine, patches_fine );
-
-        for ( unsigned int i = 0; i < patches_fine.size(); ++i )
-        {
-            const Patch * patch_fine = patches_fine[i];
-            dbg_out3 << "= Fine Patch " << *patch_fine << std::endl;
-
-            ConstVariable u_fine;
-            dw_new->get ( u_fine, u_label, 0, patch_fine, Ghost::None, 0 );
-            dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-            BlockRange range_coarse (
-                Max ( l_coarse, map_to_coarser ( level_fine, get_low ( patch_fine ) ) ),
-                Min ( h_coarse, map_to_coarser ( level_fine, get_high ( patch_fine ) ) )
-            );
-
-            dbg_out3 << "= Iterating over coarse cells window " << range_coarse << std::endl;
-            parallel_for ( range_coarse, [level_coarse, level_fine, &u_fine, &u_coarse, this] ( int i, int j, int k )->void { coarsen ( i, j, k, level_coarse, level_fine, get_view ( u_fine ), get_view ( u_coarse ) ); } );
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRCCHeat3D::task_error_estimate ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRCCHeat3D::task_error_estimate " << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        FlagVariable flag_refine;
-        PerPatch<PatchFlagP> flag_refine_patch;
-        dw_new->getModifiable ( flag_refine, m_regridder->getRefineFlagLabel(), 0, patch );
-        dw_new->get ( flag_refine_patch, m_regridder->getRefinePatchFlagLabel(), 0, patch );
-        dbg_out4 << "flag_refine \t window " << flag_refine.getLowIndex() << flag_refine.getHighIndex() << std::endl;
-
-        PatchFlag * patch_flag_refine = flag_refine_patch.get().get_rep();
-        ConstVariable u;
-        dw_new->get ( u, u_label, 0, patch, Ghost::None, 0 );
-        dbg_out4 << "u \t window " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        bool refine_patch = false;
-        BlockRange range = get_inner_range ( patch );
-        dbg_out3 << "= Iterating over inner cells window " << range << std::endl;
-        Uintah::parallel_reduce_sum ( range, [patch, &u, &flag_refine, this] ( int i, int j, int k, bool & refine_patch )->void { error_estimate ( i, j, k, patch, get_view ( u ), get_view ( flag_refine ), refine_patch, refine_threshold ); }, refine_patch );
-
-        if ( refine_patch )
-        {
-            patch_flag_refine->set();
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRCCHeat3D::forward_euler_time_advance_refinement ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4], ConstVariable u_coarse_old[4] )
-{
-    const Level * level = patch->getLevel();
-
-    const double d ( face / 2 );
-    const double h ( level->dCell() [d] );
-
-    const double dx ( level->dCell().x() );
-    const double dy ( level->dCell().y() );
-//  const double dz ( level->dCell().z() );
-
-    const IntVector cl = get_low ( patch );
-    const IntVector ch = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    const IntVector c0 ( i, j, k );
-    const IntVector cm = c0 - patch->faceDirection ( face );
-    const IntVector cp = c0 + patch->faceDirection ( face );
-
-    const IntVector cw ( i - 1, j, k );
-    const IntVector ce ( i + 1, j, k );
-    const IntVector cs ( i, j - 1, k );
-    const IntVector cn ( i, j + 1, k );
-//  const IntVector cb ( i, j, k - 1 );
-//  const IntVector ct ( i, j, k + 1 );
-
-    if ( bc_kind[face] == "Dirichlet" )
-    {
-        u_new[c0] = bc_value[face];
-        if ( is_internal ( patch, cm, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on nm
-        {
-            u_new[cm] += ( delt * alpha * ( bc_value[face] - u_old[c0] ) ) / ( h * h );
-        }
-        return;
-    }
-
-    if ( bc_kind[face] == "Neumann" )
-    {
-        double delta_u = delt * alpha;
-        const double sgn ( patch->faceDirection ( face ) [d] );
-        double uxx = 0.;
-        double uyy = 0.;
-        double uzz = 0.;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            if ( k == cl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == ch.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            uxx = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy + uzz;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( k == cl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == ch.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_cw = interpolate_coarser ( cw, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xminus] );
-                    uxx = ( u_old[ce] + u_old_cw - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old[cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ce = interpolate_coarser ( ce, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xplus] );
-                    uxx = ( u_old_ce + u_old[cw] - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            uyy = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        case Patch::zminus:
-        case Patch::zplus:
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_cw = interpolate_coarser ( cw, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xminus] );
-                    uxx = ( u_old[ce] + u_old_cw - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old[cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ce = interpolate_coarser ( ce, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xplus] );
-                    uxx = ( u_old_ce + u_old[cw] - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yminus] == "Neumann" )
-                {
-                    uyy = ( u_old[cn] - u_old[c0] - bc_value[Patch::yminus] * dy ) / ( dy * dy );
-                }
-                else if ( bc_kind[Patch::yminus] == "FineCoarseInterface" )
-                {
-                    double u_old_cs = interpolate_coarser ( cs, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::yminus] );
-                    uyy = ( u_old[cn] + u_old_cs - 2. * u_old[c0] ) / ( dy * dy );
-                }
-            }
-            else if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yplus] == "Neumann" )
-                {
-                    uyy = ( u_old[c0] - u_old[cs] + bc_value[Patch::yplus] * dy ) / ( dy * dy );
-                }
-                else if ( bc_kind[Patch::yplus] == "FineCoarseInterface" )
-                {
-                    double u_old_cn = interpolate_coarser ( cn, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::yplus] );
-                    uyy = ( u_old_cn + u_old[cs] - 2. * u_old[c0] ) / ( dy * dy );
-                }
-            }
-            else
-            {
-                uyy = dyy ( i, j, k, patch, u_old );
-            }
-            uzz = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[c0] = u_old[c0] + delta_u;
-        return;
-    }
-
-    if ( bc_kind[face] == "FineCoarseInterface" )
-    {
-        double delta_u = delt * alpha;
-        double uxx = 0.;
-        double uyy = 0.;
-        double uzz = 0.;
-
-        double u_old_cp;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            if ( k == cl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == ch.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            u_old_cp = interpolate_coarser ( cp, level, level->getCoarserLevel().get_rep(), u_coarse_old[face] );
-            uxx = ( u_old[cm] + u_old_cp - 2. * u_old[c0] ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy + uzz;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( k == cl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == ch.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_cw = interpolate_coarser ( cw, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xminus] );
-                    uxx = ( u_old[ce] + u_old_cw - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old[cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ce = interpolate_coarser ( ce, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xplus] );
-                    uxx = ( u_old_ce + u_old[cw] - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            u_old_cp = interpolate_coarser ( cp, level, level->getCoarserLevel().get_rep(), u_coarse_old[face] );
-            uyy = ( u_old[cm] + u_old_cp - 2. * u_old[c0] ) / ( h * h );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy + uzz;
-            break;
-        case Patch::zminus:
-        case Patch::zplus:
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_cw = interpolate_coarser ( cw, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xminus] );
-                    uxx = ( u_old[ce] + u_old_cw - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old[cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ce = interpolate_coarser ( ce, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::xplus] );
-                    uxx = ( u_old_ce + u_old[cw] - 2. * u_old[c0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yminus] == "Neumann" )
-                {
-                    uyy = ( u_old[cn] - u_old[c0] - bc_value[Patch::yminus] * dy ) / ( dy * dy );
-                }
-                else if ( bc_kind[Patch::yminus] == "FineCoarseInterface" )
-                {
-                    double u_old_cs = interpolate_coarser ( cs, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::yminus] );
-                    uyy = ( u_old[cn] + u_old_cs - 2. * u_old[c0] ) / ( dy * dy );
-                }
-            }
-            else if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yplus] == "Neumann" )
-                {
-                    uyy = ( u_old[c0] - u_old[cs] + bc_value[Patch::yplus] * dy ) / ( dy * dy );
-                }
-                else if ( bc_kind[Patch::yplus] == "FineCoarseInterface" )
-                {
-                    double u_old_cn = interpolate_coarser ( cn, level, level->getCoarserLevel().get_rep(), u_coarse_old[Patch::yplus] );
-                    uyy = ( u_old_cn + u_old[cs] - 2. * u_old[c0] ) / ( dy * dy );
-                }
-            }
-            else
-            {
-                uyy = dyy ( i, j, k, patch, u_old );
-            }
-            u_old_cp = interpolate_coarser ( cp, level, level->getCoarserLevel().get_rep(), u_coarse_old[face] );
-            uzz = ( u_old[cm] + u_old_cp - 2 * u_old[c0] ) / ( h * h );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[c0] = u_old[c0] + delta_u;
-        return;
-    }
-
-    std::ostringstream msg;
-    msg << "\n ERROR: Unknown BC condition (" << bc_kind[face] << ") on patch " << *patch << " face " << face << "\n";
-    throw InvalidValue ( msg.str(), __FILE__, __LINE__ );
-}
-
-void AMRCCHeat3D::refine ( int i_fine, int j_fine, int k_fine, const Uintah::Level * level_fine, const Uintah::Level * level_coarse, ConstVariableView u_coarse, VariableView u_fine )
-{
-    IntVector cell_fine ( i_fine, j_fine, k_fine );
-    u_fine[cell_fine] = interpolate_coarser ( cell_fine, level_fine, level_coarse, u_coarse );
-}
-
-void AMRCCHeat3D::coarsen ( int i_coarse, int j_coarse, int k_coarse, const Uintah::Level * level_coarse, const Uintah::Level * level_fine, ConstVariableView u_fine, VariableView u_coarse )
-{
-    IntVector cell_coarse ( i_coarse, j_coarse, k_coarse );
-    u_coarse[cell_coarse] = restrict_finer ( cell_coarse, level_coarse, level_fine, u_fine );
-}
-
-void Uintah::AMRCCHeat3D::error_estimate ( int i, int j, int k, const Uintah::Patch * patch, ConstVariableView u, FlagView flag_refine, bool & refine_patch, const double & refine_threshold )
-{
-    const IntVector l = u.getLowIndex();
-    const IntVector h = u.getHighIndex() - IntVector ( 1, 1, 1 );
-    Vector d ( patch->dCell() );
-
-    int im = ( i > l.x() ) ? i - 1 : i, ip = ( i < h.x() ) ? i + 1 : i;
-    int jm = ( j > l.y() ) ? j - 1 : j, jp = ( j < h.y() ) ? j + 1 : j;
-    int km = ( k > l.z() ) ? k - 1 : k, kp = ( k < h.z() ) ? k + 1 : k;
-    double u_x = ( u ( ip, j, k ) - u ( im, j, k ) ) / ( d.x() * ( ip - im ) );
-    double u_y = ( u ( i, jp, k ) - u ( i, jm, k ) ) / ( d.y() * ( jp - jm ) );
-    double u_z = ( u ( i, j, kp ) - u ( i, j, km ) ) / ( d.z() * ( kp - km ) );
-
-    bool tmp = u_x * u_x > refine_threshold ||
-               u_y * u_y > refine_threshold ||
-               u_z * u_z > refine_threshold;
-
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-double AMRCCHeat3D::interpolate_coarser ( const IntVector & cell_fine, const Uintah::Level * level_fine, const Uintah::Level * level_coarse, ConstVariableView u_coarse )
-{
-    IntVector cell_coarse ( level_fine->mapCellToCoarser ( cell_fine ) );
-    return u_coarse[cell_coarse];
-}
-
-double AMRCCHeat3D::restrict_finer ( const IntVector & cell_coarse, const Uintah::Level * level_coarse, const Uintah::Level * level_fine, ConstVariableView u_fine )
-{
-    const IntVector & l_coarse ( cell_coarse ); // bottom-left-lower corner
-    const IntVector h_coarse = l_coarse + IntVector ( 1, 1, 1 );
-    const IntVector l_fine ( level_coarse->mapNodeToFiner ( l_coarse ) );
-    const IntVector h_fine = l_fine + level_fine->getRefinementRatio(); // TODO check this
-
-    double sum_u ( 0. ), cnt ( 0. );
-    for ( CellIterator it ( l_fine, h_fine ); !it.done(); ++it )
-    {
-        sum_u += u_fine[*it];
-        cnt += 1.;
-    }
-    return sum_u / cnt;
-}
diff --git a/src/CCA/Components/Heat/AMRCCHeat3D.h b/src/CCA/Components/Heat/AMRCCHeat3D.h
deleted file mode 100644
index 6a4c1c8b..00000000
--- a/src/CCA/Components/Heat/AMRCCHeat3D.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_AMRCCHeat3D_h
-#define Packages_Uintah_CCA_Components_Heat_AMRCCHeat3D_h
-
-#include <CCA/Components/Heat/CCHeat3D.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-namespace Uintah
-{
-
-class AMRCCHeat3D : public CCHeat3D
-{
-protected:
-    using FlagVariable = CCVariable<int>;
-#ifdef UINTAH_ENABLE_KOKKOS
-    using FlagView = KokkosView3<int>;
-#else
-    using FlagView = FlagVariable & ;
-#endif
-
-    using CCHeat3D::get_view;
-    static constexpr inline FlagView get_view ( FlagVariable & var );
-
-    static inline IntVector map_to_coarser ( Level const * level, IntVector const & i );
-    static inline IntVector map_to_finer ( Level const * level, IntVector const & i );
-
-protected:
-    double refine_threshold;
-
-public:
-    AMRCCHeat3D ( const ProcessorGroup * myworld,
-		  const MaterialManagerP materialManager,
-		  int verbosity = 0 );
-  
-    virtual ~AMRCCHeat3D ();
-
-protected:
-    AMRCCHeat3D ( AMRCCHeat3D const & ) = delete;
-    AMRCCHeat3D & operator= ( AMRCCHeat3D const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-    virtual void scheduleRefine ( PatchSet const * patches, SchedulerP & sched ) override;
-    virtual void scheduleRefineInterface ( LevelP const & /*level_fine*/, SchedulerP & /*sched*/, bool /*need_old_coarse*/, bool /*need_new_coarse*/ ) override {};
-    virtual void scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-
-    void scheduleTimeAdvance_forward_euler_refinement ( LevelP const & level, SchedulerP & );
-
-    void task_forward_euler_time_advance_refinement ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_refine ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_coarsen ( ProcessorGroup const * myworld, PatchSubset const * patches_coarse, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_error_estimate ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-
-    void forward_euler_time_advance_refinement ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4], ConstVariable u_coarse_old[4] );
-    void refine ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstVariableView u_coarse, VariableView u_fine );
-    void coarsen ( int i_coarse, int j_coarse, int k_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine, VariableView u_coarse );
-    void error_estimate ( int i, int j, int k, Patch const * patch, ConstVariableView u, FlagView flag_refine, bool & refine_patch, double const & refine_threshold );
-
-    double interpolate_coarser ( const IntVector & cell_fine, Level const * level_fine, Level const * level_coarse, ConstVariableView u_coarse );
-    double restrict_finer ( const IntVector & cell_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine );
-}; // class AMRCCHeat2D
-
-} // namespace Uintah
-
-constexpr inline Uintah::AMRCCHeat3D::FlagView Uintah::AMRCCHeat3D::get_view ( FlagVariable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-inline Uintah::IntVector Uintah::AMRCCHeat3D::map_to_coarser ( Level const * level, IntVector const & i )
-{
-    return level->mapCellToCoarser ( i );
-}
-
-inline Uintah::IntVector Uintah::AMRCCHeat3D::map_to_finer ( Level const * level, IntVector const & i )
-{
-    return level->mapCellToFiner ( i );
-}
-
-#endif // Packages_Uintah_CCA_Components_CCHeat3D_AMRCCHeat3D_h
diff --git a/src/CCA/Components/Heat/AMRNCHeat2D.cc b/src/CCA/Components/Heat/AMRNCHeat2D.cc
deleted file mode 100644
index 5403157e..00000000
--- a/src/CCA/Components/Heat/AMRNCHeat2D.cc
+++ /dev/null
@@ -1,654 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <CCA/Components/Heat/AMRNCHeat2D.h>
-
-#include <Core/Exceptions/InvalidValue.h>
-#include <Core/Grid/Variables/PerPatch.h>
-#include <CCA/Components/Heat/blockrange_io.h>
-#include <Core/Grid/Variables/PerPatchVars.h>
-#include <CCA/Ports/Regridder.h>
-
-#ifdef CUSTOM_OUT
-#include <iomanip>
-#include <sstream>
-#include <Core/OS/Dir.h>
-#include <CCA/Components/Heat/vtkfile.hpp>
-#include <CCA/Components/Heat/pvtkfile.hpp>
-#endif
-
-using namespace Uintah;
-
-Uintah::AMRNCHeat2D::AMRNCHeat2D ( const ProcessorGroup * myworld,
-				   const MaterialManagerP materialManager,
-				   int verbosity )
-  : NCHeat2D ( myworld, materialManager, verbosity )
-{}
-
-AMRNCHeat2D::~AMRNCHeat2D ()
-{}
-
-void AMRNCHeat2D::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid )
-{
-    NCHeat2D::problemSetup ( params, restart_prob_spec, grid );
-
-    ProblemSpecP diffusion = params->findBlock ( "FDHeat" );
-    diffusion->require ( "refine_threshold", refine_threshold );
-}
-
-void AMRNCHeat2D::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    GridP grid = level->getGrid();
-
-    switch ( time_scheme )
-    {
-    case TimeScheme::ForwardEuler:
-        if ( level->hasCoarserLevel() )
-        {
-            scheduleTimeAdvance_forward_euler_refinement ( level, sched );
-        }
-        else
-        {
-            scheduleTimeAdvance_forward_euler ( level, sched );
-        }
-        break;
-    case TimeScheme::BackwardEuler:
-//      if ( solver->getName() == "hypre" )
-//      {
-//          scheduleTimeAdvance_backward_euler_assemble ( level, sched );
-//          scheduleTimeAdvance_backward_euler_solve ( level, sched );
-//      }
-//      if ( solver->getName() == "hypreamr" )
-//      {
-//          if ( level->getIndex() != 0 )
-//          {
-//              return;    // only schedule on the coarsest level.
-//          }
-//
-//          // all assemble task must be sent to the scheduler before the solve task
-//          for ( int l = 0; l < grid->numLevels(); ++l )
-//          {
-//              scheduleTimeAdvance_backward_euler_assemble ( grid->getLevel ( l ), sched );
-//          }
-//
-//          scheduleTimeAdvance_backward_euler_solve ( level, sched );
-//      }
-//      break;
-        throw InternalError ( "\n ERROR: BackwardEuler time scheme not implemented for node centered variables\n", __FILE__, __LINE__ );
-    default:
-        throw InternalError ( "\n ERROR: Unknown time scheme\n", __FILE__, __LINE__ );
-    }
-}
-
-void AMRNCHeat2D::scheduleRefine ( PatchSet const * patches, SchedulerP & sched )
-{
-    if ( getLevel ( patches )->hasCoarserLevel() )
-    {
-        Task * task = scinew Task ( "AMRNCHeat2D::task_refine", this, &AMRNCHeat2D::task_refine );
-        task->requires ( Task::NewDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::AroundNodes, 1 );
-        task->computes ( u_label );
-        sched->addTask ( task, patches, m_materialManager->allMaterials() );
-    }
-}
-
-void AMRNCHeat2D::scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRNCHeat2D::task_coarsen", this, &AMRNCHeat2D::task_coarsen );
-    task->requires ( Task::NewDW, u_label, 0, Task::FineLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-    task->modifies ( u_label );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRNCHeat2D::scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRNCHeat2D::task_error_estimate", this, &AMRNCHeat2D::task_error_estimate );
-    task->requires ( Task::NewDW, u_label, Ghost::AroundNodes, 1 ); // this is actually the old value of this
-    task->modifies ( m_regridder->getRefineFlagLabel(), m_regridder->refineFlagMaterials() );
-    task->modifies ( m_regridder->getRefinePatchFlagLabel(), m_regridder->refineFlagMaterials() );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRNCHeat2D::scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    scheduleErrorEstimate ( level_coarse, sched );
-}
-
-void AMRNCHeat2D::scheduleTimeAdvance_forward_euler_refinement ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRNCHeat2D::task_forward_euler_time_advance_refinement", this, &AMRNCHeat2D::task_forward_euler_time_advance_refinement );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundNodes, 1 );
-    task->requires ( Task::OldDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::AroundNodes, 1 );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRNCHeat2D::task_forward_euler_time_advance_refinement ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRNCHeat2D::task_farward_euler_time_advance_refinement ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u_old;
-        dw_old->get ( u_old, u_label, 0, patch, Ghost::AroundNodes, 1 );
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-
-        Variable u_new;
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ) ); } );
-
-        std::string bc_kind[4];
-        double bc_value[4];
-        ConstVariable u_coarse_old;
-        bool get_coarser = true;
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                if ( patch->getBCType ( face ) == Patch::Coarse && get_coarser )
-                {
-                    const Level * level = patch->getLevel();
-                    const Level * level_coarse = level->getCoarserLevel().get_rep();
-                    IntVector l = get_low ( patch );
-                    IntVector h = get_high ( patch );
-                    IntVector l_coarse = map_to_coarser ( level, l ) - IntVector ( 1, 1, 0 );
-                    IntVector h_coarse = map_to_coarser ( level, h ) + IntVector ( 1, 1, 0 );
-
-                    dw_old->getRegion ( u_coarse_old, u_label, 0, level_coarse, l_coarse, h_coarse );
-                    get_coarser = false;
-                }
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " - BC " << bc_kind[face] << " " << bc_value[face] << " face direction" << patch->faceDirection ( face ) << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u_old, &u_coarse_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance_refinement ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ), face, bc_kind, bc_value, u_coarse_old ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRNCHeat2D::task_refine ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches_fine, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRNCHeat2D::task_refine ====" << std::endl;
-
-    const Level * level_fine = getLevel ( patches_fine );
-    const Level * level_coarse = level_fine->getCoarserLevel().get_rep();
-
-    for ( int p = 0; p < patches_fine->size(); ++p )
-    {
-        const Patch * patch_fine = patches_fine->get ( p );
-        dbg_out2 << "== Fine Patch: " << *patch_fine << std::endl;
-
-        Variable u_fine;
-        dw_new->allocateAndPut ( u_fine, u_label, 0, patch_fine );
-        dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-        IntVector l_fine = get_low ( patch_fine );
-        IntVector h_fine = get_high ( patch_fine );
-
-        IntVector l_coarse = map_to_coarser ( level_fine, l_fine );
-        IntVector h_coarse = map_to_coarser ( level_fine, h_fine );
-        // Extening in order to select nodes on right edges
-        h_coarse += IntVector ( 1, 1, 0 );
-
-        dbg_out4 << "fine range" << BlockRange ( l_fine, h_fine ) << std::endl;
-        dbg_out4 << "coarse range" << BlockRange ( l_coarse, h_coarse ) << std::endl;
-
-        ConstVariable u_coarse;
-        dw_new->getRegion ( u_coarse, u_label, 0, level_coarse, l_coarse, h_coarse );
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        BlockRange range_fine ( l_fine, h_fine );
-        dbg_out3 << "= Iterating over fine range" << range_fine << std::endl;
-        parallel_for ( range_fine, [level_fine, level_coarse, &u_coarse, &u_fine, this] ( int i, int j, int k )->void { refine ( i, j, k, level_fine, level_coarse, get_view ( u_coarse ), get_view ( u_fine ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRNCHeat2D::task_coarsen ( ProcessorGroup const * /*myworld*/, const PatchSubset * patches_coarse, const MaterialSubset * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRNCHeat2D::task_coarsen " << std::endl;
-
-    const Level * level_coarse = getLevel ( patches_coarse );
-    const Level * level_fine = level_coarse->getFinerLevel().get_rep();
-
-    for ( int p = 0; p < patches_coarse->size(); ++p )
-    {
-        const Patch * patch_coarse = patches_coarse->get ( p );
-        dbg_out2 << "== Coarse Patch: " << *patch_coarse << std::endl;
-
-        Variable u_coarse;
-        dw_new->getModifiable ( u_coarse, u_label, 0, patch_coarse );
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        IntVector l_coarse = get_low ( patch_coarse );
-        IntVector h_coarse = get_high ( patch_coarse );
-
-        IntVector l_fine = map_to_finer ( level_coarse, l_coarse );
-        IntVector h_fine = map_to_finer ( level_coarse, h_coarse );
-
-        Level::selectType patches_fine;
-        level_fine->selectPatches ( l_fine, h_fine, patches_fine );
-
-        for ( unsigned int i = 0; i < patches_fine.size(); ++i )
-        {
-            const Patch * patch_fine = patches_fine[i];
-            dbg_out3 << "= Fine Patch " << *patch_fine << std::endl;
-
-            ConstVariable u_fine;
-            dw_new->get ( u_fine, u_label, 0, patch_fine, Ghost::None, 0 );
-            dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-            BlockRange range_coarse (
-                Max ( l_coarse, map_to_coarser ( level_fine, get_low ( patch_fine ) ) ),
-                Min ( h_coarse, map_to_coarser ( level_fine, get_high ( patch_fine ) ) )
-            );
-
-            dbg_out3 << "= Iterating over coarse cells window " << range_coarse << std::endl;
-            parallel_for ( range_coarse, [level_coarse, level_fine, &u_fine, &u_coarse, this] ( int i, int j, int k )->void { coarsen ( i, j, k, level_coarse, level_fine, get_view ( u_fine ), get_view ( u_coarse ) ); } );
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRNCHeat2D::task_error_estimate ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRNCHeat2D::task_error_estimate " << std::endl;
-
-#ifdef CUSTOM_OUT
-    PVtkFile * out_pvtk = nullptr;
-    const Level * level = getLevel ( patches );
-    const int & levelID = level->getIndex();
-    const int & timestep = getTimestep();
-    std::string out_path, time_path, level_path, patch_path;
-
-    if ( timestep + 1 >= m_output->getNextOutputTimeStep() )
-    {
-        dbg_out1 << "==== AMRNCHeat2D::task_save" << std::endl;
-        std::stringstream time_ss, level_ss;
-        out_path = m_output->getOutputLocation();
-        time_ss << "t" << std::setw ( 5 ) << std::setfill ( '0' ) << timestep;
-        level_ss << "l" << levelID;
-        time_path = time_ss.str();
-        level_path = level_ss.str();
-        MKDIR ( std::string ( out_path + "/" + time_path ).c_str(), 0777 );
-        MKDIR ( std::string ( out_path + "/" + time_path + "/rf" + level_path ).c_str(), 0777 );
-
-        // WARNING only for one process/thread
-
-        out_pvtk = new PVtkFile ( out_path +  "/" + time_path + "/rf" + level_path, time_path, timestep * delt );
-    }
-#endif
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        FlagVariable flag_refine;
-        PerPatch<PatchFlagP> flag_refine_patch;
-        dw_new->getModifiable ( flag_refine, m_regridder->getRefineFlagLabel(), 0, patch );
-        dw_new->get ( flag_refine_patch, m_regridder->getRefinePatchFlagLabel(), 0, patch );
-        dbg_out4 << "flag_refine \t window " << flag_refine.getLowIndex() << flag_refine.getHighIndex() << std::endl;
-
-        PatchFlag * patch_flag_refine = flag_refine_patch.get().get_rep();
-        ConstVariable u;
-        dw_new->get ( u, u_label, 0, patch, Ghost::AroundNodes, 1 );
-        dbg_out4 << "u \t window " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        bool refine_patch = false;
-        BlockRange range = get_flag_range ( patch );
-        dbg_out3 << "= Iterating over cells window " << range << std::endl;
-        Uintah::parallel_reduce_sum ( range, [patch, &u, &flag_refine, this] ( int i, int j, int k, bool & refine_patch )->void { error_estimate ( i, j, k, patch, get_view ( u ), get_view ( flag_refine ), refine_patch, refine_threshold ); }, refine_patch );
-
-        if ( refine_patch )
-        {
-            patch_flag_refine->set();
-        }
-
-#ifdef CUSTOM_OUT
-        if ( out_pvtk )
-        {
-            IntVector l = get_low ( patch );
-            IntVector h = get_high ( patch ) + IntVector (
-                              patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 1 : 0,
-                              patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 1 : 0,
-                              0
-                          );
-            Point p0 = get_position ( patch, l );
-
-            VtkFile * out_vtk = new VtkFile ( out_path + "/" + time_path + "/rf" + level_path, patch->getID() );
-            out_vtk->set_grid ( patch->getLevel()->dCell().x(), patch->getLevel()->dCell().y(), patch->getLevel()->dCell().z(), h.x() - l.x(), h.y() - l.y(), h.z() - l.z(), p0.x(), p0.y(), p0.z() );
-            out_vtk->add_cell_data ( m_regridder->getRefineFlagLabel()->getName() + "/" + std::to_string ( levelID ), flag_refine, flag_refine.getLowIndex(), flag_refine.getHighIndex() );
-            out_vtk->save();
-            out_pvtk->add ( out_vtk->file_name() );
-            delete out_vtk;
-        }
-#endif
-    }
-
-#ifdef CUSTOM_OUT
-    if ( out_pvtk )
-    {
-        out_pvtk->save();
-
-        if ( rf_out_visit.find ( levelID ) == rf_out_visit.end() )
-        {
-            rf_out_visit.emplace ( levelID, new VisitFile ( m_output->getOutputLocation(), "rf_level" + std::to_string ( levelID ), false ) );
-        }
-        rf_out_visit[levelID]->add ( time_path + "/rf" + level_path + "/" + out_pvtk->file_name() );
-        delete out_pvtk;
-    }
-#endif
-
-    dbg_out2 << std::endl;
-}
-
-void AMRNCHeat2D::forward_euler_time_advance_refinement ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4], ConstVariable u_coarse_old )
-{
-    const Level * level = patch->getLevel();
-
-    const double d ( face / 2 );
-    const double h ( level->dCell() [d] );
-
-    const double dx ( level->dCell().x() );
-//  const double dy ( level->dCell().y() );
-
-    const IntVector nl = get_low ( patch );
-    const IntVector nh = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    const IntVector n0 ( i, j, k );
-    const IntVector nm = n0 - patch->faceDirection ( face );
-    const IntVector np = n0 + patch->faceDirection ( face );
-
-    const IntVector nw ( i - 1, j, k );
-    const IntVector ne ( i + 1, j, k );
-//  const IntVector ns ( i, j - 1,  k );
-//  const IntVector nn ( i, j + 1,  k );
-
-    if ( bc_kind[face] == "Dirichlet" )
-    {
-        u_new[n0] = bc_value[face];
-        if ( is_internal ( patch, nm, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on nm
-        {
-            u_new[nm] += ( delt * alpha * ( bc_value[face] - u_old[n0] ) ) / ( h * h );
-        }
-        return;
-    }
-
-    if ( bc_kind[face] == "Neumann" )
-    {
-        double delta_u = delt * alpha;
-        const double sgn ( patch->faceDirection ( face ) [d] );
-        double uxx = 0.;
-        double uyy = 0.;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            uxx = sgn * 2. * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_nw = interpolate_coarser ( nw, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old[ne] + u_old_nw - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ne = interpolate_coarser ( ne, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old_ne + u_old[nw] - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            uyy = sgn * 2. * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            delta_u *=  uxx + uyy;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[n0] = u_old[n0] + delta_u;
-        return;
-    }
-
-    if ( bc_kind[face] == "FineCoarseInterface" )
-    {
-        double delta_u = delt * alpha;
-        double uxx = 0.;
-        double uyy = 0.;
-
-        double u_old_np;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            u_old_np = interpolate_coarser ( np, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-            uxx = ( u_old[nm] + u_old_np - 2. * u_old[n0] ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_nw = interpolate_coarser ( nw, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old[ne] + u_old_nw - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ne = interpolate_coarser ( ne, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old_ne + u_old[nw] - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            u_old_np = interpolate_coarser ( np, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-            uyy = ( u_old[nm] + u_old_np - 2. * u_old[n0] ) / ( h * h );
-            delta_u *= uxx + uyy;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[n0] = u_old[n0] + delta_u;
-        return;
-    }
-
-    std::ostringstream msg;
-    msg << "\n ERROR: Unknown BC condition (" << bc_kind[face] << ") on patch " << *patch << " face " << face << "\n";
-    throw InvalidValue ( msg.str(), __FILE__, __LINE__ );
-}
-
-void Uintah::AMRNCHeat2D::refine ( int i_fine, int j_fine, int k_fine, const Uintah::Level * level_fine, const Uintah::Level * level_coarse, ConstVariableView u_coarse, VariableView u_fine )
-{
-    IntVector node_fine ( i_fine, j_fine, k_fine );
-    u_fine[node_fine] = interpolate_coarser ( node_fine, level_fine, level_coarse, u_coarse );
-}
-
-void Uintah::AMRNCHeat2D::coarsen ( int i_coarse, int j_coarse, int k_coarse, const Uintah::Level * level_coarse, const Uintah::Level * level_fine, ConstVariableView u_fine, VariableView u_coarse )
-{
-    IntVector node_coarse ( i_coarse, j_coarse, k_coarse );
-    u_coarse[node_coarse] = restrict_finer ( node_coarse, level_coarse, level_fine, u_fine );
-}
-
-void Uintah::AMRNCHeat2D::error_estimate ( int i, int j, int k, const Uintah::Patch * patch, ConstVariableView u, FlagView flag_refine, bool & refine_patch, const double & refine_threshold )
-{
-    Vector d ( patch->dCell() );
-
-    double u_x_0 = ( u ( i + 1, j,     k ) - u ( i,     j,     k ) ) / d.x();
-    double u_x_1 = ( u ( i + 1, j + 1, k ) - u ( i,     j + 1, k ) ) / d.x();
-    double u_y_0 = ( u ( i,     j + 1, k ) - u ( i,     j,     k ) ) / d.y();
-    double u_y_1 = ( u ( i + 1, j + 1, k ) - u ( i + 1, j,     k ) ) / d.y();
-    bool tmp = u_x_0 * u_x_0 > refine_threshold ||
-               u_x_1 * u_x_1 > refine_threshold ||
-               u_y_0 * u_y_0 > refine_threshold ||
-               u_y_1 * u_y_1 > refine_threshold;
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-double AMRNCHeat2D::interpolate_coarser ( const IntVector & node_fine, const Level * level_fine, const Level * level_coarse, ConstVariableView u_coarse )
-{
-    IntVector node_coarse ( level_fine->mapNodeToCoarser ( node_fine ) );
-    Point point_fine ( level_fine->getNodePosition ( node_fine ) );
-    Point point_coarse ( level_coarse->getNodePosition ( node_coarse ) );
-    Vector dist = ( point_fine.asVector() - point_coarse.asVector() ) / level_coarse->dCell();
-    double w00 ( 1 ), w01 ( 1 ), w10 ( 1 ), w11 ( 1 );
-    IntVector n00 ( node_coarse ), n01 ( node_coarse ), n10 ( node_coarse ), n11 ( node_coarse );
-    if ( dist.x() < 0. )
-    {
-        n00[0] = n01[0] -= 1;
-        w00 *= -dist.x();
-        w01 *= -dist.x();
-        w10 *= ( 1 + dist.x() );
-        w11 *= ( 1 + dist.x() );
-    }
-    else if ( dist.x() > 0. )
-    {
-        n10[0] = n11[0] += 1;
-        w00 *= ( 1 - dist.x() );
-        w01 *= ( 1 - dist.x() );
-        w10 *= dist.x();
-        w11 *= dist.x();
-    }
-    else
-    {
-        w10 = 0.;
-        w11 = 0.;
-    }
-
-    if ( dist.y() < 0. )
-    {
-        n00[1] = n10[1] -= 1;
-        w00 *= -dist.y();
-        w10 *= -dist.y();
-        w01 *= ( 1 + dist.y() );
-        w11 *= ( 1 + dist.y() );
-    }
-    else if ( dist.y() > 0. )
-    {
-        n01[1] = n11[1] += 1;
-        w00 *= ( 1 - dist.y() );
-        w10 *= ( 1 - dist.y() );
-        w01 *= dist.y();
-        w11 *= dist.y();
-    }
-    else
-    {
-        w01 = 0.;
-        w11 = 0.;
-    }
-
-    return w00 * u_coarse[n00] +
-           w01 * u_coarse[n01] +
-           w10 * u_coarse[n10] +
-           w11 * u_coarse[n11];
-}
-
-double AMRNCHeat2D::restrict_finer ( const IntVector & node_coarse, const Level * level_coarse, const Level * level_fine, ConstVariableView u_fine )
-{
-    IntVector node_fine ( level_coarse->mapNodeToFiner ( node_coarse ) );
-
-    Point point_coarse ( level_coarse->getNodePosition ( node_coarse ) );
-    Point point_fine ( level_fine->getNodePosition ( node_fine ) );
-
-    assert ( ( point_fine.asVector() - point_coarse.asVector() ).length() == 0 );
-
-    return u_fine[node_fine];
-}
diff --git a/src/CCA/Components/Heat/AMRNCHeat2D.h b/src/CCA/Components/Heat/AMRNCHeat2D.h
deleted file mode 100644
index 585bfaf3..00000000
--- a/src/CCA/Components/Heat/AMRNCHeat2D.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_AMRNCHeat2D_h
-#define Packages_Uintah_CCA_Components_Heat_AMRNCHeat2D_h
-
-#include <Core/Grid/Variables/CCVariable.h>
-#include <CCA/Components/Heat/NCHeat2D.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-namespace Uintah
-{
-
-class AMRNCHeat2D : public NCHeat2D
-{
-protected:
-    using FlagVariable = CCVariable<int>;
-#ifdef UINTAH_ENABLE_KOKKOS
-    using FlagView = KokkosView3<int>;
-#else
-    using FlagView = FlagVariable & ;
-#endif
-
-    using NCHeat2D::get_view;
-    static constexpr inline FlagView get_view ( FlagVariable & var );
-
-    static inline IntVector map_to_coarser ( Level const * level, IntVector const & i );
-    static inline IntVector map_to_finer ( Level const * level, IntVector const & i );
-    static inline BlockRange get_flag_range ( Patch const * patch );
-
-protected:
-    double refine_threshold;
-#ifdef CUSTOM_OUT
-    std::map<int, VisitFile *> rf_out_visit;
-#endif
-
-public:
-    AMRNCHeat2D ( const ProcessorGroup * myworld,
-		  const MaterialManagerP materialManager,
-		  int verbosity = 0 );
-  
-    virtual ~AMRNCHeat2D ();
-
-protected:
-    AMRNCHeat2D ( AMRNCHeat2D const & ) = delete;
-    AMRNCHeat2D & operator= ( AMRNCHeat2D const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-    virtual void scheduleRefine ( PatchSet const * patches, SchedulerP & sched ) override;
-    virtual void scheduleRefineInterface ( LevelP const & /*level_fine*/, SchedulerP & /*sched*/, bool /*need_old_coarse*/, bool /*need_new_coarse*/ ) override {};
-    virtual void scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-
-    void scheduleTimeAdvance_forward_euler_refinement ( LevelP const & level, SchedulerP & );
-
-    void task_forward_euler_time_advance_refinement ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_refine ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_coarsen ( ProcessorGroup const * myworld, PatchSubset const * patches_coarse, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_error_estimate ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-
-    void forward_euler_time_advance_refinement ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4], ConstVariable u_coarse_old );
-    void refine ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstVariableView u_coarse, VariableView u_fine );
-    void coarsen ( int i_coarse, int j_coarse, int k_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine, VariableView u_coarse );
-    void error_estimate ( int i, int j, int k, Patch const * patch, ConstVariableView u, FlagView flag_refine, bool & refine_patch, double const & refine_threshold );
-    
-    double interpolate_coarser ( const IntVector & node_fine, Level const * level_fine, Level const * level_coarse, ConstVariableView u_coarse );
-    double restrict_finer (const IntVector & node_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine );
-}; // class AMRNCHeat2D
-
-} // namespace Uintah
-
-constexpr inline Uintah::AMRNCHeat2D::FlagView Uintah::AMRNCHeat2D::get_view ( FlagVariable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-inline Uintah::IntVector Uintah::AMRNCHeat2D::map_to_coarser ( Level const * level, IntVector const & i )
-{
-    return level->mapNodeToCoarser ( i );
-}
-
-inline Uintah::IntVector Uintah::AMRNCHeat2D::map_to_finer ( Level const * level, IntVector const & i )
-{
-    return level->mapNodeToFiner ( i );
-}
-
-inline Uintah::BlockRange Uintah::AMRNCHeat2D::get_flag_range ( Patch const * patch )
-{
-    return { patch->getCellLowIndex(), patch->getCellHighIndex() };
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_AMRNCHeat2D_h
diff --git a/src/CCA/Components/Heat/AMRNCHeat3D.cc b/src/CCA/Components/Heat/AMRNCHeat3D.cc
deleted file mode 100644
index 85993cb7..00000000
--- a/src/CCA/Components/Heat/AMRNCHeat3D.cc
+++ /dev/null
@@ -1,926 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <CCA/Components/Heat/AMRNCHeat3D.h>
-
-#include <Core/Exceptions/InvalidValue.h>
-#include <Core/Grid/Variables/PerPatch.h>
-#include <CCA/Components/Heat/blockrange_io.h>
-#include <Core/Grid/Variables/PerPatchVars.h>
-#include <CCA/Ports/Regridder.h>
-
-#ifdef CUSTOM_OUT
-#include <iomanip>
-#include <sstream>
-#include <Core/OS/Dir.h>
-#include <CCA/Components/Heat/vtkfile.hpp>
-#include <CCA/Components/Heat/pvtkfile.hpp>
-#endif
-
-using namespace Uintah;
-
-AMRNCHeat3D::AMRNCHeat3D ( const ProcessorGroup * myworld,
-			   const MaterialManagerP materialManager,
-			   int verbosity )
-  : NCHeat3D ( myworld, materialManager, verbosity )
-{}
-
-AMRNCHeat3D::~AMRNCHeat3D ()
-{}
-
-void AMRNCHeat3D::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid )
-{
-    NCHeat3D::problemSetup ( params, restart_prob_spec, grid );
-
-    ProblemSpecP diffusion = params->findBlock ( "FDHeat" );
-    diffusion->require ( "refine_threshold", refine_threshold );
-}
-
-void AMRNCHeat3D::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    GridP grid = level->getGrid();
-
-    switch ( time_scheme )
-    {
-    case TimeScheme::ForwardEuler:
-        if ( level->hasCoarserLevel() )
-        {
-            scheduleTimeAdvance_forward_euler_refinement ( level, sched );
-        }
-        else
-        {
-            scheduleTimeAdvance_forward_euler ( level, sched );
-        }
-        break;
-    case TimeScheme::BackwardEuler:
-//      if ( solver->getName() == "hypre" )
-//      {
-//          scheduleTimeAdvance_backward_euler_assemble ( level, sched );
-//          scheduleTimeAdvance_backward_euler_solve ( level, sched );
-//      }
-//      if ( solver->getName() == "hypreamr" )
-//      {
-//          if ( level->getIndex() != 0 )
-//          {
-//              return;    // only schedule on the coarsest level.
-//          }
-//
-//          // all assemble task must be sent to the scheduler before the solve task
-//          for ( int l = 0; l < grid->numLevels(); ++l )
-//          {
-//              scheduleTimeAdvance_backward_euler_assemble ( grid->getLevel ( l ), sched );
-//          }
-//
-//          scheduleTimeAdvance_backward_euler_solve ( level, sched );
-//      }
-//      break;
-        throw InternalError ( "\n ERROR: BackwardEuler time scheme not implemented for node centered variables\n", __FILE__, __LINE__ );
-    default:
-        throw InternalError ( "\n ERROR: Unknown time scheme\n", __FILE__, __LINE__ );
-    }
-}
-
-void AMRNCHeat3D::scheduleRefine ( PatchSet const * patches, SchedulerP & sched )
-{
-    if ( getLevel ( patches )->hasCoarserLevel() )
-    {
-        Task * task = scinew Task ( "AMRNCHeat3D::task_refine", this, &AMRNCHeat3D::task_refine );
-        task->requires ( Task::NewDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::AroundNodes, 1 );
-        task->computes ( u_label );
-        sched->addTask ( task, patches, m_materialManager->allMaterials() );
-    }
-}
-
-void AMRNCHeat3D::scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRNCHeat3D::task_coarsen", this, &AMRNCHeat3D::task_coarsen );
-    task->requires ( Task::NewDW, u_label, 0, Task::FineLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-    task->modifies ( u_label );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRNCHeat3D::scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRNCHeat3D::task_error_estimate", this, &AMRNCHeat3D::task_error_estimate );
-    task->requires ( Task::NewDW, u_label, Ghost::AroundNodes, 1 ); // this is actually the old value of this
-    task->modifies ( m_regridder->getRefineFlagLabel(), m_regridder->refineFlagMaterials() );
-    task->modifies ( m_regridder->getRefinePatchFlagLabel(), m_regridder->refineFlagMaterials() );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRNCHeat3D::scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    scheduleErrorEstimate ( level_coarse, sched );
-}
-
-void AMRNCHeat3D::scheduleTimeAdvance_forward_euler_refinement ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRNCHeat3D::task_forward_euler_time_advance_refinement", this, &AMRNCHeat3D::task_forward_euler_time_advance_refinement );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundNodes, 1 );
-    task->requires ( Task::OldDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::AroundNodes, 1 );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void AMRNCHeat3D::task_forward_euler_time_advance_refinement ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRNCHeat3D::task_farward_euler_time_advance_refinement ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u_old;
-        dw_old->get ( u_old, u_label, 0, patch, Ghost::AroundNodes, 1 );
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-
-        Variable u_new;
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ) ); } );
-
-        std::string bc_kind[6];
-        double bc_value[6];
-        ConstVariable u_coarse_old;
-        bool get_coarser = true;
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                if ( patch->getBCType ( face ) == Patch::Coarse && get_coarser )
-                {
-                    const Level * level = patch->getLevel();
-                    const Level * level_coarse = level->getCoarserLevel().get_rep();
-                    IntVector l = get_low ( patch );
-                    IntVector h = get_high ( patch );
-                    IntVector l_coarse = map_to_coarser ( level, l ) - IntVector ( 1, 1, 1 );
-                    IntVector h_coarse = map_to_coarser ( level, h ) + IntVector ( 1, 1, 1 );
-
-                    dw_old->getRegion ( u_coarse_old, u_label, 0, level_coarse, l_coarse, h_coarse );
-                    get_coarser = false;
-                }
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " - BC " << bc_kind[face] << " " << bc_value[face] << " face direction" << patch->faceDirection ( face ) << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u_old, &u_coarse_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance_refinement ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ), face, bc_kind, bc_value, u_coarse_old ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRNCHeat3D::task_refine ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches_fine, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRNCHeat3D::task_refine ====" << std::endl;
-
-    const Level * level_fine = getLevel ( patches_fine );
-    const Level * level_coarse = level_fine->getCoarserLevel().get_rep();
-
-    for ( int p = 0; p < patches_fine->size(); ++p )
-    {
-        const Patch * patch_fine = patches_fine->get ( p );
-        dbg_out2 << "== Fine Patch: " << *patch_fine << std::endl;
-
-        Variable u_fine;
-        dw_new->allocateAndPut ( u_fine, u_label, 0, patch_fine );
-        dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-        IntVector l_fine = get_low ( patch_fine );
-        IntVector h_fine = get_high ( patch_fine );
-
-        IntVector l_coarse = map_to_coarser ( level_fine, l_fine );
-        IntVector h_coarse = map_to_coarser ( level_fine, h_fine );
-        // Extening in order to select nodes on right edges
-        h_coarse += IntVector ( 1, 1, 1 );
-
-        dbg_out4 << "fine range" << BlockRange ( l_fine, h_fine ) << std::endl;
-        dbg_out4 << "coarse range" << BlockRange ( l_coarse, h_coarse ) << std::endl;
-
-        ConstVariable u_coarse;
-        dw_new->getRegion ( u_coarse, u_label, 0, level_coarse, l_coarse, h_coarse );
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        BlockRange range_fine ( l_fine, h_fine );
-        dbg_out3 << "= Iterating over fine range" << range_fine << std::endl;
-        parallel_for ( range_fine, [level_fine, level_coarse, &u_coarse, &u_fine, this] ( int i, int j, int k )->void { refine ( i, j, k, level_fine, level_coarse, get_view ( u_coarse ), get_view ( u_fine ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRNCHeat3D::task_coarsen ( ProcessorGroup const * /*myworld*/, const PatchSubset * patches_coarse, const MaterialSubset * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRNCHeat3D::task_coarsen " << std::endl;
-
-    const Level * level_coarse = getLevel ( patches_coarse );
-    const Level * level_fine = level_coarse->getFinerLevel().get_rep();
-
-    for ( int p = 0; p < patches_coarse->size(); ++p )
-    {
-        const Patch * patch_coarse = patches_coarse->get ( p );
-        dbg_out2 << "== Coarse Patch: " << *patch_coarse << std::endl;
-
-        Variable u_coarse;
-        dw_new->getModifiable ( u_coarse, u_label, 0, patch_coarse );
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        IntVector l_coarse = get_low ( patch_coarse );
-        IntVector h_coarse = get_high ( patch_coarse );
-
-        IntVector l_fine = map_to_finer ( level_coarse, l_coarse );
-        IntVector h_fine = map_to_finer ( level_coarse, h_coarse );
-
-        Level::selectType patches_fine;
-        level_fine->selectPatches ( l_fine, h_fine, patches_fine );
-
-        for ( unsigned int i = 0; i < patches_fine.size(); ++i )
-        {
-            const Patch * patch_fine = patches_fine[i];
-            dbg_out3 << "= Fine Patch " << *patch_fine << std::endl;
-
-            ConstVariable u_fine;
-            dw_new->get ( u_fine, u_label, 0, patch_fine, Ghost::None, 0 );
-            dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-            BlockRange range_coarse (
-                Max ( l_coarse, map_to_coarser ( level_fine, get_low ( patch_fine ) ) ),
-                Min ( h_coarse, map_to_coarser ( level_fine, get_high ( patch_fine ) ) )
-            );
-
-            dbg_out3 << "= Iterating over coarse cells window " << range_coarse << std::endl;
-            parallel_for ( range_coarse, [level_coarse, level_fine, &u_fine, &u_coarse, this] ( int i, int j, int k )->void { coarsen ( i, j, k, level_coarse, level_fine, get_view ( u_fine ), get_view ( u_coarse ) ); } );
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void AMRNCHeat3D::task_error_estimate ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRNCHeat3D::task_error_estimate " << std::endl;
-
-#ifdef CUSTOM_OUT
-    PVtkFile * out_pvtk = nullptr;
-    const Level * level = getLevel ( patches );
-    const int & levelID = level->getIndex();
-    const int & timestep = getTimestep();
-    std::string out_path, time_path, level_path, patch_path;
-
-    if ( timestep + 1 >= dataArchiver->getNextOutputTimestep() )
-    {
-        dbg_out1 << "==== AMRNCHeat3D::task_save" << std::endl;
-        std::stringstream time_ss, level_ss;
-        out_path = dataArchiver->getOutputLocation();
-        time_ss << "t" << std::setw ( 5 ) << std::setfill ( '0' ) << timestep;
-        level_ss << "l" << levelID;
-        time_path = time_ss.str();
-        level_path = level_ss.str();
-        MKDIR ( std::string ( out_path + "/" + time_path ).c_str(), 0777 );
-        MKDIR ( std::string ( out_path + "/" + time_path + "/rf" + level_path ).c_str(), 0777 );
-
-        // WARNING only for one process/thread
-
-        out_pvtk = new PVtkFile ( out_path +  "/" + time_path + "/rf" + level_path, time_path, timestep * delt );
-    }
-#endif
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        FlagVariable flag_refine;
-        PerPatch<PatchFlagP> flag_refine_patch;
-        dw_new->getModifiable ( flag_refine, m_regridder->getRefineFlagLabel(), 0, patch );
-        dw_new->get ( flag_refine_patch, m_regridder->getRefinePatchFlagLabel(), 0, patch );
-        dbg_out4 << "flag_refine \t window " << flag_refine.getLowIndex() << flag_refine.getHighIndex() << std::endl;
-
-        PatchFlag * patch_flag_refine = flag_refine_patch.get().get_rep();
-        ConstVariable u;
-        dw_new->get ( u, u_label, 0, patch, Ghost::AroundNodes, 1 );
-        dbg_out4 << "u \t window " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        bool refine_patch = false;
-        BlockRange range = get_flag_range ( patch );
-        dbg_out3 << "= Iterating over cells window " << range << std::endl;
-        Uintah::parallel_reduce_sum ( range, [patch, &u, &flag_refine, this] ( int i, int j, int k, bool & refine_patch )->void { error_estimate ( i, j, k, patch, get_view ( u ), get_view ( flag_refine ), refine_patch, refine_threshold ); }, refine_patch );
-
-        if ( refine_patch )
-        {
-            patch_flag_refine->set();
-        }
-
-#ifdef CUSTOM_OUT
-        if ( out_pvtk )
-        {
-            IntVector l = get_low ( patch );
-            IntVector h = get_high ( patch ) + IntVector (
-                              patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 1 : 0,
-                              patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 1 : 0,
-                              0
-                          );
-            Point p0 = get_position ( patch, l );
-
-            VtkFile * out_vtk = new VtkFile ( out_path + "/" + time_path + "/rf" + level_path, patch->getID() );
-            out_vtk->set_grid ( patch->getLevel()->dCell().x(), patch->getLevel()->dCell().y(), patch->getLevel()->dCell().z(), h.x() - l.x(), h.y() - l.y(), h.z() - l.z(), p0.x(), p0.y(), p0.z() );
-            out_vtk->add_cell_data ( m_regridder->getRefineFlagLabel()->getName() + "/" + std::to_string ( levelID ), flag_refine, flag_refine.getLowIndex(), flag_refine.getHighIndex() );
-            out_vtk->save();
-            out_pvtk->add ( out_vtk->file_name() );
-            delete out_vtk;
-        }
-#endif
-    }
-
-#ifdef CUSTOM_OUT
-    if ( out_pvtk )
-    {
-        out_pvtk->save();
-
-        if ( rf_out_visit.find ( levelID ) == rf_out_visit.end() )
-        {
-            rf_out_visit.emplace ( levelID, new VisitFile ( dataArchiver->getOutputLocation(), "rf_level" + std::to_string ( levelID ), false ) );
-        }
-        rf_out_visit[levelID]->add ( time_path + "/rf" + level_path + "/" + out_pvtk->file_name() );
-        delete out_pvtk;
-    }
-#endif
-
-    dbg_out2 << std::endl;
-}
-
-void AMRNCHeat3D::forward_euler_time_advance_refinement ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4], ConstVariable u_coarse_old )
-{
-    const Level * level = patch->getLevel();
-
-    const double d ( face / 2 );
-    const double h ( level->dCell() [d] );
-
-    const double dx ( level->dCell().x() );
-    const double dy ( level->dCell().y() );
-//  const double dz ( level->dCell().z() );
-
-    const IntVector nl = get_low ( patch );
-    const IntVector nh = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    const IntVector n0 ( i, j, k );
-    const IntVector nm = n0 - patch->faceDirection ( face );
-    const IntVector np = n0 + patch->faceDirection ( face );
-
-    const IntVector nw ( i - 1, j, k );
-    const IntVector ne ( i + 1, j, k );
-    const IntVector ns ( i, j - 1,  k );
-    const IntVector nn ( i, j + 1,  k );
-//  const IntVector ns ( i, j,  k - 1 );
-//  const IntVector nn ( i, j,  k + 1 );
-
-    if ( bc_kind[face] == "Dirichlet" )
-    {
-        u_new[n0] = bc_value[face];
-        if ( is_internal ( patch, nm, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on nm
-        {
-            u_new[nm] += ( delt * alpha * ( bc_value[face] - u_old[n0] ) ) / ( h * h );
-        }
-        return;
-    }
-
-    if ( bc_kind[face] == "Neumann" )
-    {
-        double delta_u = delt * alpha;
-        const double sgn ( patch->faceDirection ( face ) [d] );
-        double uxx = 0.;
-        double uyy = 0.;
-        double uzz = 0.;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            if ( k == nl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == nh.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            uxx = sgn * 2. * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy + uzz;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( k == nl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == nh.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_nw = interpolate_coarser ( nw, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old[ne] + u_old_nw - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ne = interpolate_coarser ( ne, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old_ne + u_old[nw] - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            uyy = sgn * 2. * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        case Patch::zminus:
-        case Patch::zplus:
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_nw = interpolate_coarser ( nw, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old[ne] + u_old_nw - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ne = interpolate_coarser ( ne, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old_ne + u_old[nw] - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yminus] == "Neumann" )
-                {
-                    uyy = ( u_old[nn] - u_old[n0] - bc_value[Patch::yminus] * dy ) / ( dy * dy );
-                }
-                else if ( bc_kind[Patch::yminus] == "FineCoarseInterface" )
-                {
-                    double u_old_ns = interpolate_coarser ( ns, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uyy = ( u_old[nn] + u_old_ns - 2. * u_old[n0] ) / ( dy * dy );
-                }
-            }
-            else if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yplus] == "Neumann" )
-                {
-                    uyy = ( u_old[n0] - u_old[ns] + bc_value[Patch::yplus] * dy ) / ( dy * dy );
-                }
-                else if ( bc_kind[Patch::yplus] == "FineCoarseInterface" )
-                {
-                    double u_old_nn = interpolate_coarser ( nn, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uyy = ( u_old_nn + u_old[ns] - 2. * u_old[n0] ) / ( dy * dy );
-                }
-            }
-            else
-            {
-                uyy = dyy ( i, j, k, patch, u_old );
-            }
-            uzz = sgn * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[n0] = u_old[n0] + delta_u;
-        return;
-    }
-
-    if ( bc_kind[face] == "FineCoarseInterface" )
-    {
-        double delta_u = delt * alpha;
-        double uxx = 0.;
-        double uyy = 0.;
-        double uzz = 0.;
-
-        double u_old_np;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            if ( k == nl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == nh.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            u_old_np = interpolate_coarser ( np, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-            uxx = ( u_old[nm] + u_old_np - 2. * u_old[n0] ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy + uzz;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( k == nl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == nh.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_nw = interpolate_coarser ( nw, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old[ne] + u_old_nw - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ne = interpolate_coarser ( ne, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old_ne + u_old[nw] - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            u_old_np = interpolate_coarser ( np, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-            uyy = ( u_old[nm] + u_old_np - 2. * u_old[n0] ) / ( h * h );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy + uzz;
-            break;
-        case Patch::zminus:
-        case Patch::zplus:
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xminus] == "FineCoarseInterface" )
-                {
-                    double u_old_nw = interpolate_coarser ( nw, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old[ne] + u_old_nw - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-                else if ( bc_kind[Patch::xplus] == "FineCoarseInterface" )
-                {
-                    double u_old_ne = interpolate_coarser ( ne, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uxx = ( u_old_ne + u_old[nw] - 2. * u_old[n0] ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yminus] == "Neumann" )
-                {
-                    uyy = 2. * ( u_old[nn] - u_old[n0] - bc_value[Patch::yminus] * dy ) / ( dy * dy );
-                }
-                else if ( bc_kind[Patch::yminus] == "FineCoarseInterface" )
-                {
-                    double u_old_ns = interpolate_coarser ( ns, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uyy = ( u_old[nn] + u_old_ns - 2. * u_old[n0] ) / ( dy * dy );
-                }
-            }
-            else if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yplus] == "Neumann" )
-                {
-                    uyy = 2. * ( u_old[n0] - u_old[ns] + bc_value[Patch::yplus] * dy ) / ( dy * dy );
-                }
-                else if ( bc_kind[Patch::yplus] == "FineCoarseInterface" )
-                {
-                    double u_old_nn = interpolate_coarser ( nn, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-                    uyy = ( u_old_nn + u_old[ns] - 2. * u_old[n0] ) / ( dy * dy );
-                }
-            }
-            else
-            {
-                uyy = dyy ( i, j, k, patch, u_old );
-            }
-            u_old_np = interpolate_coarser ( np, level, level->getCoarserLevel().get_rep(), u_coarse_old );
-            uzz = ( u_old[nm] + u_old_np - 2 * u_old[n0] ) / ( h * h );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[n0] = u_old[n0] + delta_u;
-        return;
-    }
-
-    std::ostringstream msg;
-    msg << "\n ERROR: Unknown BC condition (" << bc_kind[face] << ") on patch " << *patch << " face " << face << "\n";
-    throw InvalidValue ( msg.str(), __FILE__, __LINE__ );
-}
-
-void Uintah::AMRNCHeat3D::refine ( int i_fine, int j_fine, int k_fine, const Uintah::Level * level_fine, const Uintah::Level * level_coarse, ConstVariableView u_coarse, VariableView u_fine )
-{
-    IntVector node_fine ( i_fine, j_fine, k_fine );
-    u_fine[node_fine] = interpolate_coarser ( node_fine, level_fine, level_coarse, u_coarse );
-}
-
-void Uintah::AMRNCHeat3D::coarsen ( int i_coarse, int j_coarse, int k_coarse, const Uintah::Level * level_coarse, const Uintah::Level * level_fine, ConstVariableView u_fine, VariableView u_coarse )
-{
-    IntVector node_coarse ( i_coarse, j_coarse, k_coarse );
-    u_coarse[node_coarse] = restrict_finer ( node_coarse, level_coarse, level_fine, u_fine );
-}
-
-void Uintah::AMRNCHeat3D::error_estimate ( int i, int j, int k, const Uintah::Patch * patch, ConstVariableView u, FlagView flag_refine, bool & refine_patch, const double & refine_threshold )
-{
-    Vector d ( patch->dCell() );
-
-    double u_x_00 = ( u ( i + 1, j,     k ) - u ( i,     j,     k ) ) / d.x();
-    double u_x_01 = ( u ( i + 1, j,     k + 1 ) - u ( i,     j,     k + 1 ) ) / d.x();
-    double u_x_10 = ( u ( i + 1, j + 1, k ) - u ( i,     j + 1, k ) ) / d.x();
-    double u_x_11 = ( u ( i + 1, j + 1, k + 1 ) - u ( i,     j + 1, k + 1 ) ) / d.x();
-    double u_y_00 = ( u ( i,     j + 1, k ) - u ( i,     j,     k ) ) / d.y();
-    double u_y_01 = ( u ( i,     j + 1, k + 1 ) - u ( i,     j,     k + 1 ) ) / d.y();
-    double u_y_10 = ( u ( i + 1, j + 1, k ) - u ( i + 1, j,     k ) ) / d.y();
-    double u_y_11 = ( u ( i + 1, j + 1, k + 1 ) - u ( i + 1, j,     k + 1 ) ) / d.y();
-    double u_z_00 = ( u ( i,     j,     k + 1 ) - u ( i,     j,     k ) ) / d.z();
-    double u_z_01 = ( u ( i,     j + 1, k + 1 ) - u ( i,     j + 1, k ) ) / d.z();
-    double u_z_10 = ( u ( i + 1, j,     k + 1 ) - u ( i + 1, j,     k ) ) / d.z();
-    double u_z_11 = ( u ( i + 1, j + 1, k + 1 ) - u ( i + 1, j + 1, k ) ) / d.z();
-
-    bool tmp = u_x_00 * u_x_00 > refine_threshold ||
-               u_x_01 * u_x_01 > refine_threshold ||
-               u_x_10 * u_x_10 > refine_threshold ||
-               u_x_11 * u_x_11 > refine_threshold ||
-               u_y_00 * u_y_00 > refine_threshold ||
-               u_y_01 * u_y_01 > refine_threshold ||
-               u_y_10 * u_y_10 > refine_threshold ||
-               u_y_11 * u_y_11 > refine_threshold ||
-               u_z_00 * u_z_00 > refine_threshold ||
-               u_z_01 * u_z_01 > refine_threshold ||
-               u_z_10 * u_z_10 > refine_threshold ||
-               u_z_11 * u_z_11 > refine_threshold;
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-double AMRNCHeat3D::interpolate_coarser ( const IntVector & node_fine, const Level * level_fine, const Level * level_coarse, ConstVariableView u_coarse )
-{
-    IntVector node_coarse ( level_fine->mapNodeToCoarser ( node_fine ) );
-    Point point_fine ( level_fine->getNodePosition ( node_fine ) );
-    Point point_coarse ( level_coarse->getNodePosition ( node_coarse ) );
-    Vector dist = ( point_fine.asVector() - point_coarse.asVector() ) / level_coarse->dCell();
-    double w000 ( 1 ), w100 ( 1 ), w010 ( 1 ), w110 ( 1 ), w001 ( 1 ), w101 ( 1 ), w011 ( 1 ), w111 ( 1 );
-    IntVector n000 ( node_coarse ), n010 ( node_coarse ), n100 ( node_coarse ), n110 ( node_coarse ), n001 ( node_coarse ), n011 ( node_coarse ), n101 ( node_coarse ), n111 ( node_coarse );
-    if ( dist.x() < 0. )
-    {
-        n000[0] = n001[0] = n010[0] = n011[0] -= 1;
-        w000 *= -dist.x();
-        w001 *= -dist.x();
-        w010 *= -dist.x();
-        w011 *= -dist.x();
-        w100 *= ( 1 + dist.x() );
-        w101 *= ( 1 + dist.x() );
-        w110 *= ( 1 + dist.x() );
-        w111 *= ( 1 + dist.x() );
-    }
-    else if ( dist.x() > 0. )
-    {
-        n100[0] = n101[0] = n110[0] = n111[0] += 1;
-        w000 *= ( 1 - dist.x() );
-        w001 *= ( 1 - dist.x() );
-        w010 *= ( 1 - dist.x() );
-        w011 *= ( 1 - dist.x() );
-        w100 *= dist.x();
-        w101 *= dist.x();
-        w110 *= dist.x();
-        w111 *= dist.x();
-    }
-    else
-    {
-        w100 = 0.;
-        w101 = 0.;
-        w110 = 0.;
-        w111 = 0.;
-    }
-
-    if ( dist.y() < 0. )
-    {
-        n000[1] = n001[1] = n100[1] = n101[1] -= 1;
-        w000 *= -dist.y();
-        w001 *= -dist.y();
-        w100 *= -dist.y();
-        w101 *= -dist.y();
-        w010 *= ( 1 + dist.y() );
-        w011 *= ( 1 + dist.y() );
-        w110 *= ( 1 + dist.y() );
-        w111 *= ( 1 + dist.y() );
-    }
-    else if ( dist.y() > 0. )
-    {
-        n010[1] = n011[1] = n110[1] = n111[1] += 1;
-        w000 *= ( 1 - dist.y() );
-        w001 *= ( 1 - dist.y() );
-        w100 *= ( 1 - dist.y() );
-        w101 *= ( 1 - dist.y() );
-        w010 *= dist.y();
-        w011 *= dist.y();
-        w110 *= dist.y();
-        w111 *= dist.y();
-    }
-    else
-    {
-        w010 = 0.;
-        w011 = 0.;
-        w110 = 0.;
-        w111 = 0.;
-    }
-
-    if ( dist.z() < 0. )
-    {
-        n000[2] = n010[2] = n100[2] = n110[2] -= 1;
-        w000 *= -dist.z();
-        w010 *= -dist.z();
-        w100 *= -dist.z();
-        w110 *= -dist.z();
-        w001 *= ( 1 + dist.z() );
-        w011 *= ( 1 + dist.z() );
-        w101 *= ( 1 + dist.z() );
-        w111 *= ( 1 + dist.z() );
-    }
-    else if ( dist.z() > 0. )
-    {
-        n001[2] = n011[2] = n101[2] = n111[2] += 1;
-        w000 *= ( 1 - dist.z() );
-        w010 *= ( 1 - dist.z() );
-        w100 *= ( 1 - dist.z() );
-        w110 *= ( 1 - dist.z() );
-        w001 *= dist.z();
-        w011 *= dist.z();
-        w101 *= dist.z();
-        w111 *= dist.z();
-    }
-    else
-    {
-        w001 *= 0.;
-        w011 *= 0.;
-        w101 *= 0.;
-        w111 *= 0.;
-    }
-
-    return w000 * u_coarse[n000] +
-           w001 * u_coarse[n001] +
-           w010 * u_coarse[n010] +
-           w011 * u_coarse[n011] +
-           w100 * u_coarse[n100] +
-           w101 * u_coarse[n101] +
-           w110 * u_coarse[n110] +
-           w111 * u_coarse[n111];
-};
-
-double Uintah::AMRNCHeat3D::restrict_finer ( const IntVector & node_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine )
-{
-    IntVector node_fine ( level_coarse->mapNodeToFiner ( node_coarse ) );
-
-    Point point_coarse ( level_coarse->getNodePosition ( node_coarse ) );
-    Point point_fine ( level_fine->getNodePosition ( node_fine ) );
-
-    assert ( ( point_fine.asVector() - point_coarse.asVector() ).length() == 0 );
-
-    return u_fine[node_fine];
-};
-
-
-
diff --git a/src/CCA/Components/Heat/AMRNCHeat3D.h b/src/CCA/Components/Heat/AMRNCHeat3D.h
deleted file mode 100644
index 5190127a..00000000
--- a/src/CCA/Components/Heat/AMRNCHeat3D.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_AMRNCHeat3D_h
-#define Packages_Uintah_CCA_Components_Heat_AMRNCHeat3D_h
-
-#include <Core/Grid/Variables/CCVariable.h>
-#include <CCA/Components/Heat/NCHeat3D.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-namespace Uintah
-{
-
-class AMRNCHeat3D : public NCHeat3D
-{
-protected:
-    using FlagVariable = CCVariable<int>;
-#ifdef UINTAH_ENABLE_KOKKOS
-    using FlagView = KokkosView3<int>;
-#else
-    using FlagView = FlagVariable & ;
-#endif
-
-    using NCHeat3D::get_view;
-    static constexpr inline FlagView get_view ( FlagVariable & var );
-
-    static inline IntVector map_to_coarser ( Level const * level, IntVector const & i );
-    static inline IntVector map_to_finer ( Level const * level, IntVector const & i );
-    static inline BlockRange get_flag_range ( Patch const * patch );
-
-protected:
-    double refine_threshold;
-#ifdef CUSTOM_OUT
-    std::map<int, VisitFile *> rf_out_visit;
-#endif
-
-public:
-    AMRNCHeat3D ( const ProcessorGroup * myworld,
-		  const MaterialManagerP materialManager,
-		  int verbosity = 0 );
-  
-    virtual ~AMRNCHeat3D ();
-
-protected:
-    AMRNCHeat3D ( AMRNCHeat3D const & ) = delete;
-    AMRNCHeat3D & operator= ( AMRNCHeat3D const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-    virtual void scheduleRefine ( PatchSet const * patches, SchedulerP & sched ) override;
-    virtual void scheduleRefineInterface ( LevelP const & /*level_fine*/, SchedulerP & /*sched*/, bool /*need_old_coarse*/, bool /*need_new_coarse*/ ) override {};
-    virtual void scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-
-    void scheduleTimeAdvance_forward_euler_refinement ( LevelP const & level, SchedulerP & );
-
-    void task_forward_euler_time_advance_refinement ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_refine ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_coarsen ( ProcessorGroup const * myworld, PatchSubset const * patches_coarse, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_error_estimate ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-
-    void forward_euler_time_advance_refinement ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[6], const double bc_value[6], ConstVariable u_coarse_old );
-    void refine ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstVariableView u_coarse, VariableView u_fine );
-    void coarsen ( int i_coarse, int j_coarse, int k_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine, VariableView u_coarse );
-    void error_estimate ( int i, int j, int k, Patch const * patch, ConstVariableView u, FlagView flag_refine, bool & refine_patch, double const & refine_threshold );
-
-    double interpolate_coarser ( const IntVector & node_fine, Level const * level_fine, Level const * level_coarse, ConstVariableView u_coarse );
-    double restrict_finer ( const IntVector & node_coarse, Level const * level_coarse, Level const * level_fine, ConstVariableView u_fine );
-}; // class AMRNCHeat3D
-
-} // namespace Uintah
-
-constexpr inline Uintah::AMRNCHeat3D::FlagView Uintah::AMRNCHeat3D::get_view ( FlagVariable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-inline Uintah::IntVector Uintah::AMRNCHeat3D::map_to_coarser ( Level const * level, IntVector const & i )
-{
-    return level->mapNodeToCoarser ( i );
-}
-
-inline Uintah::IntVector Uintah::AMRNCHeat3D::map_to_finer ( Level const * level, IntVector const & i )
-{
-    return level->mapNodeToFiner ( i );
-}
-
-inline Uintah::BlockRange Uintah::AMRNCHeat3D::get_flag_range ( Patch const * patch )
-{
-    return { patch->getCellLowIndex(), patch->getCellHighIndex() };
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_AMRNCHeat3D_h
diff --git a/src/CCA/Components/Heat/CCHeat2D.cc b/src/CCA/Components/Heat/CCHeat2D.cc
deleted file mode 100644
index 974bd84e..00000000
--- a/src/CCA/Components/Heat/CCHeat2D.cc
+++ /dev/null
@@ -1,495 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <CCA/Components/Heat/CCHeat2D.h>
-
-#include <CCA/Components/Heat/blockrange_io.h>
-
-using namespace Uintah;
-
-CCHeat2D::CCHeat2D ( const ProcessorGroup * myworld,
-		     const MaterialManagerP materialManager,
-		     int verbosity )
-  : ApplicationCommon ( myworld, materialManager )
-    , dbg_out1 ( "CCHeat2D", verbosity > 0 )
-    , dbg_out2 ( "CCHeat2D", verbosity > 1 )
-    , dbg_out3 ( "CCHeat2D", verbosity > 2 )
-    , dbg_out4 ( "CCHeat2D", verbosity > 3 )
-    , solver ( nullptr )
-{
-    u_label = VarLabel::create ( "u", Variable::getTypeDescription() );
-    matrix_label = VarLabel::create ( "A", Matrix::getTypeDescription() );
-    rhs_label = VarLabel::create ( "b", Variable::getTypeDescription() );
-#ifdef DBG_MATRIX
-    Ap_label = VarLabel::create ( "Ap", Variable::getTypeDescription() );
-    Aw_label = VarLabel::create ( "Aw", Variable::getTypeDescription() );
-    Ae_label = VarLabel::create ( "Ae", Variable::getTypeDescription() );
-    An_label = VarLabel::create ( "An", Variable::getTypeDescription() );
-    As_label = VarLabel::create ( "As", Variable::getTypeDescription() );
-    At_label = VarLabel::create ( "At", Variable::getTypeDescription() );
-    Ab_label = VarLabel::create ( "Ab", Variable::getTypeDescription() );
-#endif
-}
-
-CCHeat2D::~CCHeat2D()
-{
-    VarLabel::destroy ( u_label );
-    VarLabel::destroy ( matrix_label );
-    VarLabel::destroy ( rhs_label );
-#ifdef DBG_MATRIX
-    VarLabel::destroy ( Ap_label );
-    VarLabel::destroy ( Aw_label );
-    VarLabel::destroy ( Ae_label );
-    VarLabel::destroy ( An_label );
-    VarLabel::destroy ( As_label );
-    VarLabel::destroy ( At_label );
-    VarLabel::destroy ( Ab_label );
-#endif
-}
-
-void CCHeat2D::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & /*restart_prob_spec*/, GridP & /*grid*/ )
-{
-    setLockstepAMR( true );
-
-    m_materialManager->registerSimpleMaterial ( scinew SimpleMaterial() );
-
-    ProblemSpecP heat = params->findBlock ( "FDHeat" );
-    std::string scheme;
-    heat->require ( "delt", delt );
-    heat->require ( "alpha", alpha );
-    heat->require ( "R0", r0 );
-    heat->getWithDefault ( "gamma", gamma, 1. );
-    heat->getWithDefault ( "scheme", scheme, "forward_euler" );
-    time_scheme = from_str ( scheme );
-    if ( time_scheme & TimeScheme::Implicit )
-    {
-        ProblemSpecP solv = params->findBlock ( "Solver" );
-        solver = dynamic_cast<SolverInterface *> ( getPort ( "solver" ) );
-        if ( !solver )
-        {
-            throw InternalError ( "CCHeat2D:couldn't get solver port", __FILE__, __LINE__ );
-        }
-        solver->readParameters ( solv, "u" );
-        solver->getParameters()->setSolveOnExtraCells ( false );
-    }
-}
-
-void CCHeat2D::scheduleInitialize ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "CCHeat2D::task_initialize", this, &CCHeat2D::task_initialize );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void CCHeat2D::scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "CCHeat2D::task_compute_stable_timestep", this, &CCHeat2D::task_compute_stable_timestep );
-    task->computes ( getDelTLabel(), level.get_rep() );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void CCHeat2D::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    switch ( time_scheme )
-    {
-    case TimeScheme::ForwardEuler:
-        scheduleTimeAdvance_forward_euler ( level, sched );
-        break;
-    case TimeScheme::BackwardEuler:
-        scheduleTimeAdvance_backward_euler_assemble ( level, sched );
-        scheduleTimeAdvance_backward_euler_solve ( level, sched );
-        break;
-    default:
-        break;
-    }
-}
-
-void CCHeat2D::scheduleTimeAdvance_forward_euler ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "CCHeat2D::task_farward_euler_time_advance", this, &CCHeat2D::task_farward_euler_time_advance );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundCells, 1 );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void CCHeat2D::scheduleTimeAdvance_backward_euler_assemble ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "CCHeat2D::task_backward_euler_assemble", this, &CCHeat2D::task_backward_euler_assemble );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundCells, 1 );
-    task->computes ( matrix_label );
-    task->computes ( rhs_label );
-#ifdef DBG_MATRIX
-    task->computes ( Ap_label );
-    task->computes ( Aw_label );
-    task->computes ( Ae_label );
-    task->computes ( An_label );
-    task->computes ( As_label );
-    task->computes ( At_label );
-    task->computes ( Ab_label );
-#endif
-    sched->addTask ( task, level->allPatches(), m_materialManager->allMaterials() );
-}
-
-void CCHeat2D::scheduleTimeAdvance_backward_euler_solve ( LevelP const & level, SchedulerP & sched )
-{
-    solver->scheduleSolve ( level, sched, m_materialManager->allMaterials(),
-                            matrix_label, Task::NewDW, // A
-                            u_label, false,            // x
-                            rhs_label, Task::NewDW,    // b
-                            u_label, Task::OldDW );    // guess
-}
-
-void CCHeat2D::task_initialize ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== CCHeat2D::task_initialize ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        Variable u;
-        dw_new->allocateAndPut ( u, u_label, 0, patch );
-        dbg_out4 << "u \t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        BlockRange range ( get_range ( patch ) );
-        dbg_out3 << "= Iterating over range " << range << std::endl;
-        parallel_for ( range, [patch, &u, this] ( int i, int j, int k )->void { initialize ( i, j, k, patch, get_view ( u ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void CCHeat2D::task_compute_stable_timestep ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== CCHeat2D::task_compute_stable_timestep ====" << std::endl;
-    dw_new->put ( delt_vartype ( delt ), getDelTLabel(), getLevel ( patches ) );
-    dbg_out2 << std::endl;
-}
-
-void CCHeat2D::task_farward_euler_time_advance ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== CCHeat2D::task_farward_euler_time_advance ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u_old;
-        dw_old->get ( u_old, u_label, 0, patch, Ghost::AroundCells, 1 );
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-
-        Variable u_new;
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ) ); } );
-
-        std::string bc_kind[4];
-        double bc_value[4];
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ), face, bc_kind, bc_value ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void Uintah::CCHeat2D::task_backward_euler_assemble ( const Uintah::ProcessorGroup * myworld, const PatchSubset * patches, const MaterialSubset * matls, Uintah::DataWarehouse * dw_old, Uintah::DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== CCHeat2D::task_backward_euler_assemble ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u;
-        dw_old->get ( u, u_label, 0, patch, Ghost::AroundCells, 1 );
-        dbg_out4 << "u\t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        Matrix A;
-        dw_new->allocateAndPut ( A, matrix_label, 0, patch );
-        dbg_out4 << "A \t range " << A.getLowIndex() << A.getHighIndex() << std::endl;
-
-#ifdef DBG_MATRIX
-        Variable Ap;
-        dw_new->allocateAndPut ( Ap, Ap_label, 0, patch );
-        dbg_out4 << "Ap \t range " << Ap.getLowIndex() << Ap.getHighIndex() << std::endl;
-
-        Variable Aw;
-        dw_new->allocateAndPut ( Aw, Aw_label, 0, patch );
-        dbg_out4 << "Aw \t range " << Aw.getLowIndex() << Aw.getHighIndex() << std::endl;
-
-        Variable Ae;
-        dw_new->allocateAndPut ( Ae, Ae_label, 0, patch );
-        dbg_out4 << "Ae \t range " << Ae.getLowIndex() << Ae.getHighIndex() << std::endl;
-
-        Variable An;
-        dw_new->allocateAndPut ( An, An_label, 0, patch );
-        dbg_out4 << "An \t range " << An.getLowIndex() << An.getHighIndex() << std::endl;
-
-        Variable As;
-        dw_new->allocateAndPut ( As, As_label, 0, patch );
-        dbg_out4 << "As \t range " << As.getLowIndex() << As.getHighIndex() << std::endl;
-
-        Variable At;
-        dw_new->allocateAndPut ( At, At_label, 0, patch );
-        dbg_out4 << "At \t range " << At.getLowIndex() << At.getHighIndex() << std::endl;
-
-        Variable Ab;
-        dw_new->allocateAndPut ( Ab, Ab_label, 0, patch );
-        dbg_out4 << "Ab \t range " << Ab.getLowIndex() << Ab.getHighIndex() << std::endl;
-#endif
-
-        Variable b;
-        dw_new->allocateAndPut ( b, rhs_label, 0, patch );
-        dbg_out4 << "b\t range " << b.getLowIndex() << b.getHighIndex() << std::endl;
-
-        BlockRange range ( get_range ( patch ) );
-        dbg_out3 << "= Iterating over range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u, REF_A, &b, this] ( int i, int j, int k )->void { backward_euler_assemble ( i, j, k, patch, get_view ( u ), GET_VIEW_A, get_view ( b ) ); } );
-
-        std::string bc_kind[4];
-        double bc_value[4];
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " - BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u, REF_A, &b, this] ( int i, int j, int k )->void { backward_euler_assemble ( i, j, k, patch, get_view ( u ), GET_VIEW_A, get_view ( b ), face, bc_kind, bc_value ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void CCHeat2D::initialize ( int i, int j, int k, Patch const * patch, VariableView u )
-{
-    IntVector n ( i, j, k );
-    Point p = get_position ( patch, n );
-    double r2 = p.x() * p.x() + p.y() * p.y();
-    double tmp = r2 - r0 * r0;
-    u[n] = - tanh ( gamma * tmp );
-}
-
-void CCHeat2D::forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new )
-{
-    double delta_u = delt * alpha * laplacian ( i, j, k, patch, u_old );
-    u_new ( i, j, k ) = u_old ( i, j, k ) + delta_u;
-}
-
-void CCHeat2D::forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] )
-{
-    const double d ( face / 2 );
-    const double h ( patch->getLevel()->dCell() [d] );
-
-    const double dx ( patch->getLevel()->dCell().x() );
-//  const double dy ( patch->getLevel()->dCell().y() );
-
-    const IntVector cl = get_low ( patch );
-    const IntVector ch = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    const IntVector c0 ( i, j, k );
-    const IntVector cm = c0 - patch->faceDirection ( face );
-//  const IntVector cp = c0 + patch->faceDirection ( face );
-
-    const IntVector cw ( i - 1, j, k );
-    const IntVector ce ( i + 1, j, k );
-//  const IntVector cs ( i, j - 1, k );
-//  const IntVector cn ( i, j + 1, k );
-
-    if ( bc_kind[face] == "Dirichlet" )
-    {
-        u_new[c0] = bc_value[face];
-        if ( is_internal ( patch, cm, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on cm
-        {
-            u_new[cm] += ( delt * alpha * ( bc_value[face] - u_old[c0] ) ) / ( h * h );
-        }
-        return;
-    }
-    if ( bc_kind[face] == "Neumann" )
-    {
-        double delta_u = delt * alpha;
-        const double sgn ( patch->faceDirection ( face ) [d] );
-        double uxx = 0.;
-        double uyy = 0.;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            uxx = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old [cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            uyy = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            delta_u *=  uxx + uyy;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[c0] = u_old[c0] + delta_u;
-        return;
-    }
-}
-
-void CCHeat2D::backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    IntVector n ( i, j, k );
-    double a = - alpha * delt;
-    double ax = a / ( d.x() * d.x() );
-    double ay = a / ( d.y() * d.y() );
-    A[n].p = 1. - 2. * ( ax + ay );
-    A[n].e = A[n].w = ax;
-    A[n].n = A[n].s = ay;
-    A[n].t = A[n].b = 0.;
-    b[n] = u[n];
-#ifdef DBG_MATRIX
-    Ap[n] = A[n].p;
-    Aw[n] = A[n].w;
-    Ae[n] = A[n].e;
-    As[n] = A[n].s;
-    An[n] = A[n].n;
-    At[n] = A[n].t;
-    Ab[n] = A[n].b;
-#endif
-}
-
-void CCHeat2D::backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] )
-{
-    switch ( patch->getBCType ( face ) )
-    {
-    case Patch::None:
-    {
-        const double d ( face / 2 );
-        const double h ( patch->getLevel()->dCell() [d] );
-        IntVector n0 ( i, j, k );
-        IntVector n1 = n0 - patch->faceDirection ( face );
-        double a = ( alpha * delt ) / ( h * h );
-        {
-            if ( bc_kind[face] == "Dirichlet" )
-            {
-                b[n0] = bc_value[face];
-                if ( is_internal ( patch, n1, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on n1
-                {
-                    b[n1] += a * bc_value[face];
-                }
-                A[n0].p = 1;
-                A[n0].e = A[n0].w = 0.;
-                A[n0].n = A[n0].s = 0.;
-                A[n0].t = A[n0].b = 0.;
-                A[n1][face] = 0.;
-#ifdef DBG_MATRIX
-                Ap[n0] = A[n0].p;
-                Aw[n0] = A[n0].w;
-                Ae[n0] = A[n0].e;
-                As[n0] = A[n0].s;
-                An[n0] = A[n0].n;
-                At[n0] = A[n0].t;
-                Ab[n0] = A[n0].b;
-
-                Ap[n1] = A[n1].p;
-                Aw[n1] = A[n1].w;
-                Ae[n1] = A[n1].e;
-                As[n1] = A[n1].s;
-                An[n1] = A[n1].n;
-                At[n1] = A[n1].t;
-                Ab[n1] = A[n1].b;
-#endif
-                return;
-            }
-            if ( bc_kind[face] == "Neumann" )
-            {
-                if ( !is_internal ( patch, n0, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on n0
-                {
-                    return;
-                }
-                const double sgn ( patch->faceDirection ( face ) [d] );
-                A[n0].p -= a;
-                A[n0][face] = 0.;
-#ifdef DBG_MATRIX
-                Ap[n0] = A[n0].p;
-                Aw[n0] = A[n0].w;
-                Ae[n0] = A[n0].e;
-                As[n0] = A[n0].s;
-                An[n0] = A[n0].n;
-                At[n0] = A[n0].t;
-                Ab[n0] = A[n0].b;
-#endif
-                b[n0] -= a * sgn * h * bc_value[face];
-                return;
-            }
-        }
-    }
-    default:
-        return;
-    }
-}
diff --git a/src/CCA/Components/Heat/CCHeat2D.h b/src/CCA/Components/Heat/CCHeat2D.h
deleted file mode 100644
index bb181f17..00000000
--- a/src/CCA/Components/Heat/CCHeat2D.h
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_CCHeat2D_h
-#define Packages_Uintah_CCA_Components_Heat_CCHeat2D_h
-
-#include <CCA/Components/Application/ApplicationCommon.h>
-
-#include <Core/Grid/BoundaryConditions/BCDataArray.h>
-#include <Core/Grid/BoundaryConditions/BoundCond.h>
-#include <Core/Grid/Ghost.h>
-#include <Core/Grid/Patch.h>
-#include <Core/Grid/SimpleMaterial.h>
-#include <Core/Grid/Task.h>
-#include <Core/Grid/Variables/BlockRange.hpp>
-#include <Core/Grid/Variables/CCVariable.h>
-#include <Core/Grid/Variables/VarLabel.h>
-#include <Core/Util/DebugStream.h>
-#include <CCA/Components/Heat/TimeScheme.h>
-#include <CCA/Ports/Scheduler.h>
-#include <CCA/Ports/SolverInterface.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-#define DBG_MATRIX
-
-namespace Uintah
-{
-
-class CCHeat2D :
-    public ApplicationCommon
-{
-protected:
-    using ConstVariable = constCCVariable<double>;
-    using Variable = CCVariable<double>;
-    using ConstMatrix = constCCVariable<Stencil7>;
-    using Matrix = CCVariable<Stencil7>;
-#ifdef UINTAH_ENABLE_KOKKOS
-    using ConstVariableView = KokkosView3<double const>;
-    using VariableView = KokkosView3<double>;
-    using MatrixView = KokkosView3<Stencil7>;
-#else
-    using ConstVariableView = ConstVariable & ;
-    using VariableView = Variable & ;
-    using MatrixView = Matrix & ;
-#endif
-
-    static constexpr Patch::FaceType start_face = Patch::xminus;
-    static constexpr Patch::FaceType end_face   = Patch::yplus;
-
-    static constexpr inline ConstVariableView get_view ( ConstVariable & var );
-    static constexpr inline VariableView get_view ( Variable & var );
-    static constexpr inline MatrixView get_view ( Matrix & var );
-
-    static inline IntVector get_low ( Patch const * patch );
-    static inline IntVector get_high ( Patch const * patch );
-    static inline BlockRange get_range ( Patch const * patch );
-    static inline BlockRange get_inner_range ( Patch const * patch );
-    static inline BlockRange get_face_range ( Patch const * patch, Patch::FaceType face );
-    static inline void get_bc ( Patch const * patch, Patch::FaceType face, const int child, const std::string & desc, const int mat_id, BlockRange & range, std::string & bc_kind, double & bc_value );
-    static inline Point get_position ( Patch const * patch, IntVector const & i );
-    static inline bool is_internal ( const Patch * patch, const IntVector & i, int d, const std::string bc_kind[4] );
-
-    static inline double dx ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dy ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dxx ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dyy ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double laplacian ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-
-protected:
-    double const tol = 1.e-6;
-
-    DebugStream dbg_out1, dbg_out2, dbg_out3, dbg_out4;
-
-    double delt, alpha, r0, gamma;
-    TimeScheme time_scheme;
-
-    const VarLabel * u_label;
-    const VarLabel * matrix_label, * rhs_label;
-#ifdef DBG_MATRIX
-#   define MATRIX_VIEW_A MatrixView A, VariableView Ap, VariableView Aw, VariableView Ae, VariableView As, VariableView An, VariableView Ab, VariableView At
-#   define REF_A &A, &Ap, &Aw, &Ae, &As, &An, &Ab, &At
-#   define GET_VIEW_A get_view ( A ), get_view ( Ap ), get_view ( Aw ), get_view ( Ae ), get_view ( As ), get_view ( An ), get_view ( Ab ), get_view ( At )
-    const VarLabel * Ap_label, * Aw_label, * Ae_label, * As_label, * An_label, * Ab_label, * At_label;
-#else
-#   define MATRIX_VIEW_A MatrixView A
-#   define REF_A &A
-#   define GET_VIEW_A get_view ( A )
-#endif
-
-    SolverInterface * solver;
-
-public:
-    CCHeat2D ( const ProcessorGroup * myworld,
-	       const MaterialManagerP materialManager,
-	       int verbosity = 0 );
-  
-    virtual ~CCHeat2D();
-
-protected:
-    CCHeat2D ( CCHeat2D const & ) = delete;
-    CCHeat2D & operator= ( CCHeat2D const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleInitialize ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleRestartInitialize ( LevelP const & /*level*/, SchedulerP & /*sched*/ ) override {} // TODO
-    virtual void scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-
-    void scheduleTimeAdvance_forward_euler ( LevelP const & level, SchedulerP & );
-    void scheduleTimeAdvance_backward_euler_assemble ( LevelP const & level, SchedulerP & );
-    void scheduleTimeAdvance_backward_euler_solve ( LevelP const & level, SchedulerP & );
-
-    void task_initialize ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_compute_stable_timestep ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_farward_euler_time_advance ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_backward_euler_assemble ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-
-    void initialize ( int i, int j, int k, Patch const * patch, VariableView u );
-    void forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new );
-    void forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] );
-    void backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b );
-    void backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] );
-}; // class CCHeat2D
-
-} // namespace Uintah
-
-constexpr inline Uintah::CCHeat2D::ConstVariableView Uintah::CCHeat2D::get_view ( ConstVariable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-constexpr inline Uintah::CCHeat2D::VariableView Uintah::CCHeat2D::get_view ( Variable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-constexpr inline Uintah::CCHeat2D::MatrixView Uintah::CCHeat2D::get_view ( Matrix & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-inline Uintah::Point Uintah::CCHeat2D::get_position ( Patch const * patch, IntVector const & i )
-{
-    return patch->getCellPosition ( i );
-}
-
-inline Uintah::IntVector Uintah::CCHeat2D::get_low ( Patch const * patch )
-{
-    return patch->getCellLowIndex();
-}
-
-inline Uintah::IntVector Uintah::CCHeat2D::get_high ( Patch const * patch )
-{
-    return patch->getCellHighIndex();
-}
-
-inline Uintah::BlockRange Uintah::CCHeat2D::get_range ( Patch const * patch )
-{
-    return { get_low ( patch ), get_high ( patch ) };
-}
-
-inline Uintah::BlockRange Uintah::CCHeat2D::get_inner_range ( Patch const * patch )
-{
-    return { get_low ( patch ) + IntVector (
-                 patch->getBCType ( Patch::xminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yminus ) == Patch::Neighbor ? 0 : 1,
-                 0
-             ),
-             get_high ( patch ) - IntVector (
-                 patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 0 : 1,
-                 0
-             )
-           };
-}
-
-inline Uintah::BlockRange Uintah::CCHeat2D::get_face_range ( Patch const * patch, Patch::FaceType face )
-{
-    IntVector l, h;
-    patch->getFaceCells ( face, 0, l, h );
-    return { l, h };
-}
-
-inline void Uintah::CCHeat2D::get_bc ( const Patch * patch, Patch::FaceType face, const int child, const std::string & desc, const int mat_id, BlockRange & range, std::string & bc_kind, double & bc_value )
-{
-    range = get_face_range ( patch, face );
-    bc_kind = "NotSet";
-    bc_value = 0.;
-
-    if ( desc == "zeroNeumann" )
-    {
-        bc_kind = "zeroNeumann";
-        return;
-    }
-
-    if ( patch->getBCType ( face ) == Patch::Coarse )
-    {
-        bc_kind = "FineCoarseInterface";
-        return;
-    }
-
-    if ( patch->getBCType ( face ) == Patch::Neighbor )
-    {
-        bc_kind = "Neighbor";
-        return;
-    }
-
-    const BCDataArray * bcd = patch->getBCDataArray ( face );
-    if ( !bcd ) return;
-
-    const BoundCondBase * bc;
-    if ( ( bc = bcd->getBoundCondData ( mat_id, desc, child ) ) )
-    {
-        const BoundCond<double> * bcs = dynamic_cast<const BoundCond<double> *> ( bc );;
-        if ( bcs )
-        {
-            bc_kind  = bcs->getBCType();
-            bc_value = bcs->getValue();
-        }
-    }
-    else if ( ( bc = bcd->getBoundCondData ( mat_id, "Symmetric", child ) ) )
-    {
-        if ( bc->getBCType() == "symmetry" ) bc_kind  = "symmetry";
-    }
-    if ( bc ) delete bc;
-    return;
-}
-
-bool Uintah::CCHeat2D::is_internal ( const Patch * patch, const IntVector & i, int d, const std::string bc_kind[4] )
-{
-    IntVector l = get_low ( patch );
-    IntVector h = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    for ( int k = 0; k < d; ++k )
-    {
-        if ( bc_kind[2 * k] == "Dirichlet" && i[k] <= l[k] ) return false;
-        if ( bc_kind[2 * k + 1] == "Dirichlet" && i[k] >= h[k] ) return false;
-    }
-    return true;
-}
-
-inline double Uintah::CCHeat2D::dx ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) - psi ( i - 1, j, k ) ) / ( 2. * d.x() );
-}
-
-inline double Uintah::CCHeat2D::dy ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) - psi ( i, j - 1, k ) ) / ( 2. * d.y() );
-}
-
-inline double Uintah::CCHeat2D::dxx ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) + psi ( i - 1, j, k ) - 2. * psi ( i, j, k ) ) / ( d.x() * d.x() );
-}
-
-inline double Uintah::CCHeat2D::dyy ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) + psi ( i, j - 1, k ) - 2. * psi ( i, j, k ) ) / ( d.y() * d.y() );
-}
-
-inline double Uintah::CCHeat2D::laplacian ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    return dxx ( i, j, k, patch, psi ) + dyy ( i, j, k, patch, psi );
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_CCHeat2D_h
diff --git a/src/CCA/Components/Heat/CCHeat3D.cc b/src/CCA/Components/Heat/CCHeat3D.cc
deleted file mode 100644
index 15ad2780..00000000
--- a/src/CCA/Components/Heat/CCHeat3D.cc
+++ /dev/null
@@ -1,575 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <CCA/Components/Heat/CCHeat3D.h>
-
-#include <CCA/Components/Heat/blockrange_io.h>
-
-using namespace Uintah;
-
-CCHeat3D::CCHeat3D ( const ProcessorGroup * myworld,
-		     const MaterialManagerP materialManager,
-		     int verbosity )
-  : ApplicationCommon ( myworld, materialManager )
-    , dbg_out1 ( "CCHeat3D", verbosity > 0 )
-    , dbg_out2 ( "CCHeat3D", verbosity > 1 )
-    , dbg_out3 ( "CCHeat3D", verbosity > 2 )
-    , dbg_out4 ( "CCHeat3D", verbosity > 3 )
-    , solver ( nullptr )
-{
-    u_label = VarLabel::create ( "u", Variable::getTypeDescription() );
-    matrix_label = VarLabel::create ( "A", Matrix::getTypeDescription() );
-    rhs_label = VarLabel::create ( "b", Variable::getTypeDescription() );
-#ifdef DBG_MATRIX
-    Ap_label = VarLabel::create ( "Ap", Variable::getTypeDescription() );
-    Aw_label = VarLabel::create ( "Aw", Variable::getTypeDescription() );
-    Ae_label = VarLabel::create ( "Ae", Variable::getTypeDescription() );
-    An_label = VarLabel::create ( "An", Variable::getTypeDescription() );
-    As_label = VarLabel::create ( "As", Variable::getTypeDescription() );
-    At_label = VarLabel::create ( "At", Variable::getTypeDescription() );
-    Ab_label = VarLabel::create ( "Ab", Variable::getTypeDescription() );
-#endif
-}
-
-CCHeat3D::~CCHeat3D()
-{
-    VarLabel::destroy ( u_label );
-    VarLabel::destroy ( matrix_label );
-    VarLabel::destroy ( rhs_label );
-#ifdef DBG_MATRIX
-    VarLabel::destroy ( Ap_label );
-    VarLabel::destroy ( Aw_label );
-    VarLabel::destroy ( Ae_label );
-    VarLabel::destroy ( An_label );
-    VarLabel::destroy ( As_label );
-    VarLabel::destroy ( At_label );
-    VarLabel::destroy ( Ab_label );
-#endif
-}
-
-void CCHeat3D::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & /*restart_prob_spec*/, GridP & /*grid*/ )
-{
-    setLockstepAMR( true );
-
-    m_materialManager->registerSimpleMaterial ( scinew SimpleMaterial() );
-
-    ProblemSpecP heat = params->findBlock ( "FDHeat" );
-    std::string scheme;
-    heat->require ( "delt", delt );
-    heat->require ( "alpha", alpha );
-    heat->require ( "R0", r0 );
-    heat->getWithDefault ( "gamma", gamma, 1. );
-    heat->getWithDefault ( "scheme", scheme, "forward_euler" );
-    time_scheme = from_str ( scheme );
-    if ( time_scheme & TimeScheme::Implicit )
-    {
-        ProblemSpecP solv = params->findBlock ( "Solver" );
-        solver = dynamic_cast<SolverInterface *> ( getPort ( "solver" ) );
-        if ( !solver )
-        {
-            throw InternalError ( "CCHeat2D:couldn't get solver port", __FILE__, __LINE__ );
-        }
-        solver->readParameters ( solv, "u" );
-        solver->getParameters()->setSolveOnExtraCells ( false );
-    }
-}
-
-void CCHeat3D::scheduleInitialize ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "CCHeat3D::task_initialize", this, &CCHeat3D::task_initialize );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void CCHeat3D::scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "CCHeat3D::task_compute_stable_timestep", this, &CCHeat3D::task_compute_stable_timestep );
-    task->computes ( getDelTLabel(), level.get_rep() );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void CCHeat3D::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    switch ( time_scheme )
-    {
-    case TimeScheme::ForwardEuler:
-        scheduleTimeAdvance_forward_euler ( level, sched );
-        break;
-    case TimeScheme::BackwardEuler:
-        scheduleTimeAdvance_backward_euler_assemble ( level, sched );
-        scheduleTimeAdvance_backward_euler_solve ( level, sched );
-        break;
-    default:
-        break;
-    }
-}
-
-void CCHeat3D::scheduleTimeAdvance_forward_euler ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "CCHeat3D::task_farward_euler_time_advance", this, &CCHeat3D::task_farward_euler_time_advance );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundCells, 1 );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void CCHeat3D::scheduleTimeAdvance_backward_euler_assemble ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "CCHeat3D::task_backward_euler_assemble", this, &CCHeat3D::task_backward_euler_assemble );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundCells, 1 );
-    task->computes ( matrix_label );
-    task->computes ( rhs_label );
-#ifdef DBG_MATRIX
-    task->computes ( Ap_label );
-    task->computes ( Aw_label );
-    task->computes ( Ae_label );
-    task->computes ( An_label );
-    task->computes ( As_label );
-    task->computes ( At_label );
-    task->computes ( Ab_label );
-#endif
-    sched->addTask ( task, level->allPatches(), m_materialManager->allMaterials() );
-}
-
-void CCHeat3D::scheduleTimeAdvance_backward_euler_solve ( LevelP const & level, SchedulerP & sched )
-{
-    solver->scheduleSolve ( level, sched, m_materialManager->allMaterials(),
-                            matrix_label, Task::NewDW, // A
-                            u_label, false,            // x
-                            rhs_label, Task::NewDW,    // b
-                            u_label, Task::OldDW);      // guess
-}
-
-void CCHeat3D::task_initialize ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== CCHeat3D::task_initialize ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        Variable u;
-        dw_new->allocateAndPut ( u, u_label, 0, patch );
-        dbg_out4 << "u \t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        BlockRange range ( get_range ( patch ) );
-        dbg_out3 << "= Iterating over range " << range << std::endl;
-        parallel_for ( range, [patch, &u, this] ( int i, int j, int k )->void { initialize ( i, j, k, patch, get_view ( u ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void CCHeat3D::task_compute_stable_timestep ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== CCHeat3D::task_compute_stable_timestep ====" << std::endl;
-    dw_new->put ( delt_vartype ( delt ), getDelTLabel(), getLevel ( patches ) );
-    dbg_out2 << std::endl;
-}
-
-void CCHeat3D::task_farward_euler_time_advance ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== CCHeat3D::task_farward_euler_time_advance ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u_old;
-        dw_old->get ( u_old, u_label, 0, patch, Ghost::AroundCells, 1 );
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-
-        Variable u_new;
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ) ); } );
-
-        std::string bc_kind[6];
-        double bc_value[6];
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ), face, bc_kind, bc_value ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void Uintah::CCHeat3D::task_backward_euler_assemble ( const Uintah::ProcessorGroup * myworld, const PatchSubset * patches, const MaterialSubset * matls, Uintah::DataWarehouse * dw_old, Uintah::DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== CCHeat3D::task_backward_euler_assemble ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u;
-        dw_old->get ( u, u_label, 0, patch, Ghost::AroundCells, 1 );
-        dbg_out4 << "u\t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        Matrix A;
-        dw_new->allocateAndPut ( A, matrix_label, 0, patch );
-        dbg_out4 << "A \t range " << A.getLowIndex() << A.getHighIndex() << std::endl;
-
-#ifdef DBG_MATRIX
-        Variable Ap;
-        dw_new->allocateAndPut ( Ap, Ap_label, 0, patch );
-        dbg_out4 << "Ap \t range " << Ap.getLowIndex() << Ap.getHighIndex() << std::endl;
-
-        Variable Aw;
-        dw_new->allocateAndPut ( Aw, Aw_label, 0, patch );
-        dbg_out4 << "Aw \t range " << Aw.getLowIndex() << Aw.getHighIndex() << std::endl;
-
-        Variable Ae;
-        dw_new->allocateAndPut ( Ae, Ae_label, 0, patch );
-        dbg_out4 << "Ae \t range " << Ae.getLowIndex() << Ae.getHighIndex() << std::endl;
-
-        Variable An;
-        dw_new->allocateAndPut ( An, An_label, 0, patch );
-        dbg_out4 << "An \t range " << An.getLowIndex() << An.getHighIndex() << std::endl;
-
-        Variable As;
-        dw_new->allocateAndPut ( As, As_label, 0, patch );
-        dbg_out4 << "As \t range " << As.getLowIndex() << As.getHighIndex() << std::endl;
-
-        Variable At;
-        dw_new->allocateAndPut ( At, At_label, 0, patch );
-        dbg_out4 << "At \t range " << At.getLowIndex() << At.getHighIndex() << std::endl;
-
-        Variable Ab;
-        dw_new->allocateAndPut ( Ab, Ab_label, 0, patch );
-        dbg_out4 << "Ab \t range " << Ab.getLowIndex() << Ab.getHighIndex() << std::endl;
-#endif
-
-        Variable b;
-        dw_new->allocateAndPut ( b, rhs_label, 0, patch );
-        dbg_out4 << "b\t range " << b.getLowIndex() << b.getHighIndex() << std::endl;
-
-        BlockRange range ( get_range ( patch ) );
-        dbg_out3 << "= Iterating over range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u, REF_A, &b, this] ( int i, int j, int k )->void { backward_euler_assemble ( i, j, k, patch, get_view ( u ), GET_VIEW_A, get_view ( b ) ); } );
-
-        std::string bc_kind[6];
-        double bc_value[6];
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " - BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u, REF_A, &b, this] ( int i, int j, int k )->void { backward_euler_assemble ( i, j, k, patch, get_view ( u ), GET_VIEW_A, get_view ( b ), face, bc_kind, bc_value ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void CCHeat3D::initialize ( int i, int j, int k, Patch const * patch, VariableView u )
-{
-    IntVector n ( i, j, k );
-    Point p = get_position ( patch, n );
-    double r2 = p.x() * p.x() + p.y() * p.y() + p.z() * p.z();
-    double tmp = r2 - r0 * r0;
-    u[n] = - tanh ( gamma * tmp );
-}
-
-void CCHeat3D::forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new )
-{
-    double delta_u = delt * alpha * laplacian ( i, j, k, patch, u_old );
-    u_new ( i, j, k ) = u_old ( i, j, k ) + delta_u;
-}
-
-void CCHeat3D::forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] )
-{
-    const double d ( face / 2 );
-    const double h ( patch->getLevel()->dCell() [d] );
-
-    const double dx ( patch->getLevel()->dCell().x() );
-    const double dy ( patch->getLevel()->dCell().y() );
-//  const double dz ( patch->getLevel()->dCell().z() );
-
-    const IntVector cl = get_low ( patch );
-    const IntVector ch = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    const IntVector c0 ( i, j, k );
-    const IntVector cm = c0 - patch->faceDirection ( face );
-//  const IntVector cp = c0 + patch->faceDirection ( face );
-
-    const IntVector cw ( i - 1, j, k );
-    const IntVector ce ( i + 1, j, k );
-    const IntVector cs ( i, j - 1, k );
-    const IntVector cn ( i, j + 1, k );
-//  const IntVector cb ( i, j, k - 1 );
-//  const IntVector ct ( i, j, k + 1 );
-
-    if ( bc_kind[face] == "Dirichlet" )
-    {
-        u_new[c0] = bc_value[face];
-        if ( is_internal ( patch, cm, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on cm
-        {
-            u_new[cm] += ( delt * alpha * ( bc_value[face] - u_old[c0] ) ) / ( h * h );
-        }
-        return;
-    }
-    if ( bc_kind[face] == "Neumann" )
-    {
-        double delta_u = delt * alpha;
-        const double sgn ( patch->faceDirection ( face ) [d] );
-        double uxx = 0.;
-        double uyy = 0.;
-        double uzz = 0.;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            if ( k == cl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == ch.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            uxx = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy + uzz;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( k == cl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == ch.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old[cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            uyy = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        case Patch::zminus:
-        case Patch::zplus:
-            if ( i == cl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = ( u_old[ce] - u_old[c0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-            }
-            else if ( i == ch.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = ( u_old[c0] - u_old[cw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            if ( j == cl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yminus] == "Neumann" )
-                {
-                    uyy = ( u_old[cn] - u_old[c0] - bc_value[Patch::yminus] * dy ) / ( dy * dy );
-                }
-            }
-            else if ( j == ch.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yplus] == "Neumann" )
-                {
-                    uyy = ( u_old[c0] - u_old[cs] + bc_value[Patch::yplus] * dy ) / ( dy * dy );
-                }
-            }
-            else
-            {
-                uyy = dyy ( i, j, k, patch, u_old );
-            }
-            uzz = sgn * ( u_old[c0] - u_old[cm] + bc_value[face] * h ) / ( h * h );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[c0] = u_old[c0] + delta_u;
-        return;
-    }
-}
-
-void CCHeat3D::backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    IntVector n ( i, j, k );
-    double a = - alpha * delt;
-    double ax = a / ( d.x() * d.x() );
-    double ay = a / ( d.y() * d.y() );
-    double az = a / ( d.z() * d.z() );
-    A[n].p = 1. - 2. * ( ax + ay + az );
-    A[n].e = A[n].w = ax;
-    A[n].n = A[n].s = ay;
-    A[n].t = A[n].b = az;
-    b[n] = u[n];
-#ifdef DBG_MATRIX
-    Ap[n] = A[n].p;
-    Aw[n] = A[n].w;
-    Ae[n] = A[n].e;
-    As[n] = A[n].s;
-    An[n] = A[n].n;
-    At[n] = A[n].t;
-    Ab[n] = A[n].b;
-#endif
-}
-
-void CCHeat3D::backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] )
-{
-    switch ( patch->getBCType ( face ) )
-    {
-    case Patch::None:
-    {
-        const double d ( face / 2 );
-        const double h ( patch->getLevel()->dCell() [d] );
-        IntVector n0 ( i, j, k );
-        IntVector n1 = n0 - patch->faceDirection ( face );
-        double a = ( alpha * delt ) / ( h * h );
-        {
-            if ( bc_kind[face] == "Dirichlet" )
-            {
-                b[n0] = bc_value[face];
-                if ( is_internal ( patch, n1, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on n1
-                {
-                    b[n1] += a * bc_value[face];
-                }
-                A[n0].p = 1;
-                A[n0].e = A[n0].w = 0.;
-                A[n0].n = A[n0].s = 0.;
-                A[n0].t = A[n0].b = 0.;
-                A[n1][face] = 0.;
-#ifdef DBG_MATRIX
-                Ap[n0] = A[n0].p;
-                Aw[n0] = A[n0].w;
-                Ae[n0] = A[n0].e;
-                As[n0] = A[n0].s;
-                An[n0] = A[n0].n;
-                At[n0] = A[n0].t;
-                Ab[n0] = A[n0].b;
-
-                Ap[n1] = A[n1].p;
-                Aw[n1] = A[n1].w;
-                Ae[n1] = A[n1].e;
-                As[n1] = A[n1].s;
-                An[n1] = A[n1].n;
-                At[n1] = A[n1].t;
-                Ab[n1] = A[n1].b;
-#endif
-                return;
-            }
-            if ( bc_kind[face] == "Neumann" )
-            {
-                if ( !is_internal ( patch, n0, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on n0
-                {
-                    return;
-                }
-                const double sgn ( patch->faceDirection ( face ) [d] );
-                A[n0].p -= a;
-                A[n0][face] = 0.;
-#ifdef DBG_MATRIX
-                Ap[n0] = A[n0].p;
-                Aw[n0] = A[n0].w;
-                Ae[n0] = A[n0].e;
-                As[n0] = A[n0].s;
-                An[n0] = A[n0].n;
-                At[n0] = A[n0].t;
-                Ab[n0] = A[n0].b;
-#endif
-                b[n0] -= a * sgn * h * bc_value[face];
-                return;
-            }
-        }
-    }
-    default:
-        return;
-    }
-}
diff --git a/src/CCA/Components/Heat/CCHeat3D.h b/src/CCA/Components/Heat/CCHeat3D.h
deleted file mode 100644
index bbbcf08f..00000000
--- a/src/CCA/Components/Heat/CCHeat3D.h
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Head_CCHeat3D_h
-#define Packages_Uintah_CCA_Components_Head_CCHeat3D_h
-
-#include <CCA/Components/Application/ApplicationCommon.h>
-
-#include <Core/Grid/BoundaryConditions/BCDataArray.h>
-#include <Core/Grid/BoundaryConditions/BoundCond.h>
-#include <Core/Grid/Ghost.h>
-#include <Core/Grid/Patch.h>
-#include <Core/Grid/MaterialManager.h>
-#include <Core/Grid/SimpleMaterial.h>
-#include <Core/Grid/Task.h>
-#include <Core/Grid/Variables/BlockRange.hpp>
-#include <Core/Grid/Variables/CCVariable.h>
-#include <Core/Grid/Variables/VarLabel.h>
-#include <Core/Util/DebugStream.h>
-#include <CCA/Components/Heat/TimeScheme.h>
-#include <CCA/Ports/Scheduler.h>
-#include <CCA/Ports/SolverInterface.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-#define DBG_MATRIX
-
-namespace Uintah
-{
-
-class CCHeat3D :
-    public ApplicationCommon
-{
-protected:
-    using ConstVariable = constCCVariable<double>;
-    using Variable = CCVariable<double>;
-    using ConstMatrix = constCCVariable<Stencil7>;
-    using Matrix = CCVariable<Stencil7>;
-#ifdef UINTAH_ENABLE_KOKKOS
-    using ConstVariableView = KokkosView3<double const>;
-    using VariableView = KokkosView3<double>;
-    using MatrixView = KokkosView3<Stencil7>;
-#else
-    using ConstVariableView = ConstVariable & ;
-    using VariableView = Variable & ;
-    using MatrixView = Matrix & ;
-#endif
-
-    static constexpr Patch::FaceType start_face = Patch::xminus;
-    static constexpr Patch::FaceType end_face = Patch::zplus;
-
-    static constexpr inline ConstVariableView get_view ( ConstVariable & var );
-    static constexpr inline VariableView get_view ( Variable & var );
-    static constexpr inline MatrixView get_view ( Matrix & var );
-
-    static inline IntVector get_low ( Patch const * patch );
-    static inline IntVector get_high ( Patch const * patch );
-    static inline BlockRange get_range ( Patch const * patch );
-    static inline BlockRange get_inner_range ( Patch const * patch );
-    static inline BlockRange get_face_range ( Patch const * patch, Patch::FaceType face );
-    static inline void get_bc ( Patch const * patch, Patch::FaceType face, const int child, const std::string & desc, const int mat_id, BlockRange & range, std::string & bc_kind, double & bc_value );
-    static inline Point get_position ( Patch const * patch, IntVector const & i );
-    static inline bool is_internal ( const Patch * patch, const IntVector & i, int d, const std::string bc_kind[6] );
-
-    static inline double dx ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dy ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dz ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dxx ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dyy ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dzz ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double laplacian ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-
-protected:
-    double const tol = 1.e-6;
-
-    DebugStream dbg_out1, dbg_out2, dbg_out3, dbg_out4;
-
-    double delt, alpha, r0, gamma;
-    TimeScheme time_scheme;
-
-    const VarLabel * u_label;
-    const VarLabel * matrix_label, * rhs_label;
-#ifdef DBG_MATRIX
-#   define MATRIX_VIEW_A MatrixView A, VariableView Ap, VariableView Aw, VariableView Ae, VariableView As, VariableView An, VariableView Ab, VariableView At
-#   define REF_A &A, &Ap, &Aw, &Ae, &As, &An, &Ab, &At
-#   define GET_VIEW_A get_view ( A ), get_view ( Ap ), get_view ( Aw ), get_view ( Ae ), get_view ( As ), get_view ( An ), get_view ( Ab ), get_view ( At )
-    const VarLabel * Ap_label, * Aw_label, * Ae_label, * As_label, * An_label, * Ab_label, * At_label;
-#else
-#   define MATRIX_VIEW_A MatrixView A
-#   define REF_A &A
-#   define GET_VIEW_A get_view ( A )
-#endif
-
-    SolverInterface * solver;
-
-public:
-    CCHeat3D ( const ProcessorGroup * myworld,
-	       const MaterialManagerP materialManager,
-	       int verbosity = 0 );
-  
-    virtual ~CCHeat3D();
-
-protected:
-    CCHeat3D ( CCHeat3D const & ) = delete;
-    CCHeat3D & operator= ( CCHeat3D const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleInitialize ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleRestartInitialize ( LevelP const & /*level*/, SchedulerP & /*sched*/ ) override {} // TODO
-    virtual void scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-
-    void scheduleTimeAdvance_forward_euler ( LevelP const & level, SchedulerP & );
-    void scheduleTimeAdvance_backward_euler_assemble ( LevelP const & level, SchedulerP & );
-    void scheduleTimeAdvance_backward_euler_solve ( LevelP const & level, SchedulerP & );
-
-    void task_initialize ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_compute_stable_timestep ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_farward_euler_time_advance ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_backward_euler_assemble ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-
-    void initialize ( int i, int j, int k, Patch const * patch, VariableView u );
-    void forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new );
-    void forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] );
-    void backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b );
-    void backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] );
-}; // class CCHeat3D
-
-} // namespace Uintah
-
-constexpr inline Uintah::CCHeat3D::ConstVariableView Uintah::CCHeat3D::get_view ( ConstVariable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-constexpr inline Uintah::CCHeat3D::VariableView Uintah::CCHeat3D::get_view ( Variable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-constexpr inline Uintah::CCHeat3D::MatrixView Uintah::CCHeat3D::get_view ( Matrix & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-inline Uintah::Point Uintah::CCHeat3D::get_position ( Patch const * patch, IntVector const & i )
-{
-    return patch->getCellPosition ( i );
-}
-
-inline Uintah::IntVector Uintah::CCHeat3D::get_low ( Patch const * patch )
-{
-    return patch->getCellLowIndex();
-}
-
-inline Uintah::IntVector Uintah::CCHeat3D::get_high ( Patch const * patch )
-{
-    return patch->getCellHighIndex();
-}
-
-inline Uintah::BlockRange Uintah::CCHeat3D::get_range ( Patch const * patch )
-{
-    return { get_low ( patch ), get_high ( patch ) };
-}
-
-inline Uintah::BlockRange Uintah::CCHeat3D::get_inner_range ( Patch const * patch )
-{
-    return { get_low ( patch ) + IntVector (
-                 patch->getBCType ( Patch::xminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::zminus ) == Patch::Neighbor ? 0 : 1
-             ),
-             get_high ( patch ) - IntVector (
-                 patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::zplus ) == Patch::Neighbor ? 0 : 1
-             )
-           };
-}
-
-inline Uintah::BlockRange Uintah::CCHeat3D::get_face_range ( Patch const * patch, Patch::FaceType face )
-{
-    IntVector l, h;
-    patch->getFaceCells ( face, 0, l, h );
-    return { l, h };
-}
-
-inline void Uintah::CCHeat3D::get_bc ( const Patch * patch, Patch::FaceType face, const int child, const std::string & desc, const int mat_id, BlockRange & range, std::string & bc_kind, double & bc_value )
-{
-    range = get_face_range ( patch, face );
-    bc_kind = "NotSet";
-    bc_value = 0.;
-
-    if ( desc == "zeroNeumann" )
-    {
-        bc_kind = "zeroNeumann";
-        return;
-    }
-
-    if ( patch->getBCType ( face ) == Patch::Coarse )
-    {
-        bc_kind = "FineCoarseInterface";
-        return;
-    }
-
-    if ( patch->getBCType ( face ) == Patch::Neighbor )
-    {
-        bc_kind = "Neighbor";
-        return;
-    }
-
-    const BCDataArray * bcd = patch->getBCDataArray ( face );
-    if ( !bcd ) return;
-
-    const BoundCondBase * bc;
-    if ( ( bc = bcd->getBoundCondData ( mat_id, desc, child ) ) )
-    {
-        const BoundCond<double> * bcs = dynamic_cast<const BoundCond<double> *> ( bc );;
-        if ( bcs )
-        {
-            bc_kind  = bcs->getBCType();
-            bc_value = bcs->getValue();
-        }
-    }
-    else if ( ( bc = bcd->getBoundCondData ( mat_id, "Symmetric", child ) ) )
-    {
-        if ( bc->getBCType() == "symmetry" ) bc_kind  = "symmetry";
-    }
-    if ( bc ) delete bc;
-    return;
-}
-
-bool Uintah::CCHeat3D::is_internal ( const Patch * patch, const IntVector & i, int d, const std::string bc_kind[6] )
-{
-    IntVector l = get_low ( patch );
-    IntVector h = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    for ( int k = 0; k < d; ++k )
-    {
-        if ( bc_kind[2 * k] == "Dirichlet" && i[k] <= l[k] ) return false;
-        if ( bc_kind[2 * k + 1] == "Dirichlet" && i[k] >= h[k] ) return false;
-    }
-    return true;
-}
-
-inline double Uintah::CCHeat3D::dx ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) - psi ( i - 1, j, k ) ) / ( 2. * d.x() );
-}
-
-inline double Uintah::CCHeat3D::dy ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) - psi ( i, j - 1, k ) ) / ( 2. * d.y() );
-}
-
-inline double Uintah::CCHeat3D::dz ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j, k + 1 ) - psi ( i, j, k - 1 ) ) / ( 2. * d.z() );
-}
-
-inline double Uintah::CCHeat3D::dxx ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) + psi ( i - 1, j, k ) - 2. * psi ( i, j, k ) ) / ( d.x() * d.x() );
-}
-
-inline double Uintah::CCHeat3D::dyy ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) + psi ( i, j - 1, k ) - 2. * psi ( i, j, k ) ) / ( d.y() * d.y() );
-}
-
-inline double Uintah::CCHeat3D::dzz ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j, k + 1 ) + psi ( i, j, k - 1 ) - 2. * psi ( i, j, k ) ) / ( d.z() * d.z() );
-}
-
-inline double Uintah::CCHeat3D::laplacian ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    return dxx ( i, j, k, patch, psi ) + dyy ( i, j, k, patch, psi ) + dzz ( i, j, k, patch, psi );
-}
-
-#endif // Packages_Uintah_CCA_Components_Head_CCHeat3D_h
diff --git a/src/CCA/Components/Heat/NCHeat2D.cc b/src/CCA/Components/Heat/NCHeat2D.cc
deleted file mode 100644
index c3f99f47..00000000
--- a/src/CCA/Components/Heat/NCHeat2D.cc
+++ /dev/null
@@ -1,576 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <CCA/Components/Heat/NCHeat2D.h>
-
-#include <CCA/Components/Heat/blockrange_io.h>
-
-#ifdef CUSTOM_OUT
-#   include <iomanip>
-#   include <sstream>
-#   include <Core/OS/Dir.h>
-#   include <CCA/Components/Heat/vtkfile.hpp>
-#   include <CCA/Components/Heat/pvtkfile.hpp>
-#endif
-
-using namespace Uintah;
-
-NCHeat2D::NCHeat2D ( const ProcessorGroup * myworld,
-		     const MaterialManagerP materialManager,
-		     int verbosity )
-  : ApplicationCommon ( myworld, materialManager )
-  , dbg_out1 ( "NCHeat2D", verbosity > 0 )
-  , dbg_out2 ( "NCHeat2D", verbosity > 1 )
-  , dbg_out3 ( "NCHeat2D", verbosity > 2 )
-  , dbg_out4 ( "NCHeat2D", verbosity > 3 )
-    //  , solver ( nullptr )
-//  , solver_parameters ( nullptr )
-{
-    u_label = VarLabel::create ( "u", Variable::getTypeDescription() );
-//  matrix_label = VarLabel::create ( "A", Matrix::getTypeDescription() );
-//  rhs_label = VarLabel::create ( "b", Variable::getTypeDescription() );
-// #ifdef DBG_MATRIX
-//  Ap_label = VarLabel::create ( "Ap", Variable::getTypeDescription() );
-//  Aw_label = VarLabel::create ( "Aw", Variable::getTypeDescription() );
-//  Ae_label = VarLabel::create ( "Ae", Variable::getTypeDescription() );
-//  An_label = VarLabel::create ( "An", Variable::getTypeDescription() );
-//  As_label = VarLabel::create ( "As", Variable::getTypeDescription() );
-//  At_label = VarLabel::create ( "At", Variable::getTypeDescription() );
-//  Ab_label = VarLabel::create ( "Ab", Variable::getTypeDescription() );
-// #endif
-}
-
-NCHeat2D::~NCHeat2D()
-{
-    VarLabel::destroy ( u_label );
-//  VarLabel::destroy ( matrix_label );
-//  VarLabel::destroy ( rhs_label );
-// #ifdef DBG_MATRIX
-//  VarLabel::destroy ( Ap_label );
-//  VarLabel::destroy ( Aw_label );
-//  VarLabel::destroy ( Ae_label );
-//  VarLabel::destroy ( An_label );
-//  VarLabel::destroy ( As_label );
-//  VarLabel::destroy ( At_label );
-//  VarLabel::destroy ( Ab_label );
-// #endif
-#ifdef CUSTOM_OUT
-    for ( auto pair : out_visit )
-    {
-        delete pair.second;
-    }
-#endif
-}
-
-void NCHeat2D::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & /*restart_prob_spec*/, GridP & /*grid*/ )
-{
-    setLockstepAMR( true );
-    
-    m_materialManager->registerSimpleMaterial ( scinew SimpleMaterial() );
-
-    ProblemSpecP heat = params->findBlock ( "FDHeat" );
-    std::string scheme;
-    heat->require ( "delt", delt );
-    heat->require ( "alpha", alpha );
-    heat->require ( "R0", r0 );
-    heat->getWithDefault ( "gamma", gamma, 1. );
-    heat->getWithDefault ( "scheme", scheme, "forward_euler" );
-    time_scheme = from_str ( scheme );
-    if ( time_scheme & TimeScheme::Implicit )
-    {
-//      ProblemSpecP solv = params->findBlock ( "Solver" );
-//      solver = dynamic_cast<SolverInterface *> ( getPort ( "solver" ) );
-//      if ( !solver ) throw InternalError ( "NCHeat2D:couldn't get solver port", __FILE__, __LINE__ );
-//      solver_parameters = solver->readParameters ( solv, "u" );
-//      solver_parameters->setSolveOnExtraCells ( false );
-        throw InternalError ( "\n ERROR: implicit solver not implemented for node centered variables", __FILE__, __LINE__ );
-    }
-
-#ifdef CUSTOM_OUT
-    dataArchiver = dynamic_cast<Output *> ( getPort ( "output" ) );
-#endif
-}
-
-void NCHeat2D::scheduleInitialize ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "NCHeat2D::task_initialize", this, &NCHeat2D::task_initialize );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void NCHeat2D::scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "NCHeat2D::task_compute_stable_timestep", this, &NCHeat2D::task_compute_stable_timestep );
-    task->computes ( getDelTLabel(), level.get_rep() );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void NCHeat2D::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    switch ( time_scheme )
-    {
-    case TimeScheme::ForwardEuler:
-        scheduleTimeAdvance_forward_euler ( level, sched );
-        break;
-    case TimeScheme::BackwardEuler:
-//      scheduleTimeAdvance_backward_euler_assemble ( level, sched );
-//      scheduleTimeAdvance_backward_euler_solve ( level, sched );
-        throw InternalError ( "\n ERROR: BackwardEuler time scheme not implemented for node centered variables\n", __FILE__, __LINE__ );
-        break;
-    default:
-        break;
-    }
-
-#ifdef CUSTOM_OUT
-    scheduleTimeAdvance_save ( level, sched );
-#endif
-}
-
-void NCHeat2D::scheduleTimeAdvance_forward_euler ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "NCHeat2D::task_farward_euler_time_advance", this, &NCHeat2D::task_farward_euler_time_advance );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundNodes, 1 );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-// void NCHeat2D::scheduleTimeAdvance_backward_euler_assemble ( LevelP const & level, SchedulerP & sched )
-// {
-//  Task * task = scinew Task ( "NCHeat2D::task_backward_euler_assemble", this, &NCHeat2D::task_backward_euler_assemble );
-//  task->requires ( Task::OldDW, u_label, Ghost::AroundNodes, 1 );
-//  task->computes ( matrix_label );
-//  task->computes ( rhs_label );
-// #ifdef DBG_MATRIX
-//  task->computes ( Ap_label );
-//  task->computes ( Aw_label );
-//  task->computes ( Ae_label );
-//  task->computes ( An_label );
-//  task->computes ( As_label );
-//  task->computes ( At_label );
-//  task->computes ( Ab_label );
-// #endif
-//  sched->addTask ( task, level->allPatches(), m_materialManager->allMaterials() );
-// }
-
-// void NCHeat2D::scheduleTimeAdvance_backward_euler_solve ( LevelP const & level, SchedulerP & sched )
-// {
-//  solver->scheduleSolve ( level, sched, m_materialManager->allMaterials(),
-//                          matrix_label, Task::NewDW, // A
-//                          u_label, false,            // x
-//                          rhs_label, Task::NewDW,    // b
-//                          u_label, Task::OldDW,      // guess
-//                          solver_parameters );
-// }
-
-#ifdef CUSTOM_OUT
-void NCHeat2D::scheduleTimeAdvance_save ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "NCHeat2D::task_save", this, &NCHeat2D::task_save );
-    task_save->requires ( Task::NewDW, u_label, Ghost::AroundNodes, 1 );
-    sched->addTask ( task_save, level->eachPatch(), m_materialManager->allMaterials() );
-}
-#endif
-
-void NCHeat2D::task_initialize ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== NCHeat2D::task_initialize ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        Variable u;
-        dw_new->allocateAndPut ( u, u_label, 0, patch );
-        dbg_out4 << "u \t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        BlockRange range ( get_range ( patch ) );
-        dbg_out3 << "= Iterating over range " << range << std::endl;
-        parallel_for ( range, [patch, &u, this] ( int i, int j, int k )->void { initialize ( i, j, k, patch, get_view ( u ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void NCHeat2D::task_compute_stable_timestep ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== NCHeat2D::task_compute_stable_timestep ====" << std::endl;
-    dw_new->put ( delt_vartype ( delt ), getDelTLabel(), getLevel ( patches ) );
-    dbg_out2 << std::endl;
-}
-
-void NCHeat2D::task_farward_euler_time_advance ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== NCHeat2D::task_farward_euler_time_advance ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u_old;
-        dw_old->get ( u_old, u_label, 0, patch, Ghost::AroundNodes, 1 );
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-
-        Variable u_new;
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ) ); } );
-
-        std::string bc_kind[4];
-        double bc_value[4];
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ), face, bc_kind, bc_value ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-// void Uintah::NCHeat2D::task_backward_euler_assemble ( const Uintah::ProcessorGroup * myworld, const PatchSubset * patches, const MaterialSubset * matls, Uintah::DataWarehouse * dw_old, Uintah::DataWarehouse * dw_new )
-// {
-//  dbg_out1 << "==== NCHeat2D::task_backward_euler_assemble ====" << std::endl;
-//
-//  for ( int p = 0; p < patches->size(); ++p )
-//  {
-//      const Patch * patch = patches->get ( p );
-//      dbg_out2 << "== Patch: " << *patch << std::endl;
-//
-//      ConstVariable u;
-//      dw_old->get ( u, u_label, 0, patch, Ghost::AroundNodes, 1 );
-//      dbg_out4 << "u\t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-//
-//      Matrix A;
-//      dw_new->allocateAndPut ( A, matrix_label, 0, patch );
-//      dbg_out4 << "A \t range " << A.getLowIndex() << A.getHighIndex() << std::endl;
-//
-// #ifdef DBG_MATRIX
-//      Variable Ap;
-//      dw_new->allocateAndPut ( Ap, Ap_label, 0, patch );
-//      dbg_out4 << "Ap \t range " << Ap.getLowIndex() << Ap.getHighIndex() << std::endl;
-//
-//      Variable Aw;
-//      dw_new->allocateAndPut ( Aw, Aw_label, 0, patch );
-//      dbg_out4 << "Aw \t range " << Aw.getLowIndex() << Aw.getHighIndex() << std::endl;
-//
-//      Variable Ae;
-//      dw_new->allocateAndPut ( Ae, Ae_label, 0, patch );
-//      dbg_out4 << "Ae \t range " << Ae.getLowIndex() << Ae.getHighIndex() << std::endl;
-//
-//      Variable An;
-//      dw_new->allocateAndPut ( An, An_label, 0, patch );
-//      dbg_out4 << "An \t range " << An.getLowIndex() << An.getHighIndex() << std::endl;
-//
-//      Variable As;
-//      dw_new->allocateAndPut ( As, As_label, 0, patch );
-//      dbg_out4 << "As \t range " << As.getLowIndex() << As.getHighIndex() << std::endl;
-//
-//      Variable At;
-//      dw_new->allocateAndPut ( At, At_label, 0, patch );
-//      dbg_out4 << "At \t range " << At.getLowIndex() << At.getHighIndex() << std::endl;
-//
-//      Variable Ab;
-//      dw_new->allocateAndPut ( Ab, Ab_label, 0, patch );
-//      dbg_out4 << "Ab \t range " << Ab.getLowIndex() << Ab.getHighIndex() << std::endl;
-// #endif
-//
-//      Variable b;
-//      dw_new->allocateAndPut ( b, rhs_label, 0, patch );
-//      dbg_out4 << "b\t range " << b.getLowIndex() << b.getHighIndex() << std::endl;
-//
-//      BlockRange range ( get_range ( patch ) );
-//      dbg_out3 << "= Iterating over range " << range << std::endl;
-//      Uintah::parallel_for ( range, [patch, &u, REF_A, &b, this] ( int i, int j, int k )->void { backward_euler_assemble ( i, j, k, patch, get_view ( u ), GET_VIEW_A, get_view ( b ) ); } );
-//
-//      std::string bc_kind[4];
-//      double bc_value[4];
-//      for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-//          if ( patch->getBCType ( face ) != Patch::Neighbor )
-//          {
-//              get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-//              dbg_out3 << "= Iterating over " << face << " face range " << range << " - BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-//              parallel_for ( range, [face, bc_value, bc_kind, patch, &u, REF_A, &b, this] ( int i, int j, int k )->void { backward_euler_assemble ( i, j, k, patch, get_view ( u ), GET_VIEW_A, get_view ( b ), face, bc_kind, bc_value ); } );
-//          }
-//  }
-//
-//  dbg_out2 << std::endl;
-// }
-
-#ifdef CUSTOM_OUT
-void NCHeat2D::task_save ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    if ( dataArchiver->isOutputTimestep() )
-    {
-        const Level * level = getLevel ( patches );
-        const int & levelID = level->getIndex();
-        std::string out_path, time_path, level_path, patch_path;
-        std::stringstream time_ss, level_ss;
-        out_path = dataArchiver->getOutputLocation();
-        const int & timestep = getTimestep();
-        time_ss << "t" << std::setw ( 5 ) << std::setfill ( '0' ) << timestep;
-        level_ss << "l" << levelID;
-        time_path = time_ss.str();
-        level_path = level_ss.str();
-        MKDIR ( std::string ( out_path + "/" + time_path ).c_str(), 0777 );
-        MKDIR ( std::string ( out_path + "/" + time_path + "/" + level_path ).c_str(), 0777 );
-
-        // WARNING only for one process/thread
-
-        PVtkFile * out_pvtk = new PVtkFile ( out_path +  "/" + time_path + "/" + level_path, time_path, timestep * delt );
-        for ( int pIndex = 0; pIndex < patches->size(); pIndex++ )
-        {
-            const Patch * patch = patches->get ( pIndex );
-            IntVector l = get_low ( patch );
-            IntVector h = get_high ( patch ) + IntVector (
-                              patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 1 : 0,
-                              patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 1 : 0,
-                              0
-                          );
-            Point p0 = get_position ( patch, l );
-            ConstVariable u;
-            dw_new->getRegion ( u, u_label, 0, level, l, h );
-
-            VtkFile * out_vtk = new VtkFile ( out_path + "/" + time_path + "/" + level_path, patch->getID() );
-            out_vtk->set_grid ( patch->getLevel()->dCell().x(), patch->getLevel()->dCell().y(), patch->getLevel()->dCell().z(), h.x() - l.x(), h.y() - l.y(), h.z() - l.z(), p0.x(), p0.y(), p0.z() );
-            out_vtk->add_node_data ( u_label->getName() + "/" + std::to_string ( levelID ), u, l, h );
-            out_vtk->save();
-            out_pvtk->add ( out_vtk->file_name() );
-            delete out_vtk;
-        } // end for pIndex
-        out_pvtk->save();
-
-        if ( out_visit.find ( levelID ) == out_visit.end() )
-        {
-            out_visit.emplace ( levelID, new VisitFile ( dataArchiver->getOutputLocation(), "level" + std::to_string ( levelID ), false ) );
-        }
-        out_visit[levelID]->add ( time_path + "/" + level_path + "/" + out_pvtk->file_name() );
-        delete out_pvtk;
-    }
-}
-#endif
-
-void NCHeat2D::initialize ( int i, int j, int k, Patch const * patch, VariableView u )
-{
-    IntVector n ( i, j, k );
-    Point p = get_position ( patch, n );
-    double r2 = p.x() * p.x() + p.y() * p.y();
-    double tmp = r2 - r0 * r0;
-    u[n] = - tanh ( gamma * tmp );
-}
-
-void NCHeat2D::forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new )
-{
-    double delta_u = delt * alpha * laplacian ( i, j, k, patch, u_old );
-    u_new ( i, j, k ) = u_old ( i, j, k ) + delta_u;
-}
-
-void NCHeat2D::forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] )
-{
-    const double d ( face / 2 );
-    const double h ( patch->getLevel()->dCell() [d] );
-
-    const double dx ( patch->getLevel()->dCell().x() );
-//  const double dy ( patch->getLevel()->dCell().y() );
-
-    const IntVector nl = get_low ( patch );
-    const IntVector nh = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    const IntVector n0 ( i, j, k );
-    const IntVector nm = n0 - patch->faceDirection ( face );
-//  const IntVector np = n0 + patch->faceDirection ( face );
-
-    const IntVector nw ( i - 1, j, k );
-    const IntVector ne ( i + 1, j, k );
-//  const IntVector ns ( i, j - 1, k );
-//  const IntVector nn ( i, j + 1, k );
-
-    if ( bc_kind[face] == "Dirichlet" )
-    {
-        u_new[n0] = bc_value[face];
-        if ( is_internal ( patch, nm, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on nm
-        {
-            u_new[nm] += ( delt * alpha * ( bc_value[face] - u_old[n0] ) ) / ( h * h );
-        }
-        return;
-    }
-    if ( bc_kind[face] == "Neumann" )
-    {
-        double delta_u = delt * alpha;
-        const double sgn ( patch->faceDirection ( face ) [d] );
-        double uxx = 0.;
-        double uyy = 0.;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            uxx = sgn * 2. * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            uyy = sgn * 2. * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            delta_u *=  uxx + uyy;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[n0] = u_old[n0] + delta_u;
-        return;
-    }
-}
-
-// void NCHeat2D::backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b )
-// {
-//  Vector const d ( patch->getLevel()->dCell() );
-//  IntVector n ( i, j, k );
-//  double a = - alpha * delt;
-//  double ax = a / ( d.x() * d.x() );
-//  double ay = a / ( d.y() * d.y() );
-//  A[n].p = 1. - 2. * (ax + ay);
-//  A[n].e = A[n].w = ax;
-//  A[n].n = A[n].s = ay;
-//  A[n].t = A[n].b = 0.;
-//  b[n] = u[n];
-// #ifdef DBG_MATRIX
-//  Ap[n] = A[n].p;
-//  Aw[n] = A[n].w;
-//  Ae[n] = A[n].e;
-//  As[n] = A[n].s;
-//  An[n] = A[n].n;
-//  At[n] = A[n].t;
-//  Ab[n] = A[n].b;
-// #endif
-// }
-
-// void NCHeat2D::backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] )
-// {
-//  switch ( patch->getBCType ( face ) )
-//  {
-//  case Patch::None:
-//  {
-//      const double d ( face / 2 );
-//      const double h ( patch->getLevel()->dCell() [d] );
-//      IntVector n0 ( i, j, k );
-//      IntVector n1 = n0 - patch->faceDirection ( face );
-//      double a = ( alpha * delt ) / ( h * h );
-//      {
-//          if ( bc_kind[face] == "Dirichlet" )
-//          {
-//              b[n0] = bc_value[face];
-//              if ( is_internal ( patch, n1, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on n1
-//                  b[n1] += a * bc_value[face];
-//              A[n0].p = 1;
-//              A[n0].e = A[n0].w = 0.;
-//              A[n0].n = A[n0].s = 0.;
-//              A[n0].t = A[n0].b = 0.;
-//              A[n1][face] = 0.;
-// #ifdef DBG_MATRIX
-//              Ap[n0] = A[n0].p;
-//              Aw[n0] = A[n0].w;
-//              Ae[n0] = A[n0].e;
-//              As[n0] = A[n0].s;
-//              An[n0] = A[n0].n;
-//              At[n0] = A[n0].t;
-//              Ab[n0] = A[n0].b;
-//
-//              Ap[n1] = A[n1].p;
-//              Aw[n1] = A[n1].w;
-//              Ae[n1] = A[n1].e;
-//              As[n1] = A[n1].s;
-//              An[n1] = A[n1].n;
-//              At[n1] = A[n1].t;
-//              Ab[n1] = A[n1].b;
-// #endif
-//              return;
-//          }
-//          if ( bc_kind[face] == "Neumann" )
-//          {
-//              if ( !is_internal ( patch, n0, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on n0
-//                  return;
-//              const double sgn ( patch->faceDirection ( face ) [d] );
-//              A[n0].p -= a;
-//              A[n0][face] = 0.;
-// #ifdef DBG_MATRIX
-//              Ap[n0] = A[n0].p;
-//              Aw[n0] = A[n0].w;
-//              Ae[n0] = A[n0].e;
-//              As[n0] = A[n0].s;
-//              An[n0] = A[n0].n;
-//              At[n0] = A[n0].t;
-//              Ab[n0] = A[n0].b;
-// #endif
-//              b[n0] -= a * sgn * h * bc_value[face];
-//              return;
-//          }
-//      }
-//  }
-//  default:
-//      return;
-//  }
-// }
diff --git a/src/CCA/Components/Heat/NCHeat2D.h b/src/CCA/Components/Heat/NCHeat2D.h
deleted file mode 100644
index 66a78fea..00000000
--- a/src/CCA/Components/Heat/NCHeat2D.h
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_NCHeat2D_h
-#define Packages_Uintah_CCA_Components_Heat_NCHeat2D_h
-
-#include <CCA/Components/Application/ApplicationCommon.h>
-
-#include <Core/Grid/BoundaryConditions/BCDataArray.h>
-#include <Core/Grid/BoundaryConditions/BoundCond.h>
-#include <Core/Grid/Ghost.h>
-#include <Core/Grid/Patch.h>
-#include <Core/Grid/SimpleMaterial.h>
-#include <Core/Grid/Task.h>
-#include <Core/Grid/Variables/BlockRange.hpp>
-#include <Core/Grid/Variables/NCVariable.h>
-#include <Core/Grid/Variables/VarLabel.h>
-#include <Core/Util/DebugStream.h>
-#include <CCA/Components/Heat/TimeScheme.h>
-#include <CCA/Ports/Scheduler.h>
-// #include <CCA/Ports/SolverInterface.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-#ifdef CUSTOM_OUT
-#   include <CCA/Components/Heat/visitfile.hpp>
-#   include <CCA/Ports/Output.h>
-#endif
-
-// #define DBG_MATRIX
-
-namespace Uintah
-{
-
-class NCHeat2D :
-    public ApplicationCommon
-{
-protected:
-    using ConstVariable = constNCVariable<double>;
-    using Variable = NCVariable<double>;
-//  using ConstMatrix = constNCVariable<Stencil7>;
-//  using Matrix = NCVariable<Stencil7>;
-#ifdef UINTAH_ENABLE_KOKKOS
-    using ConstVariableView = KokkosView3<double const>;
-    using VariableView = KokkosView3<double>;
-//  using MatrixView = KokkosView3<Stencil7>;
-#else
-    using ConstVariableView = ConstVariable & ;
-    using VariableView = Variable & ;
-//  using MatrixView = Matrix & ;
-#endif
-
-    static constexpr Patch::FaceType start_face = Patch::xminus;
-    static constexpr Patch::FaceType end_face = Patch::yplus;
-
-    static constexpr inline ConstVariableView get_view ( ConstVariable & var );
-    static constexpr inline VariableView get_view ( Variable & var );
-//  static constexpr inline MatrixView get_view ( Matrix & var );
-
-    static inline IntVector get_low ( Patch const * patch );
-    static inline IntVector get_high ( Patch const * patch );
-    static inline BlockRange get_range ( Patch const * patch );
-    static inline BlockRange get_inner_range ( Patch const * patch );
-    static inline BlockRange get_face_range ( Patch const * patch, Patch::FaceType face );
-    static inline void get_bc ( Patch const * patch, Patch::FaceType face, const int child, const std::string & desc, const int mat_id, BlockRange & range, std::string & bc_kind, double & bc_value );
-    static inline Point get_position ( Patch const * patch, IntVector const & i );
-    static inline bool is_internal ( const Patch * patch, const IntVector & i, int d, const std::string bc_kind[4] );
-
-    static inline double dx ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dy ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dxx ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dyy ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double laplacian ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-
-protected:
-    double const tol = 1.e-6;
-
-    DebugStream dbg_out1, dbg_out2, dbg_out3, dbg_out4;
-
-    double delt, alpha, r0, gamma;
-    TimeScheme time_scheme;
-
-    const VarLabel * u_label;
-//  const VarLabel * matrix_label, * rhs_label;
-// #ifdef DBG_MATRIX
-// #define MATRIX_VIEW_A MatrixView A, VariableView Ap, VariableView Aw, VariableView Ae, VariableView As, VariableView An, VariableView Ab, VariableView At
-// #define REF_A &A, &Ap, &Aw, &Ae, &As, &An, &Ab, &At
-// #define GET_VIEW_A get_view ( A ), get_view ( Ap ), get_view ( Aw ), get_view ( Ae ), get_view ( As ), get_view ( An ), get_view ( Ab ), get_view ( At )
-//  const VarLabel * Ap_label, * Aw_label, * Ae_label, * As_label, * An_label, * Ab_label, * At_label;
-// #else
-// #define MATRIX_VIEW_A MatrixView A
-// #define REF_A &A
-// #define GET_VIEW_A get_view ( A )
-// #endif
-
-//  SolverInterface * solver;
-//  SolverParameters * solver_parameters;
-
-#ifdef CUSTOM_OUT
-    Output * dataArchiver;
-    std::map<int, VisitFile *> out_visit;
-#endif
-
-public:
-    NCHeat2D ( const ProcessorGroup * myworld,
-	       const MaterialManagerP materialManager,
-	       int verbosity = 0 );
-  
-    virtual ~NCHeat2D();
-
-protected:
-    NCHeat2D ( NCHeat2D const & ) = delete;
-    NCHeat2D & operator= ( NCHeat2D const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleInitialize ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleRestartInitialize ( LevelP const & /*level*/, SchedulerP & /*sched*/ ) override {} // TODO
-    virtual void scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-
-    void scheduleTimeAdvance_forward_euler ( LevelP const & level, SchedulerP & );
-//  void scheduleTimeAdvance_backward_euler_assemble ( LevelP const & level, SchedulerP & );
-//  void scheduleTimeAdvance_backward_euler_solve ( LevelP const & level, SchedulerP & );
-#ifdef CUSTOM_OUT
-    void scheduleTimeAdvance_save ( LevelP const & level, SchedulerP & );
-#endif
-
-    void task_initialize ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_compute_stable_timestep ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_farward_euler_time_advance ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_backward_euler_assemble ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-#ifdef CUSTOM_OUT
-    void task_save ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-#endif
-
-    void initialize ( int i, int j, int k, Patch const * patch, VariableView u );
-    void forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new );
-    void forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] );
-//  void backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b );
-//  void backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b, Patch::FaceType face, const std::string bc_kind[4], const double bc_value[4] );
-}; // class NCHeat2D
-
-} // namespace Uintah
-
-constexpr inline Uintah::NCHeat2D::ConstVariableView Uintah::NCHeat2D::get_view ( ConstVariable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-constexpr inline Uintah::NCHeat2D::VariableView Uintah::NCHeat2D::get_view ( Variable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-// constexpr inline Uintah::NCHeat2D::MatrixView Uintah::NCHeat2D::get_view ( Matrix & var )
-// {
-// #ifdef UINTAH_ENABLE_KOKKOS
-//  return var.getKokkosView();
-// #else
-//  return var;
-// #endif
-// }
-
-inline Uintah::Point Uintah::NCHeat2D::get_position ( Patch const * patch, IntVector const & i )
-{
-    return patch->getNodePosition ( i );
-}
-
-inline Uintah::IntVector Uintah::NCHeat2D::get_low ( Patch const * patch )
-{
-    return patch->getNodeLowIndex();
-}
-
-inline Uintah::IntVector Uintah::NCHeat2D::get_high ( Patch const * patch )
-{
-    return patch->getNodeHighIndex();
-}
-
-inline Uintah::BlockRange Uintah::NCHeat2D::get_range ( Patch const * patch )
-{
-    return { get_low ( patch ), get_high ( patch ) };
-}
-
-inline Uintah::BlockRange Uintah::NCHeat2D::get_inner_range ( Patch const * patch )
-{
-    return { get_low ( patch ) + IntVector (
-                 patch->getBCType ( Patch::xminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yminus ) == Patch::Neighbor ? 0 : 1,
-                 0
-             ),
-             get_high ( patch ) - IntVector (
-                 patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 0 : 1,
-                 0
-             )
-           };
-}
-
-inline Uintah::BlockRange Uintah::NCHeat2D::get_face_range ( Patch const * patch, Patch::FaceType face )
-{
-    IntVector l, h;
-    patch->getFaceNodes ( face, 0, l, h );
-    return { l, h };
-}
-
-inline void Uintah::NCHeat2D::get_bc ( const Uintah::Patch * patch, Patch::FaceType face, const int child, const std::string & desc, const int mat_id, BlockRange & range, std::string & bc_kind, double & bc_value )
-{
-    range = get_face_range ( patch, face );
-    bc_kind = "NotSet";
-    bc_value = 0.;
-
-    if ( desc == "zeroNeumann" )
-    {
-        bc_kind = "zeroNeumann";
-        return;
-    }
-
-    if ( patch->getBCType ( face ) == Patch::Coarse )
-    {
-        bc_kind = "FineCoarseInterface";
-        return;
-    }
-
-    if ( patch->getBCType ( face ) == Patch::Neighbor )
-    {
-        bc_kind = "Neighbor";
-        return;
-    }
-
-    const BCDataArray * bcd = patch->getBCDataArray ( face );
-    if ( !bcd ) return;
-
-    const BoundCondBase * bc;
-    if ( ( bc = bcd->getBoundCondData ( mat_id, desc, child ) ) )
-    {
-        const BoundCond<double> * bcs = dynamic_cast<const BoundCond<double> *> ( bc );;
-        if ( bcs )
-        {
-            bc_kind  = bcs->getBCType();
-            bc_value = bcs->getValue();
-        }
-    }
-    else if ( ( bc = bcd->getBoundCondData ( mat_id, "Symmetric", child ) ) )
-    {
-        if ( bc->getBCType() == "symmetry" ) bc_kind  = "symmetry";
-    }
-    if ( bc ) delete bc;
-    return;
-}
-
-bool Uintah::NCHeat2D::is_internal ( const Patch * patch, const IntVector & i, int d, const std::string bc_kind[4] )
-{
-    IntVector l = get_low ( patch );
-    IntVector h = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    for ( int k = 0; k < d; ++k )
-    {
-        if ( bc_kind[2 * k] == "Dirichlet" && i[k] <= l[k] ) return false;
-        if ( bc_kind[2 * k + 1] == "Dirichlet" && i[k] >= h[k] ) return false;
-    }
-    return true;
-}
-
-inline double Uintah::NCHeat2D::dx ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) - psi ( i - 1, j, k ) ) / ( 2. * d.x() );
-}
-
-inline double Uintah::NCHeat2D::dy ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) - psi ( i, j - 1, k ) ) / ( 2. * d.y() );
-}
-
-inline double Uintah::NCHeat2D::dxx ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) + psi ( i - 1, j, k ) - 2. * psi ( i, j, k ) ) / ( d.x() * d.x() );
-}
-
-inline double Uintah::NCHeat2D::dyy ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) + psi ( i, j - 1, k ) - 2. * psi ( i, j, k ) ) / ( d.y() * d.y() );
-}
-
-inline double Uintah::NCHeat2D::laplacian ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    return dxx ( i, j, k, patch, psi ) + dyy ( i, j, k, patch, psi );
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_NCHeat2D_h
diff --git a/src/CCA/Components/Heat/NCHeat3D.cc b/src/CCA/Components/Heat/NCHeat3D.cc
deleted file mode 100644
index 29fe3420..00000000
--- a/src/CCA/Components/Heat/NCHeat3D.cc
+++ /dev/null
@@ -1,656 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <CCA/Components/Heat/NCHeat3D.h>
-
-#include <CCA/Components/Heat/blockrange_io.h>
-
-#ifdef CUSTOM_OUT
-#   include <iomanip>
-#   include <sstream>
-#   include <Core/OS/Dir.h>
-#   include <CCA/Components/Heat/vtkfile.hpp>
-#   include <CCA/Components/Heat/pvtkfile.hpp>
-#endif
-
-using namespace Uintah;
-
-NCHeat3D::NCHeat3D ( const ProcessorGroup * myworld,
-		     const MaterialManagerP materialManager,
-		     int verbosity )
-  : ApplicationCommon ( myworld, materialManager )
-  , dbg_out1 ( "NCHeat3D", verbosity > 0 )
-  , dbg_out2 ( "NCHeat3D", verbosity > 1 )
-  , dbg_out3 ( "NCHeat3D", verbosity > 2 )
-  , dbg_out4 ( "NCHeat3D", verbosity > 3 )
-//  , solver ( nullptr )
-//  , solver_parameters ( nullptr )
-{
-    u_label = VarLabel::create ( "u", Variable::getTypeDescription() );
-//  matrix_label = VarLabel::create ( "A", Matrix::getTypeDescription() );
-//  rhs_label = VarLabel::create ( "b", Variable::getTypeDescription() );
-// #ifdef DBG_MATRIX
-//  Ap_label = VarLabel::create ( "Ap", Variable::getTypeDescription() );
-//  Aw_label = VarLabel::create ( "Aw", Variable::getTypeDescription() );
-//  Ae_label = VarLabel::create ( "Ae", Variable::getTypeDescription() );
-//  An_label = VarLabel::create ( "An", Variable::getTypeDescription() );
-//  As_label = VarLabel::create ( "As", Variable::getTypeDescription() );
-//  At_label = VarLabel::create ( "At", Variable::getTypeDescription() );
-//  Ab_label = VarLabel::create ( "Ab", Variable::getTypeDescription() );
-// #endif
-}
-
-NCHeat3D::~NCHeat3D()
-{
-    VarLabel::destroy ( u_label );
-//  VarLabel::destroy ( matrix_label );
-//  VarLabel::destroy ( rhs_label );
-// #ifdef DBG_MATRIX
-//  VarLabel::destroy ( Ap_label );
-//  VarLabel::destroy ( Aw_label );
-//  VarLabel::destroy ( Ae_label );
-//  VarLabel::destroy ( An_label );
-//  VarLabel::destroy ( As_label );
-//  VarLabel::destroy ( At_label );
-//  VarLabel::destroy ( Ab_label );
-// #endif
-#ifdef CUSTOM_OUT
-    for ( auto pair : out_visit )
-    {
-        delete pair.second;
-    }
-#endif
-}
-
-void NCHeat3D::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & /*restart_prob_spec*/, GridP & /*grid*/ )
-{
-    setLockstepAMR( true );
-
-    m_materialManager->registerSimpleMaterial ( scinew SimpleMaterial() );
-
-    ProblemSpecP heat = params->findBlock ( "FDHeat" );
-    std::string scheme;
-    heat->require ( "delt", delt );
-    heat->require ( "alpha", alpha );
-    heat->require ( "R0", r0 );
-    heat->getWithDefault ( "gamma", gamma, 1. );
-    heat->getWithDefault ( "scheme", scheme, "forward_euler" );
-    time_scheme = from_str ( scheme );
-    if ( time_scheme & TimeScheme::Implicit )
-    {
-//      ProblemSpecP solv = params->findBlock ( "Solver" );
-//      solver = dynamic_cast<SolverInterface *> ( getPort ( "solver" ) );
-//      if ( !solver ) throw InternalError ( "NCHeat3D:couldn't get solver port", __FILE__, __LINE__ );
-//      solver_parameters = solver->readParameters ( solv, "u" );
-//      solver_parameters->setSolveOnExtraCells ( false );
-        throw InternalError ( "\n ERROR: implicit solver not implemented for node centered variables", __FILE__, __LINE__ );
-    }
-
-#ifdef CUSTOM_OUT
-    dataArchiver = dynamic_cast<Output *> ( getPort ( "output" ) );
-#endif
-}
-
-void NCHeat3D::scheduleInitialize ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "NCHeat3D::task_initialize", this, &NCHeat3D::task_initialize );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void NCHeat3D::scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "NCHeat3D::task_compute_stable_timestep", this, &NCHeat3D::task_compute_stable_timestep );
-    task->computes ( getDelTLabel(), level.get_rep() );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-void NCHeat3D::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    switch ( time_scheme )
-    {
-    case TimeScheme::ForwardEuler:
-        scheduleTimeAdvance_forward_euler ( level, sched );
-        break;
-    case TimeScheme::BackwardEuler:
-//      scheduleTimeAdvance_backward_euler_assemble ( level, sched );
-//      scheduleTimeAdvance_backward_euler_solve ( level, sched );
-        throw InternalError ( "\n ERROR: BackwardEuler time scheme not implemented for node centered variables\n", __FILE__, __LINE__ );
-        break;
-    default:
-        break;
-    }
-
-#ifdef CUSTOM_OUT
-    scheduleTimeAdvance_save ( level, sched );
-#endif
-}
-
-void NCHeat3D::scheduleTimeAdvance_forward_euler ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "NCHeat3D::task_farward_euler_time_advance", this, &NCHeat3D::task_farward_euler_time_advance );
-    task->requires ( Task::OldDW, u_label, Ghost::AroundNodes, 1 );
-    task->computes ( u_label );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-// void NCHeat3D::scheduleTimeAdvance_backward_euler_assemble ( LevelP const & level, SchedulerP & sched )
-// {
-//  Task * task = scinew Task ( "NCHeat3D::task_backward_euler_assemble", this, &NCHeat3D::task_backward_euler_assemble );
-//  task->requires ( Task::OldDW, u_label, Ghost::AroundNodes, 1 );
-//  task->computes ( matrix_label );
-//  task->computes ( rhs_label );
-// #ifdef DBG_MATRIX
-//  task->computes ( Ap_label );
-//  task->computes ( Aw_label );
-//  task->computes ( Ae_label );
-//  task->computes ( An_label );
-//  task->computes ( As_label );
-//  task->computes ( At_label );
-//  task->computes ( Ab_label );
-// #endif
-//  sched->addTask ( task, level->allPatches(), m_materialManager->allMaterials() );
-// }
-
-// void NCHeat3D::scheduleTimeAdvance_backward_euler_solve ( LevelP const & level, SchedulerP & sched )
-// {
-//  solver->scheduleSolve ( level, sched, m_materialManager->allMaterials(),
-//                          matrix_label, Task::NewDW, // A
-//                          u_label, false,            // x
-//                          rhs_label, Task::NewDW,    // b
-//                          u_label, Task::OldDW,      // guess
-//                          solver_parameters );
-// }
-
-#ifdef CUSTOM_OUT
-void NCHeat3D::scheduleTimeAdvance_save ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "NCHeat3D::task_save", this, &NCHeat3D::task_save );
-    task_save->requires ( Task::NewDW, u_label, Ghost::AroundNodes, 1 );
-    sched->addTask ( task_save, level->eachPatch(), m_materialManager->allMaterials() );
-}
-#endif
-
-void NCHeat3D::task_initialize ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== NCHeat3D::task_initialize ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        Variable u;
-        dw_new->allocateAndPut ( u, u_label, 0, patch );
-        dbg_out4 << "u \t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-
-        BlockRange range ( get_range ( patch ) );
-        dbg_out3 << "= Iterating over range " << range << std::endl;
-        parallel_for ( range, [patch, &u, this] ( int i, int j, int k )->void { initialize ( i, j, k, patch, get_view ( u ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-void NCHeat3D::task_compute_stable_timestep ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== NCHeat3D::task_compute_stable_timestep ====" << std::endl;
-    dw_new->put ( delt_vartype ( delt ), getDelTLabel(), getLevel ( patches ) );
-    dbg_out2 << std::endl;
-}
-
-void NCHeat3D::task_farward_euler_time_advance ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== NCHeat3D::task_farward_euler_time_advance ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable u_old;
-        dw_old->get ( u_old, u_label, 0, patch, Ghost::AroundNodes, 1 );
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-
-        Variable u_new;
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        Uintah::parallel_for ( range, [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ) ); } );
-
-        std::string bc_kind[6];
-        double bc_value[6];
-        for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-                dbg_out3 << "= Iterating over " << face << " face range " << range << " BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-                parallel_for ( range, [face, bc_value, bc_kind, patch, &u_old, &u_new, this] ( int i, int j, int k )->void { forward_euler_time_advance ( i, j, k, patch, get_view ( u_old ), get_view ( u_new ), face, bc_kind, bc_value ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-// void Uintah::NCHeat3D::task_backward_euler_assemble ( const Uintah::ProcessorGroup * myworld, const PatchSubset * patches, const MaterialSubset * matls, Uintah::DataWarehouse * dw_old, Uintah::DataWarehouse * dw_new )
-// {
-//  dbg_out1 << "==== NCHeat3D::task_backward_euler_assemble ====" << std::endl;
-//
-//  for ( int p = 0; p < patches->size(); ++p )
-//  {
-//      const Patch * patch = patches->get ( p );
-//      dbg_out2 << "== Patch: " << *patch << std::endl;
-//
-//      ConstVariable u;
-//      dw_old->get ( u, u_label, 0, patch, Ghost::AroundNodes, 1 );
-//      dbg_out4 << "u\t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-//
-//      Matrix A;
-//      dw_new->allocateAndPut ( A, matrix_label, 0, patch );
-//      dbg_out4 << "A \t range " << A.getLowIndex() << A.getHighIndex() << std::endl;
-//
-// #ifdef DBG_MATRIX
-//      Variable Ap;
-//      dw_new->allocateAndPut ( Ap, Ap_label, 0, patch );
-//      dbg_out4 << "Ap \t range " << Ap.getLowIndex() << Ap.getHighIndex() << std::endl;
-//
-//      Variable Aw;
-//      dw_new->allocateAndPut ( Aw, Aw_label, 0, patch );
-//      dbg_out4 << "Aw \t range " << Aw.getLowIndex() << Aw.getHighIndex() << std::endl;
-//
-//      Variable Ae;
-//      dw_new->allocateAndPut ( Ae, Ae_label, 0, patch );
-//      dbg_out4 << "Ae \t range " << Ae.getLowIndex() << Ae.getHighIndex() << std::endl;
-//
-//      Variable An;
-//      dw_new->allocateAndPut ( An, An_label, 0, patch );
-//      dbg_out4 << "An \t range " << An.getLowIndex() << An.getHighIndex() << std::endl;
-//
-//      Variable As;
-//      dw_new->allocateAndPut ( As, As_label, 0, patch );
-//      dbg_out4 << "As \t range " << As.getLowIndex() << As.getHighIndex() << std::endl;
-//
-//      Variable At;
-//      dw_new->allocateAndPut ( At, At_label, 0, patch );
-//      dbg_out4 << "At \t range " << At.getLowIndex() << At.getHighIndex() << std::endl;
-//
-//      Variable Ab;
-//      dw_new->allocateAndPut ( Ab, Ab_label, 0, patch );
-//      dbg_out4 << "Ab \t range " << Ab.getLowIndex() << Ab.getHighIndex() << std::endl;
-// #endif
-//
-//      Variable b;
-//      dw_new->allocateAndPut ( b, rhs_label, 0, patch );
-//      dbg_out4 << "b\t range " << b.getLowIndex() << b.getHighIndex() << std::endl;
-//
-//      BlockRange range ( get_range ( patch ) );
-//      dbg_out3 << "= Iterating over range " << range << std::endl;
-//      Uintah::parallel_for ( range, [patch, &u, REF_A, &b, this] ( int i, int j, int k )->void { backward_euler_assemble ( i, j, k, patch, get_view ( u ), GET_VIEW_A, get_view ( b ) ); } );
-//
-//      std::string bc_kind[6];
-//      double bc_value[6];
-//      for ( auto face = start_face; face <= end_face; face = Patch::nextFace ( face ) )
-//          if ( patch->getBCType ( face ) != Patch::Neighbor )
-//          {
-//              get_bc ( patch, face, 0, "u", 0, range, bc_kind[face], bc_value[face] ); // I don't need to know bc_kind for faces > face
-//              dbg_out3 << "= Iterating over " << face << " face range " << range << " - BC " << bc_kind[face] << " " << bc_value[face] << std::endl;
-//              parallel_for ( range, [face, bc_value, bc_kind, patch, &u, REF_A, &b, this] ( int i, int j, int k )->void { backward_euler_assemble ( i, j, k, patch, get_view ( u ), GET_VIEW_A, get_view ( b ), face, bc_kind, bc_value ); } );
-//          }
-//  }
-//
-//  dbg_out2 << std::endl;
-// }
-
-#ifdef CUSTOM_OUT
-void NCHeat3D::task_save ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    if ( dataArchiver->isOutputTimestep() )
-    {
-        const Level * level = getLevel ( patches );
-        const int & levelID = level->getIndex();
-        std::string out_path, time_path, level_path, patch_path;
-        std::stringstream time_ss, level_ss;
-        out_path = dataArchiver->getOutputLocation();
-        const int & timestep = getTimestep();
-        time_ss << "t" << std::setw ( 5 ) << std::setfill ( '0' ) << timestep;
-        level_ss << "l" << levelID;
-        time_path = time_ss.str();
-        level_path = level_ss.str();
-        MKDIR ( std::string ( out_path + "/" + time_path ).c_str(), 0777 );
-        MKDIR ( std::string ( out_path + "/" + time_path + "/" + level_path ).c_str(), 0777 );
-
-        // WARNING only for one process/thread
-
-        PVtkFile * out_pvtk = new PVtkFile ( out_path +  "/" + time_path + "/" + level_path, time_path, timestep * delt );
-        for ( int pIndex = 0; pIndex < patches->size(); pIndex++ )
-        {
-            const Patch * patch = patches->get ( pIndex );
-            IntVector l = get_low ( patch );
-            IntVector h = get_high ( patch ) + IntVector (
-                              patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 1 : 0,
-                              patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 1 : 0,
-                              patch->getBCType ( Patch::zplus ) == Patch::Neighbor ? 1 : 0
-                          );
-            Point p0 = get_position ( patch, l );
-            ConstVariable u;
-            dw_new->getRegion ( u, u_label, 0, level, l, h );
-
-            VtkFile * out_vtk = new VtkFile ( out_path + "/" + time_path + "/" + level_path, patch->getID() );
-            out_vtk->set_grid ( patch->getLevel()->dCell().x(), patch->getLevel()->dCell().y(), patch->getLevel()->dCell().z(), h.x() - l.x(), h.y() - l.y(), h.z() - l.z(), p0.x(), p0.y(), p0.z() );
-            out_vtk->add_node_data ( u_label->getName() + "/" + std::to_string ( levelID ), u, l, h );
-            out_vtk->save();
-            out_pvtk->add ( out_vtk->file_name() );
-            delete out_vtk;
-        } // end for pIndex
-        out_pvtk->save();
-
-        if ( out_visit.find ( levelID ) == out_visit.end() )
-        {
-            out_visit.emplace ( levelID, new VisitFile ( dataArchiver->getOutputLocation(), "level" + std::to_string ( levelID ), false ) );
-        }
-        out_visit[levelID]->add ( time_path + "/" + level_path + "/" + out_pvtk->file_name() );
-        delete out_pvtk;
-    }
-}
-#endif
-
-void NCHeat3D::initialize ( int i, int j, int k, Patch const * patch, VariableView u )
-{
-    IntVector n ( i, j, k );
-    Point p = get_position ( patch, n );
-    double r2 = p.x() * p.x() + p.y() * p.y() + p.z() * p.z();
-    double tmp = r2 - r0 * r0;
-    u[n] = - tanh ( gamma * tmp );
-}
-
-void NCHeat3D::forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new )
-{
-    double delta_u = delt * alpha * laplacian ( i, j, k, patch, u_old );
-    u_new ( i, j, k ) = u_old ( i, j, k ) + delta_u;
-}
-
-void NCHeat3D::forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[6], const double bc_value[6] )
-{
-    const double d ( face / 2 );
-    const double h ( patch->getLevel()->dCell() [d] );
-
-    const double dx ( patch->getLevel()->dCell().x() );
-    const double dy ( patch->getLevel()->dCell().y() );
-//  const double dz ( patch->getLevel()->dCell().z() );
-
-    const IntVector nl = get_low ( patch );
-    const IntVector nh = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    const IntVector n0 ( i, j, k );
-    const IntVector nm = n0 - patch->faceDirection ( face );
-//  const IntVector np = n0 + patch->faceDirection ( face );
-
-    const IntVector nw ( i - 1, j, k );
-    const IntVector ne ( i + 1, j, k );
-    const IntVector ns ( i, j - 1, k );
-    const IntVector nn ( i, j + 1, k );
-//  const IntVector nb ( i, j, k - 1 );
-//  const IntVector nt ( i, j, k + 1 );
-
-    if ( bc_kind[face] == "Dirichlet" )
-    {
-        u_new[n0] = bc_value[face];
-        if ( is_internal ( patch, nm, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on nm
-        {
-            u_new[nm] += ( delt * alpha * ( bc_value[face] - u_old[n0] ) ) / ( h * h );
-        }
-        return;
-    }
-    if ( bc_kind[face] == "Neumann" )
-    {
-        double delta_u = delt * alpha;
-        const double sgn ( patch->faceDirection ( face ) [d] );
-        double uxx = 0.;
-        double uyy = 0.;
-        double uzz = 0.;
-
-        switch ( face )
-        {
-        case Patch::xminus:
-        case Patch::xplus:
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                return;    // handled by yminus
-            }
-            if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                return;    // handled by yplus
-            }
-            if ( k == nl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == nh.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            uxx = sgn * 2. * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            uyy = dyy ( i, j, k, patch, u_old );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *= uxx + uyy + uzz;
-            break;
-        case Patch::yminus:
-        case Patch::yplus:
-            if ( k == nl.z() && patch->getBCType ( Patch::zminus ) != Patch::Neighbor )
-            {
-                return;    // handled by zminus
-            }
-            if ( k == nh.z() && patch->getBCType ( Patch::zplus ) != Patch::Neighbor )
-            {
-                return;    // handled by zplus
-            }
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            uyy = sgn * 2. * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            uzz = dzz ( i, j, k, patch, u_old );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        case Patch::zminus:
-        case Patch::zplus:
-            if ( i == nl.x() && patch->getBCType ( Patch::xminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xminus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[ne] - u_old[n0] - bc_value[Patch::xminus] * dx ) / ( dx * dx );
-                }
-            }
-            else if ( i == nh.x() && patch->getBCType ( Patch::xplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::xplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::xplus] == "Neumann" )
-                {
-                    uxx = 2. * ( u_old[n0] - u_old[nw] + bc_value[Patch::xplus] * dx ) / ( dx * dx );
-                }
-            }
-            else
-            {
-                uxx = dxx ( i, j, k, patch, u_old );
-            }
-            if ( j == nl.y() && patch->getBCType ( Patch::yminus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yminus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yminus] == "Neumann" )
-                {
-                    uyy = ( u_old[nn] - u_old[n0] - bc_value[Patch::yminus] * dy ) / ( dy * dy );
-                }
-            }
-            else if ( j == nh.y() && patch->getBCType ( Patch::yplus ) != Patch::Neighbor )
-            {
-                if ( bc_kind[Patch::yplus] == "Dirichlet" )
-                {
-                    return;
-                }
-                else if ( bc_kind[Patch::yplus] == "Neumann" )
-                {
-                    uyy = ( u_old[n0] - u_old[ns] + bc_value[Patch::yplus] * dy ) / ( dy * dy );
-                }
-            }
-            else
-            {
-                uyy = dyy ( i, j, k, patch, u_old );
-            }
-            uzz = sgn * ( u_old[n0] - u_old[nm] + bc_value[face] * h ) / ( h * h );
-            delta_u *=  uxx + uyy + uzz;
-            break;
-        default:
-            delta_u = 0.;
-        }
-        u_new[n0] = u_old[n0] + delta_u;
-        return;
-    }
-}
-
-// void NCHeat3D::backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b )
-// {
-//  Vector const d ( patch->getLevel()->dCell() );
-//  IntVector n ( i, j, k );
-//  double a = - alpha * delt;
-//  double ax = a / ( d.x() * d.x() );
-//  double ay = a / ( d.y() * d.y() );
-//  double az = a / ( d.z() * d.z() );
-//  A[n].p = 1. - 2. * (ax + ay);
-//  A[n].e = A[n].w = ax;
-//  A[n].n = A[n].s = ay;
-//  A[n].t = A[n].b = az.;
-//  b[n] = u[n];
-// #ifdef DBG_MATRIX
-//  Ap[n] = A[n].p;
-//  Aw[n] = A[n].w;
-//  Ae[n] = A[n].e;
-//  As[n] = A[n].s;
-//  An[n] = A[n].n;
-//  At[n] = A[n].t;
-//  Ab[n] = A[n].b;
-// #endif
-// }
-
-// void NCHeat3D::backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b, Patch::FaceType face, const std::string bc_kind[6], const double bc_value[6] )
-// {
-//  switch ( patch->getBCType ( face ) )
-//  {
-//  case Patch::None:
-//  {
-//      const double d ( face / 2 );
-//      const double h ( patch->getLevel()->dCell() [d] );
-//      IntVector n0 ( i, j, k );
-//      IntVector n1 = n0 - patch->faceDirection ( face );
-//      double a = ( alpha * delt ) / ( h * h );
-//      {
-//          if ( bc_kind[face] == "Dirichlet" )
-//          {
-//              b[n0] = bc_value[face];
-//              if ( is_internal ( patch, n1, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on n1
-//                  b[n1] += a * bc_value[face];
-//              A[n0].p = 1;
-//              A[n0].e = A[n0].w = 0.;
-//              A[n0].n = A[n0].s = 0.;
-//              A[n0].t = A[n0].b = 0.;
-//              A[n1][face] = 0.;
-// #ifdef DBG_MATRIX
-//              Ap[n0] = A[n0].p;
-//              Aw[n0] = A[n0].w;
-//              Ae[n0] = A[n0].e;
-//              As[n0] = A[n0].s;
-//              An[n0] = A[n0].n;
-//              At[n0] = A[n0].t;
-//              Ab[n0] = A[n0].b;
-//
-//              Ap[n1] = A[n1].p;
-//              Aw[n1] = A[n1].w;
-//              Ae[n1] = A[n1].e;
-//              As[n1] = A[n1].s;
-//              An[n1] = A[n1].n;
-//              At[n1] = A[n1].t;
-//              Ab[n1] = A[n1].b;
-// #endif
-//              return;
-//          }
-//          if ( bc_kind[face] == "Neumann" )
-//          {
-//              if ( !is_internal ( patch, n0, d, bc_kind ) ) // check if a dirichlet bc has already been imposed on n0
-//                  return;
-//              const double sgn ( patch->faceDirection ( face ) [d] );
-//              A[n0].p -= a;
-//              A[n0][face] = 0.;
-// #ifdef DBG_MATRIX
-//              Ap[n0] = A[n0].p;
-//              Aw[n0] = A[n0].w;
-//              Ae[n0] = A[n0].e;
-//              As[n0] = A[n0].s;
-//              An[n0] = A[n0].n;
-//              At[n0] = A[n0].t;
-//              Ab[n0] = A[n0].b;
-// #endif
-//              b[n0] -= a * sgn * h * bc_value[face];
-//              return;
-//          }
-//      }
-//  }
-//  default:
-//      return;
-//  }
-// }
diff --git a/src/CCA/Components/Heat/NCHeat3D.h b/src/CCA/Components/Heat/NCHeat3D.h
deleted file mode 100644
index 51fe9528..00000000
--- a/src/CCA/Components/Heat/NCHeat3D.h
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_NCHeat3D_h
-#define Packages_Uintah_CCA_Components_Heat_NCHeat3D_h
-
-#include <CCA/Components/Application/ApplicationCommon.h>
-
-#include <Core/Grid/BoundaryConditions/BCDataArray.h>
-#include <Core/Grid/BoundaryConditions/BoundCond.h>
-#include <Core/Grid/Ghost.h>
-#include <Core/Grid/Patch.h>
-#include <Core/Grid/SimpleMaterial.h>
-#include <Core/Grid/Task.h>
-#include <Core/Grid/Variables/BlockRange.hpp>
-#include <Core/Grid/Variables/NCVariable.h>
-#include <Core/Grid/Variables/VarLabel.h>
-#include <Core/Util/DebugStream.h>
-#include <CCA/Components/Heat/TimeScheme.h>
-#include <CCA/Ports/Scheduler.h>
-// #include <CCA/Ports/SolverInterface.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-#ifdef CUSTOM_OUT
-#   include <CCA/Components/Heat/visitfile.hpp>
-#   include <CCA/Ports/Output.h>
-#endif
-
-// #define DBG_MATRIX
-
-namespace Uintah
-{
-
-class NCHeat3D :
-    public ApplicationCommon
-{
-protected:
-    using ConstVariable = constNCVariable<double>;
-    using Variable = NCVariable<double>;
-//  using ConstMatrix = constNCVariable<Stencil7>;
-//  using Matrix = NCVariable<Stencil7>;
-#ifdef UINTAH_ENABLE_KOKKOS
-    using ConstVariableView = KokkosView3<double const>;
-    using VariableView = KokkosView3<double>;
-//  using MatrixView = KokkosView3<Stencil7>;
-#else
-    using ConstVariableView = ConstVariable & ;
-    using VariableView = Variable & ;
-//  using MatrixView = Matrix & ;
-#endif
-
-    static constexpr Patch::FaceType start_face = Patch::xminus;
-    static constexpr Patch::FaceType end_face = Patch::zplus;
-
-    static constexpr inline ConstVariableView get_view ( ConstVariable & var );
-    static constexpr inline VariableView get_view ( Variable & var );
-//  static constexpr inline MatrixView get_view ( Matrix & var );
-
-    static inline IntVector get_low ( Patch const * patch );
-    static inline IntVector get_high ( Patch const * patch );
-    static inline BlockRange get_range ( Patch const * patch );
-    static inline BlockRange get_inner_range ( Patch const * patch );
-    static inline BlockRange get_face_range ( Patch const * patch, Patch::FaceType face );
-    static inline void get_bc ( Patch const * patch, Patch::FaceType face, const int child, const std::string & desc, const int mat_id, BlockRange & range, std::string & bc_kind, double & bc_value );
-    static inline Point get_position ( Patch const * patch, IntVector const & i );
-    static inline bool is_internal ( const Patch * patch, const IntVector & i, int d, const std::string bc_kind[4] );
-
-    static inline double dx ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dy ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dz ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dxx ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dyy ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double dzz ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-    static inline double laplacian ( int i, int j, int k, Patch const * patch, ConstVariableView psi );
-
-protected:
-    double const tol = 1.e-6;
-
-    DebugStream dbg_out1, dbg_out2, dbg_out3, dbg_out4;
-
-    double delt, alpha, r0, gamma;
-    TimeScheme time_scheme;
-
-    const VarLabel * u_label;
-//  const VarLabel * matrix_label, * rhs_label;
-// #ifdef DBG_MATRIX
-// #define MATRIX_VIEW_A MatrixView A, VariableView Ap, VariableView Aw, VariableView Ae, VariableView As, VariableView An, VariableView Ab, VariableView At
-// #define REF_A &A, &Ap, &Aw, &Ae, &As, &An, &Ab, &At
-// #define GET_VIEW_A get_view ( A ), get_view ( Ap ), get_view ( Aw ), get_view ( Ae ), get_view ( As ), get_view ( An ), get_view ( Ab ), get_view ( At )
-//  const VarLabel * Ap_label, * Aw_label, * Ae_label, * As_label, * An_label, * Ab_label, * At_label;
-// #else
-// #define MATRIX_VIEW_A MatrixView A
-// #define REF_A &A
-// #define GET_VIEW_A get_view ( A )
-// #endif
-
-//  SolverInterface * solver;
-//  SolverParameters * solver_parameters;
-
-#ifdef CUSTOM_OUT
-    Output * dataArchiver;
-    std::map<int, VisitFile *> out_visit;
-#endif
-
-public:
-    NCHeat3D ( const ProcessorGroup * myworld,
-	       const MaterialManagerP materialManager,
-	       int verbosity = 0 );
-  
-    virtual ~NCHeat3D();
-
-protected:
-    NCHeat3D ( NCHeat3D const & ) = delete;
-    NCHeat3D & operator= ( NCHeat3D const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleInitialize ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleRestartInitialize ( LevelP const & /*level*/, SchedulerP & /*sched*/ ) override {}
-    virtual void scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-
-    void scheduleTimeAdvance_forward_euler ( LevelP const & level, SchedulerP & );
-//  void scheduleTimeAdvance_backward_euler_assemble ( LevelP const & level, SchedulerP & );
-//  void scheduleTimeAdvance_backward_euler_solve ( LevelP const & level, SchedulerP & );
-#ifdef CUSTOM_OUT
-    void scheduleTimeAdvance_save ( LevelP const & level, SchedulerP & );
-#endif
-
-    void task_initialize ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_compute_stable_timestep ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_farward_euler_time_advance ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_backward_euler_assemble ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-#ifdef CUSTOM_OUT
-    void task_save ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-#endif
-
-    void initialize ( int i, int j, int k, Patch const * patch, VariableView u );
-    void forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new );
-    void forward_euler_time_advance ( int i, int j, int k, Patch const * patch, ConstVariableView u_old, VariableView u_new, Patch::FaceType face, const std::string bc_kind[6], const double bc_value[6] );
-//  void backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b );
-//  void backward_euler_assemble ( int i, int j, int k, Patch const * patch, ConstVariableView u, MATRIX_VIEW_A, VariableView b, Patch::FaceType face, const std::string bc_kind[6], const double bc_value[6] );
-}; // class NCHeat3D
-
-} // namespace Uintah
-
-constexpr inline Uintah::NCHeat3D::ConstVariableView Uintah::NCHeat3D::get_view ( ConstVariable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-constexpr inline Uintah::NCHeat3D::VariableView Uintah::NCHeat3D::get_view ( Variable & var )
-{
-#ifdef UINTAH_ENABLE_KOKKOS
-    return var.getKokkosView();
-#else
-    return var;
-#endif
-}
-
-// constexpr inline Uintah::NCHeat3D::MatrixView Uintah::NCHeat3D::get_view ( Matrix & var )
-// {
-// #ifdef UINTAH_ENABLE_KOKKOS
-//  return var.getKokkosView();
-// #else
-//  return var;
-// #endif
-// }
-
-inline Uintah::Point Uintah::NCHeat3D::get_position ( Patch const * patch, IntVector const & i )
-{
-    return patch->getNodePosition ( i );
-}
-
-inline Uintah::IntVector Uintah::NCHeat3D::get_low ( Patch const * patch )
-{
-    return patch->getNodeLowIndex();
-}
-
-inline Uintah::IntVector Uintah::NCHeat3D::get_high ( Patch const * patch )
-{
-    return patch->getNodeHighIndex();
-}
-
-inline Uintah::BlockRange Uintah::NCHeat3D::get_range ( Patch const * patch )
-{
-    return { get_low ( patch ), get_high ( patch ) };
-}
-
-inline Uintah::BlockRange Uintah::NCHeat3D::get_inner_range ( Patch const * patch )
-{
-    return { get_low ( patch ) + IntVector (
-                 patch->getBCType ( Patch::xminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::zminus ) == Patch::Neighbor ? 0 : 1
-             ),
-             get_high ( patch ) - IntVector (
-                 patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::zplus ) == Patch::Neighbor ? 0 : 1
-             )
-           };
-}
-
-inline Uintah::BlockRange Uintah::NCHeat3D::get_face_range ( Patch const * patch, Patch::FaceType face )
-{
-    IntVector l, h;
-    patch->getFaceNodes ( face, 0, l, h );
-    return { l, h };
-}
-
-inline void Uintah::NCHeat3D::get_bc ( const Patch * patch, Patch::FaceType face, const int child, const std::string & desc, const int mat_id, BlockRange & range, std::string & bc_kind, double & bc_value )
-{
-    range = get_face_range ( patch, face );
-    bc_kind = "NotSet";
-    bc_value = 0.;
-
-    if ( desc == "zeroNeumann" )
-    {
-        bc_kind = "zeroNeumann";
-        return;
-    }
-
-    if ( patch->getBCType ( face ) == Patch::Coarse )
-    {
-        bc_kind = "FineCoarseInterface";
-        return;
-    }
-
-    if ( patch->getBCType ( face ) == Patch::Neighbor )
-    {
-        bc_kind = "Neighbor";
-        return;
-    }
-
-    const BCDataArray * bcd = patch->getBCDataArray ( face );
-    if ( !bcd ) return;
-
-    const BoundCondBase * bc;
-    if ( ( bc = bcd->getBoundCondData ( mat_id, desc, child ) ) )
-    {
-        const BoundCond<double> * bcs = dynamic_cast<const BoundCond<double> *> ( bc );;
-        if ( bcs )
-        {
-            bc_kind  = bcs->getBCType();
-            bc_value = bcs->getValue();
-        }
-    }
-    else if ( ( bc = bcd->getBoundCondData ( mat_id, "Symmetric", child ) ) )
-    {
-        if ( bc->getBCType() == "symmetry" ) bc_kind  = "symmetry";
-    }
-    if ( bc ) delete bc;
-    return;
-}
-
-bool Uintah::NCHeat3D::is_internal ( const Patch * patch, const IntVector & i, int d, const std::string bc_kind[4] )
-{
-    IntVector l = get_low ( patch );
-    IntVector h = get_high ( patch ) - IntVector ( 1, 1, 1 );
-
-    for ( int k = 0; k < d; ++k )
-    {
-        if ( bc_kind[2 * k] == "Dirichlet" && i[k] <= l[k] ) return false;
-        if ( bc_kind[2 * k + 1] == "Dirichlet" && i[k] >= h[k] ) return false;
-    }
-    return true;
-}
-
-inline double Uintah::NCHeat3D::dx ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) - psi ( i - 1, j, k ) ) / ( 2. * d.x() );
-}
-
-inline double Uintah::NCHeat3D::dy ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) - psi ( i, j - 1, k ) ) / ( 2. * d.y() );
-}
-
-inline double Uintah::NCHeat3D::dz ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j, k + 1 ) - psi ( i, j, k - 1 ) ) / ( 2. * d.z() );
-}
-
-inline double Uintah::NCHeat3D::dxx ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) + psi ( i - 1, j, k ) - 2. * psi ( i, j, k ) ) / ( d.x() * d.x() );
-}
-
-inline double Uintah::NCHeat3D::dyy ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) + psi ( i, j - 1, k ) - 2. * psi ( i, j, k ) ) / ( d.y() * d.y() );
-}
-
-inline double Uintah::NCHeat3D::dzz ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j, k + 1 ) + psi ( i, j, k - 1 ) - 2. * psi ( i, j, k ) ) / ( d.z() * d.z() );
-}
-
-inline double Uintah::NCHeat3D::laplacian ( int i, int j, int k, Patch const * patch, ConstVariableView psi )
-{
-    return dxx ( i, j, k, patch, psi ) + dyy ( i, j, k, patch, psi ) + dzz ( i, j, k, patch, psi );
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_NCHeat3D_h
-
-
-
-
-
diff --git a/src/CCA/Components/Heat/TimeScheme.h b/src/CCA/Components/Heat/TimeScheme.h
deleted file mode 100644
index 395a1c53..00000000
--- a/src/CCA/Components/Heat/TimeScheme.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_TimeScheme_h
-#define Packages_Uintah_CCA_Components_Heat_TimeScheme_h
-
-namespace Uintah
-{
-
-enum TimeScheme : unsigned
-{
-    Unknown       = 0x00000000,
-
-    Explicit      = 0x01000000,
-    ForwardEuler  = 0x01000001,
-
-    Implicit      = 0x02000000,
-    BackwardEuler = 0x02000001,
-    CrankNicolson = 0x02000002
-
-}; // enum TimeScheme
-
-inline TimeScheme from_str ( const std::string & value );
-
-} // namespace Uintah
-
-inline Uintah::TimeScheme Uintah::from_str ( const std::string & value )
-{
-    if ( value == "forward_euler" ) return TimeScheme::ForwardEuler;
-    if ( value == "backward_euler" ) return TimeScheme::BackwardEuler;
-    if ( value == "crank_nicolson" ) return TimeScheme::CrankNicolson;
-    return TimeScheme::Unknown;
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_TimeScheme_h
diff --git a/src/CCA/Components/Heat/pvtkfile.hpp b/src/CCA/Components/Heat/pvtkfile.hpp
deleted file mode 100644
index 7f414eb2..00000000
--- a/src/CCA/Components/Heat/pvtkfile.hpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_pvtkfile_hpp
-#define Packages_Uintah_CCA_Components_Heat_pvtkfile_hpp
-
-#include <string>
-#include <fstream>
-
-#include <boost/property_tree/xml_parser.hpp>
-
-namespace Uintah
-{
-
-class PVtkFile
-{
-    const std::string _path;
-    const std::string _name;
-    boost::property_tree::ptree _tree;
-
-    PVtkFile ( const PVtkFile & other ) = delete;
-    PVtkFile & operator= ( const PVtkFile & other ) = delete;
-    bool operator== ( const PVtkFile & other ) const = delete;
-
-public:
-    inline PVtkFile ( const std::string & path, const std::string & name, double time );
-    ~PVtkFile() = default;
-
-    inline void add ( const std::string & filename );
-    inline void add_time ( double time );
-    inline void save ();
-    inline std::string file_name ();
-};
-
-}
-
-Uintah::PVtkFile::PVtkFile ( const std::string & path, const std::string & name, double time )
-    : _path ( path ),
-      _name ( name + ".pvti" )
-{
-    std::ifstream in ( _path + "/" + _name );
-    bool exists = in.good();
-    in.close();
-    if ( exists )
-    {
-        boost::property_tree::read_xml ( _path + "/" + _name, _tree, boost::property_tree::xml_parser::trim_whitespace );
-    }
-    else
-    {
-        _tree.add ( "VTKFile.<xmlattr>.type","PImageData" );
-        _tree.add ( "VTKFile.<xmlattr>.version","0.1" );
-        add_time ( time );
-    }
-}
-
-void Uintah::PVtkFile::add ( const std::string & filename )
-{
-    boost::property_tree::ptree child;
-    child.add ( "<xmlattr>.Source",filename );
-    _tree.add_child ( "VTKFile.PImageData.Piece", child );
-}
-
-void Uintah::PVtkFile::add_time(double time)
-{
-    boost::property_tree::ptree child;
-    child.add ( "DataArray", time );
-    child.add ( "DataArray.<xmlattr>.type","Float64" );
-    child.add ( "DataArray.<xmlattr>.Name","TIME" );
-    child.add ( "DataArray.<xmlattr>.NumberOfTuples","1" );
-    child.add ( "DataArray.<xmlattr>.format","ascii");
-    _tree.add_child ( "VTKFile.PImageData.FieldData", child );
-}
-
-void Uintah::PVtkFile::save ()
-{
-    boost::property_tree::xml_writer_settings<std::string> settings ( ' ', 4 );
-    boost::property_tree::write_xml ( _path + "/" + _name, _tree, std::locale(), settings );
-}
-
-std::string Uintah::PVtkFile::file_name()
-{
-    return _name;
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_pvtkfile_hpp
diff --git a/src/CCA/Components/Heat/sub.mk b/src/CCA/Components/Heat/sub.mk
deleted file mode 100644
index 19114976..00000000
--- a/src/CCA/Components/Heat/sub.mk
+++ /dev/null
@@ -1,99 +0,0 @@
-#
-#  The MIT License
-#
-#  Copyright (c) 1997-2018 The University of Utah
-# 
-#  Permission is hereby granted, free of charge, to any person obtaining a copy
-#  of this software and associated documentation files (the "Software"), to
-#  deal in the Software without restriction, including without limitation the
-#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-#  sell copies of the Software, and to permit persons to whom the Software is
-#  furnished to do so, subject to the following conditions:
-# 
-#  The above copyright notice and this permission notice shall be included in
-#  all copies or substantial portions of the Software.
-# 
-#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-#  IN THE SOFTWARE.
-# 
-# 
-# 
-# 
-# 
-# Makefile fragment for this subdirectory /
-
-include $(SCIRUN_SCRIPTS)/smallso_prologue.mk
-
-SRCDIR := CCA/Components/Heat
-
-SRCS +=                            \
-         $(SRCDIR)/CCHeat2D.cc     \
-         $(SRCDIR)/NCHeat2D.cc     \
-         $(SRCDIR)/CCHeat3D.cc     \
-         $(SRCDIR)/NCHeat3D.cc     \
-         $(SRCDIR)/AMRCCHeat2D.cc  \
-         $(SRCDIR)/AMRNCHeat2D.cc  \
-         $(SRCDIR)/AMRCCHeat3D.cc  \
-         $(SRCDIR)/AMRNCHeat3D.cc  \
-
-VTK_SRCS :=                        \
-         $(SRCDIR)/vtkfile.cpp     \
-
-PSELIBS :=                         \
-        CCA/Components/Application \
-        CCA/Components/Schedulers \
-        CCA/Ports                 \
-        Core/Disclosure           \
-        Core/Exceptions           \
-        Core/Geometry             \
-        Core/GeometryPiece        \
-        Core/Grid                 \
-        Core/IO                   \
-        Core/Math                 \
-        Core/Parallel             \
-        Core/ProblemSpec          \
-        Core/Util
-
-LIBS :=                                                              \
-         $(Z_LIBRARY) $(XML2_LIBRARY) $(MPI_LIBRARY) $(M_LIBRARY)    \
-#        $(EXPRLIB_LIBRARY) $(SPATIALOPS_LIBRARY)                    \
-#        $(RADPROPS_LIBRARY) $(TABPROPS_LIBRARY)                     \
-#        $(NSCBC_LIBRARY)                                            \
-#        $(POKITT_LIBRARY)                                           \
-#        $(BOOST_LIBRARY) $(LAPACK_LIBRARY) $(BLAS_LIBRARY)
-
-VTK_LIBS :=                                                          \
-         -L/home/jonmatteo/Developer/vtk/6.1.0/lib                   \
-         -Wl,-rpath,/home/jonmatteo/Developer/vtk/6.1.0/lib          \
-         -lvtksys-6.1 -lvtkzlib-6.1 -lvtkjsoncpp-6.1 -lvtkexpat-6.1  \
-         -lvtkCommonCore-6.1 -lvtkCommonExecutionModel-6.1           \
-         -lvtkCommonDataModel-6.1 -lvtkCommonMisc-6.1                \
-         -lvtkCommonSystem-6.1 -lvtkCommonTransforms-6.1             \
-         -lvtkCommonMath-6.1 -lvtkIOCore-6.1 -lvtkIOGeometry-6.1     \
-         -lvtkIOXMLParser-6.1 -lvtkIOXML-6.1                         \
-#        -lvtkpng-6.1 -lvtktiff-6.1 -lvtkmetaio-6.1                  \
-#        -lvtkDICOMParser-6.1 -lvtkjpeg-6.1 -lvtkIOImage-6.1         \
-#        -lvtkexpat-6.1                                              \
-
-INCLUDES :=                                                          \
-         $(INCLUDES)                                                 \
-#        $(SPATIALOPS_INCLUDE) $(EXPRLIB_INCLUDE)                    \
-#        $(TABPROPS_INCLUDE) $(RADPROPS_INCLUDE) $(NSCBC_INCLUDE)    \
-#        $(POKITT_INCLUDE) $(BOOST_INCLUDE) $(LAPACK_INCLUDE)        \
-
-VTK_INCLUDES :=                                                      \
-         -I/home/jonmatteo/Developer/vtk/6.1.0/include/vtk-6.1       \
-
-ifeq ($(HAVE_HEAD_VTK),yes)
-   SRCS += $(VTK_SRCS)
-   LIBS += $(VTK_LIBS)
-   INCLUDES += $(VTK_INCLUDES)
-endif
-
-include $(SCIRUN_SCRIPTS)/smallso_epilogue.mk
-
diff --git a/src/CCA/Components/Heat/visitfile.hpp b/src/CCA/Components/Heat/visitfile.hpp
deleted file mode 100644
index 17442c37..00000000
--- a/src/CCA/Components/Heat/visitfile.hpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_visitfile_hpp
-#define Packages_Uintah_CCA_Components_Heat_visitfile_hpp
-
-#include <string>
-#include <fstream>
-#include <set>
-
-namespace Uintah
-{
-
-class VisitFile
-{
-    const std::string _path;
-    const std::string _name;
-    std::set<std::string> _set;
-
-    VisitFile ( const VisitFile & other ) = delete;
-    VisitFile & operator= ( const VisitFile & other ) = delete;
-    bool operator== ( const VisitFile & other ) const = delete;
-
-public:
-    inline VisitFile ( const std::string & path, const std::string & name, const bool & append );
-    ~VisitFile() = default;
-
-    inline void add ( const std::string & filename );
-};
-
-}
-
-Uintah::VisitFile::VisitFile ( const std::string & path, const std::string & name, const bool & append )
-    : _path ( path ),
-      _name ( name )
-{
-    std::ofstream out;
-    out.open ( _path + "/" + _name + ".visit", append ? std::ios_base::app : std::ios_base::trunc );
-    out.close();
-}
-
-void Uintah::VisitFile::add ( const std::string & filename )
-{
-    auto ret = _set.insert ( filename );
-    if ( ret.second )
-    {
-        std::ofstream out;
-        out.open ( _path + "/" + _name + ".visit", std::ios_base::app );
-        out << filename << std::endl;
-        out.close();
-    }
-}
-
-#endif // Packages_Uintah_CCA_Components_Heat_visitfile_hpp
diff --git a/src/CCA/Components/Heat/vtkfile.cpp b/src/CCA/Components/Heat/vtkfile.cpp
deleted file mode 100644
index 1769f3a5..00000000
--- a/src/CCA/Components/Heat/vtkfile.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include "vtkfile.hpp"
-
-#include <vtkSmartPointer.h>
-#include <vtkDataArray.h>
-#include <vtkDoubleArray.h>
-#include <vtkImageData.h>
-#include <vtkPointData.h>
-#include <vtkCellData.h>
-#include <vtkXMLImageDataWriter.h>
-
-Uintah::VtkFile::~VtkFile()
-{
-    if ( _grid )
-    {
-        _grid->Delete();
-    }
-}
-
-void Uintah::VtkFile::set_grid ( const double & hx, const double & hy, const double & hz, const int & Nx, const int & Ny, const int & Nz, const double & x0, const double & y0, const double & z0 )
-{
-    if ( _grid )
-    {
-        _grid->Delete();
-    }
-    _grid = vtkImageData::New();
-    _grid->SetSpacing ( hx, hy, hz );
-    _grid->SetDimensions ( Nx, Ny, Nz );
-    _grid->SetOrigin ( x0, y0, z0 );
-}
-
-void Uintah::VtkFile::add_time ( const double & time )
-{
-    vtkSmartPointer<vtkDoubleArray> array = vtkSmartPointer<vtkDoubleArray>::New();
-    array->SetName ( "TIME" );
-    array->SetNumberOfTuples ( 1 );
-    array->SetTuple1 ( 0, time );
-    _grid->GetFieldData()->AddArray ( array );
-}
-
-void Uintah::VtkFile::add_node_data ( const std::string & name, const constNCVariable<double> & var, const IntVector & low, const IntVector & high )
-{
-    const unsigned & n = _grid->GetNumberOfPoints();
-    vtkSmartPointer< vtkDoubleArray> array = vtkSmartPointer<vtkDoubleArray>::New();
-
-    double * tmp = new double[n];
-    int l = 0;
-    serial_for ( BlockRange ( low, high ), [&tmp, &var, &l] ( int i, int j, int k )->void { tmp[l++] = ( var ) ( i, j, k ); } );
-    array->SetNumberOfComponents ( 1 );
-    array->SetNumberOfTuples ( n );
-    array->SetArray ( tmp, n, 0, 1 );
-    array->SetName ( name.c_str() );
-    _grid->GetPointData()->AddArray ( array );
-}
-
-void Uintah::VtkFile::add_cell_data ( const std::string & name, const constCCVariable<double> & var, const IntVector & low, const IntVector & high )
-{
-    unsigned n = _grid->GetNumberOfPoints() - 1;
-    vtkSmartPointer< vtkDoubleArray> array = vtkSmartPointer<vtkDoubleArray>::New();
-
-    double * tmp = new double[n];
-    int l = 0;
-    serial_for ( BlockRange ( low, high ), [&tmp, &var, &l] ( int i, int j, int k )->void { tmp[l++] = ( var ) ( i, j, k ); } );
-    array->SetNumberOfComponents ( 1 );
-    array->SetNumberOfTuples ( n );
-    array->SetArray ( tmp, n, 0, 1 );
-    array->SetName ( name.c_str() );
-    _grid->GetCellData()->AddArray ( array );
-}
-
-void Uintah::VtkFile::add_cell_data ( const std::string & name, const constCCVariable<int> & var, const IntVector & low, const IntVector & high )
-{
-    unsigned n = _grid->GetNumberOfPoints() - 1;
-    vtkSmartPointer< vtkDoubleArray> array = vtkSmartPointer<vtkDoubleArray>::New();
-
-    double * tmp = new double[n];
-    int l = 0;
-    serial_for ( BlockRange ( low, high ), [&tmp, &var, &l] ( int i, int j, int k )->void { tmp[l++] = ( var ) ( i, j, k ); } );
-    array->SetNumberOfComponents ( 1 );
-    array->SetNumberOfTuples ( n );
-    array->SetArray ( tmp, n, 0, 1 );
-    array->SetName ( name.c_str() );
-    _grid->GetCellData()->AddArray ( array );
-}
-
-void Uintah::VtkFile::save()
-{
-    vtkXMLImageDataWriter * writer = vtkXMLImageDataWriter::New();
-    writer->SetFileName ( std::string ( _path + "/" + _name ).c_str() );
-    writer->SetInputData ( _grid );
-    writer->Write();
-    writer->Delete();
-}
-
diff --git a/src/CCA/Components/Heat/vtkfile.hpp b/src/CCA/Components/Heat/vtkfile.hpp
deleted file mode 100644
index 5efca184..00000000
--- a/src/CCA/Components/Heat/vtkfile.hpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_Heat_vtkfile_hpp
-#define Packages_Uintah_CCA_Components_Heat_vtkfile_hpp
-
-#include <iomanip>
-#include <fstream>
-#include <sstream>
-
-#include <vtkSmartPointer.h>
-#include <Core/Grid/Variables/CCVariable.h>
-#include <Core/Grid/Variables/NCVariable.h>
-
-#define ID_WIDTH 5
-
-class vtkImageData;
-
-namespace Uintah
-{
-
-class VtkFile
-{
-    const std::string _path;
-    std::string _name;
-    vtkSmartPointer<vtkImageData> _grid;
-
-    VtkFile ( const VtkFile & other ) = delete;
-    VtkFile & operator= ( const VtkFile & other ) = delete;
-    bool operator== ( const VtkFile & other ) const = delete;
-
-public:
-    inline VtkFile ( const std::string & path, const unsigned & id );
-    ~VtkFile();
-
-    inline bool exists();
-
-    inline std::string file_name();
-//     inline std::string rel_path();
-
-    void set_grid ( const double & hx, const double & hy, const double & hz, const int & Nx, const int & Ny, const int & Nz, const double & x0, const double & y0, const double & z0 );
-    void add_time ( const double & time );
-    void add_node_data ( const std::string & name, const constNCVariable<double> & var, const IntVector & low, const IntVector & high );
-    void add_cell_data ( const std::string & name, const constCCVariable<int> & var, const IntVector & low, const IntVector & high );
-    void add_cell_data ( const std::string & name, const constCCVariable<double> & var, const IntVector & low, const IntVector & high );
-    void save();
-};
-
-}
-
-Uintah::VtkFile::VtkFile ( const std::string & path, const unsigned & id )
-    : _path ( path ),
-      _grid ( )
-{
-    std::stringstream stream;
-    stream << "p" << std::setw ( ID_WIDTH ) << std::setfill ( '0' ) << id << ".vti";
-    _name = stream.str();
-}
-
-bool Uintah::VtkFile::exists()
-{
-//     std::string filepath = ;
-    std::ifstream file ( _path + "/" + _name );
-    return file.good();
-}
-
-std::string Uintah::VtkFile::file_name()
-{
-    return _name;
-}
-
-// std::string Uintah::VtkFile::abs_path()
-// {
-//     return _path + "/" + _data + "/" + _name;
-// }
-// 
-// std::string Uintah::VtkFile::rel_path()
-// {
-//     return _data + "/" + _name;
-// }
-
-#endif // Packages_Uintah_CCA_Components_Heat_vtkfile_hpp
-
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDView-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDView-bld.sh
index edddd908..d378d8f2 100755
--- a/src/CCA/Components/PhaseField/AMR/AMRFDView-bld.sh
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDView-bld.sh
@@ -27,12 +27,12 @@ VARs=(CC NC)
 STNs=(P5 P7)
 DIMs=(2 3)
 PPPs=(
-  "PureMetalProblem"
-  "PureMetalProblem"
+  "PureMetalProblem;HeatProblem"
+  "PureMetalProblem;HeatProblem"
 )
 NFFs=(
-  "4"
-  "4"
+  "4;1"
+  "4;1"
 )
 DIRs=(x y z)
 SIGNs=(minus plus)
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC0-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC0-bld.sh
new file mode 100755
index 00000000..6ed0ff62
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC0-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P5 -c FC0
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC0New-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC0New-bld.sh
new file mode 100755
index 00000000..c447b8c0
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC0New-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P5 -c FC0New
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC1-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC1-bld.sh
new file mode 100755
index 00000000..d06719a0
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC1-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P5 -c FC1
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC1New-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC1New-bld.sh
new file mode 100755
index 00000000..1ca0620b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FC1New-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P5 -c FC1New
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCBilinear-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCBilinear-bld.sh
new file mode 100755
index 00000000..0de90df1
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCBilinear-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P5 -c FCBilinear
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCLinear-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCLinear-bld.sh
new file mode 100755
index 00000000..549395cb
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCLinear-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P5 -c FCLinear
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCSimple-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCSimple-bld.sh
new file mode 100755
index 00000000..0d0f8c4d
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP5FCSimple-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P5 -c FCSimple
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC0-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC0-bld.sh
new file mode 100755
index 00000000..f7665a85
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC0-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P7 -c FC0
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC0New-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC0New-bld.sh
new file mode 100755
index 00000000..70b23bff
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC0New-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P7 -c FC0New
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC1-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC1-bld.sh
new file mode 100755
index 00000000..ab01de1d
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC1-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P7 -c FC1
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC1New-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC1New-bld.sh
new file mode 100755
index 00000000..28848fd5
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemCCP7FC1New-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P7 -c FC1New
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FC0-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FC0-bld.sh
new file mode 100755
index 00000000..64e36801
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FC0-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P5 -c FC0
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FC1-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FC1-bld.sh
new file mode 100755
index 00000000..a8a8602c
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FC1-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P5 -c FC1
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCBilinear-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCBilinear-bld.sh
new file mode 100755
index 00000000..2b2623cb
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCBilinear-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P5 -c FCBilinear
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCLinear-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCLinear-bld.sh
new file mode 100755
index 00000000..5af6ee6a
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCLinear-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P5 -c FCLinear
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCSimple-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCSimple-bld.sh
new file mode 100755
index 00000000..a26806b7
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP5FCSimple-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P5 -c FCSimple
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP7FC0-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP7FC0-bld.sh
new file mode 100755
index 00000000..e2823291
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP7FC0-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P7 -c FC0
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP7FC1-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP7FC1-bld.sh
new file mode 100755
index 00000000..0a2ef9a5
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewHeatProblemNCP7FC1-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P7 -c FC1
diff --git a/src/CCA/Components/PhaseField/AMR/sub.mk b/src/CCA/Components/PhaseField/AMR/sub.mk
index 2d3ac2b9..e88a7ec4 100644
--- a/src/CCA/Components/PhaseField/AMR/sub.mk
+++ b/src/CCA/Components/PhaseField/AMR/sub.mk
@@ -30,6 +30,20 @@
 SRCDIR := CCA/Components/PhaseField/AMR
 
 SRCS += \
+  $(SRCDIR)/AMRFDViewHeatProblemCCP5FC0-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemCCP5FC1-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemCCP5FCSimple-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemCCP5FCLinear-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemCCP5FCBilinear-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemCCP7FC0-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemCCP7FC1-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemNCP5FC0-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemNCP5FC1-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemNCP5FCSimple-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemNCP5FCLinear-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemNCP5FCBilinear-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemNCP7FC0-bld.cc \
+  $(SRCDIR)/AMRFDViewHeatProblemNCP7FC1-bld.cc \
   $(SRCDIR)/AMRFDViewPureMetalProblemCCP5FC0-bld.cc \
   $(SRCDIR)/AMRFDViewPureMetalProblemCCP5FC1-bld.cc \
   $(SRCDIR)/AMRFDViewPureMetalProblemCCP5FCSimple-bld.cc \
@@ -48,6 +62,20 @@ SRCS += \
 BLDDIR := $(SRCTOP)/$(SRCDIR)
 
 BLDSRCS += \
+  $(BLDDIR)/AMRFDViewHeatProblemCCP5FC0-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemCCP5FC1-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemCCP5FCSimple-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemCCP5FCLinear-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemCCP5FCBilinear-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemCCP7FC0-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemCCP7FC1-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemNCP5FC0-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemNCP5FC1-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemNCP5FCSimple-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemNCP5FCLinear-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemNCP5FCBilinear-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemNCP7FC0-bld.cc \
+  $(BLDDIR)/AMRFDViewHeatProblemNCP7FC1-bld.cc \
   $(BLDDIR)/AMRFDViewPureMetalProblemCCP5FC0-bld.cc \
   $(BLDDIR)/AMRFDViewPureMetalProblemCCP5FC1-bld.cc \
   $(BLDDIR)/AMRFDViewPureMetalProblemCCP5FCSimple-bld.cc \
diff --git a/src/CCA/Components/PhaseField/Applications/Heat.cc b/src/CCA/Components/PhaseField/Applications/Heat.cc
new file mode 100644
index 00000000..9c890319
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Applications/Heat.cc
@@ -0,0 +1,67 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Applications/Heat.cc
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ *
+ * In this the names used by ApplicationFactory for the differnt implementations
+ * of the Heat application are defined as well as their explicit instantiation.
+ */
+
+#include <CCA/Components/PhaseField/Applications/Heat.h>
+
+namespace Uintah {
+namespace PhaseField {
+
+#ifndef _DOXY_IGNORE_
+template<> const std::string HeatProblem<CC, P5>::Name = "HeatProblem";
+template<> const std::string HeatProblem<NC, P5>::Name = "HeatProblem";
+template<> const std::string HeatProblem<CC, P7>::Name = "HeatProblem";
+template<> const std::string HeatProblem<NC, P7>::Name = "HeatProblem";
+
+template<> const std::string Heat<CC,D2,P5>::Name = "heat|cc|d2|p5";
+template<> const std::string Heat<NC,D2,P5>::Name = "heat|nc|d2|p5";
+template<> const std::string Heat<CC,D3,P7>::Name = "heat|cc|d3|p7";
+template<> const std::string Heat<NC,D3,P7>::Name = "heat|nc|d3|p7";
+
+template<> const std::string Heat<CC,D2,P5,AMR>::Name = "amr|heat|cc|d2|p5";
+template<> const std::string Heat<NC,D2,P5,AMR>::Name = "amr|heat|nc|d2|p5";
+template<> const std::string Heat<CC,D3,P7,AMR>::Name = "amr|heat|cc|d3|p7";
+template<> const std::string Heat<NC,D3,P7,AMR>::Name = "amr|heat|nc|d3|p7";
+
+template class Heat<CC,D2,P5>;
+template class Heat<NC,D2,P5>;
+template class Heat<CC,D3,P7>;
+template class Heat<NC,D3,P7>;
+
+template class Heat<CC,D2,P5,AMR>;
+template class Heat<NC,D2,P5,AMR>;
+template class Heat<CC,D3,P7,AMR>;
+template class Heat<NC,D3,P7,AMR>;
+#endif
+
+} // namespace Uintah
+} // namespace PhaseField
diff --git a/src/CCA/Components/PhaseField/Applications/Heat.h b/src/CCA/Components/PhaseField/Applications/Heat.h
new file mode 100644
index 00000000..0e183c13
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Applications/Heat.h
@@ -0,0 +1,2427 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Applications/Heat.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Applications_Heat_h
+#define Packages_Uintah_CCA_Components_PhaseField_Applications_Heat_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/Util/Expressions.h>
+#include <CCA/Components/PhaseField/Util/BlockRangeIO.h>
+#include <CCA/Components/PhaseField/DataTypes/HeatProblem.h>
+#include <CCA/Components/PhaseField/DataTypes/SubProblemsP.h>
+#include <CCA/Components/PhaseField/DataTypes/SubProblems.h> // must be included after SubProblemsP where swapbyte soverride is defined
+#include <CCA/Components/PhaseField/DataTypes/Variable.h>
+#include <CCA/Components/PhaseField/DataTypes/ScalarField.h>
+#include <CCA/Components/PhaseField/DataTypes/VectorField.h>
+#include <CCA/Components/PhaseField/Applications/Application.h>
+#include <CCA/Components/PhaseField/Factory/Implementation.h>
+#include <CCA/Components/PhaseField/Views/View.h>
+#include <CCA/Components/PhaseField/Views/FDView.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWView.h>
+#include <CCA/Components/PhaseField/AMR/AMRInterpolator.h>
+#include <CCA/Components/PhaseField/AMR/AMRRestrictor.h>
+
+#include <Core/Util/DebugStream.h>
+#include <Core/Grid/SimpleMaterial.h>
+#include <Core/Grid/Variables/PerPatchVars.h>
+#include <Core/Parallel/UintahParallelComponent.h>
+#include <CCA/Ports/Regridder.h>
+
+#define PhaseField_Heat_DBG_MATRIX 0
+#define PhaseField_Heat_DBG_DERIVATIVES 0
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/// Debugging stream for component schedulings
+static DebugStream cout_heat_scheduling ( "HEAT SCHEDULING", false );
+
+/**
+ * @brief Heat PhaseField applications
+ *
+ * Implements a Finite Difference solver for the simulation of the heat
+ * diffusion model
+ * \f[
+ * \dot u = \alpha \nabla^2 u
+ * \f]
+ * with initial data
+ * \f[
+ * u_{|t=0} = \prod_{d} \cos ( \alpha x_d );
+ * \f]
+ * where \f$d\f$ ranges over the problem dimension.
+ *
+ * The model parameters are:
+ * - \f$ \alpha \f$   thermal diffusivity
+ *
+ * @todo templetize FAC/nonFAC
+ * @todo check for more than 2 amr levels
+ *
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimensions
+ * @tparam STN finite-difference stencil
+ * @tparam AMR whether to use adaptive mesh refinement
+ */
+template<VarType VAR, DimType DIM, StnType STN, bool AMR = false>
+class Heat
+    : public Application<VAR, DIM, STN, AMR>
+    , public Implementation<Heat<VAR, DIM, STN, AMR>, UintahParallelComponent, const ProcessorGroup *, const MaterialManagerP, int>
+{
+private: // STATIC MEMBERS
+
+    /// Index for solution
+    static constexpr size_t U = 0;
+
+    /// Number of ghost elements required by STN (on the same level)
+    static constexpr int FGN = get_stn<STN>::ghosts;
+
+    /// Type of ghost elements required by VAR and STN (on coarser level)
+    static constexpr Ghost::GhostType FGT = FGN ? get_var<VAR>::ghost_type : Ghost::None;
+
+    /// Number of ghost elements required by STN (on coarser level)
+    /// @remark this should depend on FCI bc type but if fixed for simplicity
+    static constexpr int CGN = 1;
+
+    /// Type of ghost elements required by VAR and STN (on the same level)
+    static constexpr Ghost::GhostType CGT = CGN ? get_var<VAR>::ghost_type : Ghost::None;
+
+    /// Problem material index (only one SimpleMaterial)
+    static constexpr int material = 0;
+
+    /// Interpolation type for refinement
+    static constexpr FCIType C2F = ( VAR == CC ) ? I0 : I1; // TODO make template parameter
+
+    /// Restriction type for coarsening
+    static constexpr FCIType F2C = ( VAR == CC ) ? I1 : I0; // TODO make template parameter
+
+public: // STATIC MEMBERS
+
+    /// Class name as used by ApplicationFactory
+    static const std::string Name;
+
+protected: // MEMBERS
+
+    /// Output streams for debugging
+    DebugStream dbg_out1, dbg_out2, dbg_out3, dbg_out4;
+
+    // Labels for variables to be stored into the DataWarehouse
+    const VarLabel * u_label, * delta_u_label, * error_u_label;
+    const VarLabel * u_normL2_label, * error_normL2_label;
+    const VarLabel * subproblems_label;
+
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+    std::array<const VarLabel *, DIM> du_label, error_du_label;
+    std::array<const VarLabel *, DIM> ddu_label, error_ddu_label;
+    const VarLabel * u_normH10_label, * error_normH10_label;
+    const VarLabel * u_normH20_label, * error_normH20_label;
+#endif
+
+    /// Wether to perform comparisons with analytical solution
+    bool test;
+
+    /// Time step size
+    double delt;
+
+    /// Non-dimensional thermal diffusivity
+    double alpha;
+
+    /// Threshold for AMR
+    double refine_threshold;
+
+    /// Store which fine/coarse interface conditions to use on each variable
+    std::map<std::string, FC> c2f;
+
+    /// Flag for avoiding multiple reinitialization of subproblems after regridding
+    bool is_first_schedule_refine;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Intantiate an Heat application
+     *
+     * @param myWorld data structure to manage mpi processes
+     * @param materialManager data structure to manage materials
+     * @param verbosity constrols amount of debugging output
+     */
+    Heat (
+        const ProcessorGroup * myWorld,
+        const MaterialManagerP materialManager,
+        int verbosity = 0
+    );
+
+    /**
+     * @brief Destructor
+     */
+    virtual ~Heat();
+
+    /// Prevent copy (and move) constructor
+    Heat ( Heat const & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    Heat & operator= ( Heat const & ) = delete;
+
+protected: // SETUP
+
+    /**
+     * @brief Setup
+     *
+     * Initialize problem parameters with values from problem specifications
+     *
+     * @param params problem specifications parsed from input file
+     * @param restart_prob_spec unused
+     * @param grid unused
+     */
+    virtual void
+    problemSetup (
+        const ProblemSpecP & params,
+        const ProblemSpecP & restart_prob_spec,
+        GridP & grid
+    ) override;
+
+protected: // SCHEDULINGS
+
+    /**
+     * @brief Schedule the initialization tasks
+     *
+     * Specify all tasks to be performed at initial timestep to initialize
+     * variables in the DataWarehouse
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleInitialize (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_initialize_subproblems (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleInitialize_subproblems (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_initialize_subproblems (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleInitialize_subproblems (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_initialize_solution (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleInitialize_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_initialize_solution (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleInitialize_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the initialization tasks for restarting a simulation
+     *
+     * Specify all tasks to be performed at fist timestep after a stop to
+     * initialize not saved variables to the DataWarehouse
+     *
+     * @remark only subproblems need to be reinitialized all other variables
+     * should be retrieved from saved checkpoints
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleRestartInitialize (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_compute_stable_timestep
+     *
+     * Specify all tasks to be performed before each time advance to compute a
+     * timestep size which ensures numerical stability
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleComputeStableTimeStep (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule the time advance tasks
+     *
+     * Specify all tasks to be performed at each timestep to update the
+     * simulation variables in the DataWarehouse
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleTimeAdvance (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_time_advance_solution (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleTimeAdvance_subproblems (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_solution (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleTimeAdvance_subproblems (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+    /**
+     * @brief Schedule task_time_advance_dbg_derivatives (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleTimeAdvance_dbg_derivatives (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_dbg_derivatives (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleTimeAdvance_dbg_derivatives (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_dbg_derivatives_error
+     * (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleTimeAdvance_dbg_derivatives_error (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_dbg_derivatives_error
+     * (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleTimeAdvance_dbg_derivatives_error (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+#endif
+
+    /**
+     * @brief Schedule task_time_advance_solution (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates psi
+     * and u allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleTimeAdvance_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_solution (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates psi
+     * and u allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleTimeAdvance_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_solution_error
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    void
+    scheduleTimeAdvance_solution_error (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the refinement tasks
+     *
+     * Specify all tasks to be performed after an AMR regrid in order to populate
+     * variables in the DataWarehouse at newly created patches
+     *
+     * @remark If regridding happens at initial time step scheduleInitialize is
+     * called instead
+     *
+     * @param new_patches patches to be populated
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleRefine (
+        const PatchSet * new_patches,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_initialize_subproblems after regridding
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @remark subproblems need to be reinitialized on all patches because
+     * even preexisting patches may have different neighbors
+     *
+     * @param new_patches patches to be populated
+     * @param sched scheduler to manage the tasks
+     */
+    void
+    scheduleRefine_subproblems (
+        const PatchSet * new_patches,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_refine_solution
+     *
+     * Defines the dependencies and output of the task which interpolates the
+     * solution from the coarser level to each one of the new_patches
+     * allowing sched to control its execution order
+     *
+     * @param new_patches patches to be populated
+     * @param sched scheduler to manage the tasks
+     */
+    void
+    scheduleRefine_solution (
+        const PatchSet * new_patches,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the refinement tasks
+     *
+     * Do nothing
+     *
+     * @param level_fine unused
+     * @param sched unused
+     * @param need_old_coarse unused
+     * @param need_new_coarse unused
+     */
+    virtual void
+    scheduleRefineInterface (
+        const LevelP & level_fine,
+        SchedulerP & sched,
+        bool need_old_coarse,
+        bool need_new_coarse
+    ) override;
+
+    /**
+     * @brief Schedule the time coarsen tasks
+     *
+     * Specify all tasks to be performed after each timestep to restrict the
+     * computed variables from finer to coarser levels
+     *
+     * @param level_coarse level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleCoarsen (
+        const LevelP & level_coarse,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_coarsen_solution
+     *
+     * Defines the dependencies and output of the task which restrict the
+     * solution to level_coarse from its finer level allowing sched to control
+     * its execution order
+     *
+     * @param level_coarse level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    void
+    scheduleCoarsen_solution (
+        const LevelP & level_coarse,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the error estimate tasks
+     *
+     * Specify all tasks to be performed before each timestep to estimate the
+     * spatial discretization error on the solution update in order to decide
+     * where to refine the grid
+     *
+     * @param level level to check
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleErrorEstimate (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_error_estimate_solution (coarsest level implementation)
+     *
+     * Defines the dependencies and output of the task which estimates the
+     * spatial discretization error allowing sched to controvaluel its execution order
+     *
+     * @param level level to check
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleErrorEstimate_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_error_estimate_grad_psi (refinement level implementation)
+     *
+     * Defines the dependencies and output of the task which estimates the
+     * spatial discretization error allowing sched to control its execution order
+     *
+     * @param level level to check
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleErrorEstimate_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the initial error estimate tasks
+     *
+     * Specify all tasks to be performed before the first timestep to estimate
+     * the spatial discretization error on the solution update in order to decide
+     * where to refine the grid
+     *
+     * @remark forward to scheduleErrorEstimate
+     *
+     * @param level level to check
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleInitialErrorEstimate (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+protected: // TASKS
+
+    /**
+     * @brief Initialize subproblems task
+     *
+     * Create the SubProblems for each one of the patches and save it to dw_new
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_initialize_subproblems (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Initialize solution task
+     *
+     * Allocate and save variables for psi and u for each one of the patches
+     * and save them to dw_new
+     * @remark initialize also anisotropy terms to 0
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_initialize_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Compute timestep task
+     *
+     * Puts into the new DataWarehouse the constant value specified in input (delt)
+     * of the timestep
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_compute_stable_timestep (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Advance subproblems task
+     *
+     * Move SubProblems for each one of the patches and from dw_old to dw_new
+     * or, if not found in dw_old (after regrid), create new subproblems in dw_new
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_subproblems (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+
+    /**
+     * @brief Advance derivatives task (debug)
+     *
+     * Computes value of u derivatives using the solution at the previous
+     * timestep (for debugging purpose)
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_dbg_derivatives (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Advance derivatives error task (debug)
+     *
+     * Computes the error in the approximation of u derivatives
+     * comparing them with their analytical expressions (for debugging purpose)
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_dbg_derivatives_error (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+#endif
+
+    /**
+     * @brief Advance solution task
+     *
+     * Computes new value of u using the value of the solution and at
+     * previous timestep
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Advance solution error task (test)
+     *
+     * Computes error in u approximation using the analytical solution
+     *
+     * @remark test must be set to true in input
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_solution_error (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Refine solution task
+     *
+     * Computes interpolated value of u on new refined patched
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches_fine list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_refine_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches_fine,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Coarsen solution task
+     *
+     * Restricted value of u from refined regions to coarse patches
+     * underneath
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches_coarse list of patches to be updated
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_coarsen_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches_coarse,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief ErrorEstimate solution task
+     *
+     * Computes the gradient of the solution using its value at the previous
+     * timestep and set refinement flag where it is above the threshold given
+     * in input
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_error_estimate_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+protected: // IMPLEMENTATIONS
+
+    /**
+     * @brief Initialize solution implementation
+     *
+     * compute initial condition for u at a given grid position
+     *
+     * @param id grid index
+     * @param patch grid patch
+     * @param L domain width
+     * @param[out] u view of the solution field in the new dw
+     */
+    void
+    initialize_solution (
+        const IntVector & id,
+        const Patch * patch,
+        const double & L,
+        View < ScalarField<double> > & u
+    );
+
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+
+    /**
+     * @brief Advance derivatives implementation
+     *
+     * Computes value of u derivatives using the solution at the previous
+     * timestep at a given grid position (for debugging purpose)
+     *
+     * @param id grid index
+     * @param u_old view of the solution field in the old dw
+     * @param[out] du view of the solution derivatives vector field in the new dw
+     * @param[out] ddu view of the solution derivatives vector field in the new dw
+     */
+    void
+    time_advance_dbg_derivatives (
+        const IntVector & id,
+        const FDView < ScalarField<const double>, STN > & u_old,
+        View < VectorField<double, DIM> > & du,
+        View < VectorField<double, DIM> > & ddu
+    );
+
+    /**
+     * @brief Advance derivatives error implementation
+     *
+     * Computes error in the approximation of u derivatives comparing them with
+     * their analytical expressions at a given grid position
+     * (for debugging purpose)
+     *
+     * @param id grid index
+     * @param patch grid patch
+     * @param L domain width
+     * @param t simulation time
+     * @param du view of the solution derivatives vector field in the new dw
+     * @param ddu view of the solution derivatives vector field in the new dw
+     * @param[out] error_du view of the solution derivatives error vector field in the new dw
+     * @param[out] error_ddu view of the solution derivatives error vector field in the new dw
+     * @param[out] u_normH10 L2-norm of the solution 1st order derivatives vector
+     * @param[out] u_normH20 L2-norm of the solution 2nd order derivatives vector
+     * @param[out] error_normH10 L2-norm of the solution 1st order derivatives error vector
+     * @param[out] error_normH20 L2-norm of the solution 2nd order derivatives error vector
+     */
+    void
+    time_advance_dbg_derivatives_error (
+        const IntVector & id,
+        const Patch * patch,
+        const double & L,
+        const double & t,
+        View < VectorField<const double, DIM> > & du,
+        View < VectorField<const double, DIM> > & ddu,
+        View < VectorField<double, DIM> > & error_du,
+        View < VectorField<double, DIM> > & error_ddu,
+        double & u_normH10,
+        double & u_normH20,
+        double & error_normH10,
+        double & error_normH20
+    );
+#endif
+
+    /**
+     * @brief Advance solution implementation
+     *
+     * compute new value for u at a given grid position using the value of the
+     * solution and at previous timestep
+     *
+     * @param id grid index
+     * @param u_old view of the solution field in the old dw
+     * @param[out] u_new view of the solution field in the new dw
+     */
+    void
+    time_advance_solution (
+        const IntVector & id,
+        const FDView < ScalarField<const double>, STN > & u_old,
+        View < ScalarField<double> > & u_new
+    );
+
+    /**
+     * @brief Advance solution error task (test)
+     *
+     * compute error in u approximation at a given grid position using the
+     * analytical solution
+     *
+     * @param id grid index
+     * @param patch grid patch
+     * @param L domain width
+     * @param t simulation time
+     * @param u view of the newly computed solution field in the new dw
+     * @param[out] delta_u view of the local error (difference between computed and
+     * analytical solution at each grid position)
+     * @param[out] error_u interpolation error (L2 norm over the range of each
+     * grid position of the difference between computed and
+     * analytical solution at each grid position)
+     * @param[out] u_normL2 L2-norm (global) of the solution vector
+     * @param[out] error_normL2 L2-norm (global) of the solution error vector
+     *
+     */
+    void
+    time_advance_solution_error (
+        const IntVector & id,
+        const Patch * patch,
+        const double & L,
+        const double & t,
+        View < ScalarField<const double> > & u,
+        View < ScalarField<double> > & delta_u,
+        View < ScalarField<double> > & error_u,
+        double & u_normL2,
+        double & error_normL2
+    );
+
+    /**
+     * @brief Refine solution implementation
+     *
+     * Computes interpolated value of u at a given grid position
+
+     * @param id_fine fine grid index
+     * @param u_coarse_interp interpolator of the aolution field on the coarse level
+     * @param[out] u_fine view of the aolution field on the fine level
+     */
+    void
+    refine_solution (
+        const IntVector id_fine,
+        const View < ScalarField<const double> > & u_coarse_interp,
+        View < ScalarField<double> > & u_fine
+    );
+
+    /**
+     * @brief Coarsen solution implementation
+     *
+     * Computes restricted value of u at a given grid position
+
+     * @param id_coarse coarse grid index
+     * @param u_fine_restr restrictor of the aolution field on the fine level
+     * @param[out] u_coarse view of the aolution field on the coarse level
+     */
+    void
+    coarsen_solution (
+        const IntVector id_coarse,
+        const View < ScalarField<const double> > & u_fine_restr,
+        View < ScalarField<double> > & u_coarse
+    );
+
+    /**
+     * @brief ErrorEstimate solution implementation (cell centered implementation)
+     *
+     * Computes the gradient of the phase field using its value at the previous
+     * timestep and set refinement flag where it is above the threshold given
+     * in input
+     *
+     * @param id grid index
+     * @param u view of the solution the old dw
+     * @param[out] refine_flag view of refine flag (grid field) in the new dw
+     * @param[out] refine_patch flag for patch refinement
+     */
+    template < VarType V >
+    typename std::enable_if < V == CC, void >::type
+    error_estimate_solution (
+        const IntVector id,
+        FDView < ScalarField<const double>, STN > & u,
+        View < ScalarField<int> > & refine_flag,
+        bool & refine_patch
+    );
+
+    /**
+     * @brief ErrorEstimate solution implementation (vertex based implementation)
+     *
+     * Computes the gradient of the phase field using its value at the previous
+     * timestep and set refinement flag where it is above the threshold given
+     * in input
+     *
+     * @param id grid index
+     * @param u view of the solution in the old dw
+     * @param[out] refine_flag view of refine flag (grid field) in the new dw
+     * @param[out] refine_patch flag for patch refinement
+     */
+    template < VarType V >
+    typename std::enable_if < V == NC, void >::type
+    error_estimate_solution (
+        const IntVector id,
+        FDView < ScalarField<const double>, STN > & u,
+        View < ScalarField<int> > & refine_flag,
+        bool & refine_patch
+    );
+
+}; // class Heat
+
+// CONSTRUCTORS/DESTRUCTOR
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+Heat<VAR, DIM, STN, AMR>::Heat (
+    const ProcessorGroup * myworld,
+    const MaterialManagerP materialManager,
+    int verbosity
+) : Application<VAR, DIM, STN, AMR> ( myworld, materialManager )
+    ,  dbg_out1 ( "Heat", verbosity > 0 )
+    ,  dbg_out2 ( "Heat", verbosity > 1 )
+    ,  dbg_out3 ( "Heat", verbosity > 2 )
+    ,  dbg_out4 ( "Heat", verbosity > 3 )
+{
+    u_label = VarLabel::create ( "u", Variable<VAR, double>::getTypeDescription() );
+    subproblems_label = VarLabel::create ( "subproblems", Variable < PP, SubProblems < HeatProblem<VAR, STN> > >::getTypeDescription() );
+    delta_u_label = VarLabel::create ( "delta_u", Variable<VAR, double>::getTypeDescription() );
+    error_u_label = VarLabel::create ( "error_u", Variable<VAR, double>::getTypeDescription() );
+    u_normL2_label = VarLabel::create ( "u_normL2", sum_vartype::getTypeDescription() );
+    error_normL2_label = VarLabel::create ( "error_normL2", sum_vartype::getTypeDescription() );
+
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+    du_label[X] = VarLabel::create ( "ux", Variable<VAR, double>::getTypeDescription() );
+    ddu_label[X] = VarLabel::create ( "uxx", Variable<VAR, double>::getTypeDescription() );
+    error_du_label[X] = VarLabel::create ( "error_ux", Variable<VAR, double>::getTypeDescription() );
+    error_ddu_label[X] = VarLabel::create ( "error_uxx", Variable<VAR, double>::getTypeDescription() );
+    if ( DIM > D1 )
+    {
+        du_label[Y] = VarLabel::create ( "uy", Variable<VAR, double>::getTypeDescription() );
+        ddu_label[Y] = VarLabel::create ( "uyy", Variable<VAR, double>::getTypeDescription() );
+        error_du_label[Y] = VarLabel::create ( "error_uy", Variable<VAR, double>::getTypeDescription() );
+        error_ddu_label[Y] = VarLabel::create ( "error_uyy", Variable<VAR, double>::getTypeDescription() );
+    }
+    if ( DIM > D2 )
+    {
+        du_label[Z] = VarLabel::create ( "uz", Variable<VAR, double>::getTypeDescription() );
+        ddu_label[Z] = VarLabel::create ( "uzz", Variable<VAR, double>::getTypeDescription() );
+        error_du_label[Z] = VarLabel::create ( "error_uz", Variable<VAR, double>::getTypeDescription() );
+        error_ddu_label[Z] = VarLabel::create ( "error_uzz", Variable<VAR, double>::getTypeDescription() );
+    }
+    u_normH10_label = VarLabel::create ( "u_normH10", sum_vartype::getTypeDescription() );
+    u_normH20_label = VarLabel::create ( "u_normH20", sum_vartype::getTypeDescription() );
+    error_normH10_label = VarLabel::create ( "error_normH10", sum_vartype::getTypeDescription() );
+    error_normH20_label = VarLabel::create ( "error_normH20", sum_vartype::getTypeDescription() );
+#endif
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+Heat<VAR, DIM, STN, AMR>::~Heat()
+{
+    VarLabel::destroy ( u_label );
+    VarLabel::destroy ( subproblems_label );
+    VarLabel::destroy ( delta_u_label );
+    VarLabel::destroy ( error_u_label );
+    VarLabel::destroy ( u_normL2_label );
+    VarLabel::destroy ( error_normL2_label );
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+    for ( size_t D = 0; D < DIM; ++D )
+    {
+        VarLabel::destroy ( du_label[D] );
+        VarLabel::destroy ( ddu_label[D] );
+        VarLabel::destroy ( error_du_label[D] );
+        VarLabel::destroy ( error_ddu_label[D] );
+    }
+    VarLabel::destroy ( u_normH10_label );
+    VarLabel::destroy ( u_normH20_label );
+    VarLabel::destroy ( error_normH10_label );
+    VarLabel::destroy ( error_normH20_label );
+#endif
+}
+
+// SETUP
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::problemSetup (
+    const ProblemSpecP & params,
+    const ProblemSpecP &,
+    GridP &
+)
+{
+    this->m_scheduler->overrideVariableBehavior ( subproblems_label->getName(), false, false, false, true, true );
+    this->m_materialManager->registerSimpleMaterial ( scinew SimpleMaterial() );
+
+    ProblemSpecP heat = params->findBlock ( "PhaseField" );
+    heat->require ( "delt", delt );
+    heat->require ( "alpha", alpha );
+    heat->getWithDefault ( "test", test, false );
+
+    std::string scheme;
+    heat->getWithDefault ( "scheme", scheme, "forward_euler" );
+    if ( scheme != "forward_euler" )
+        SCI_THROW ( InternalError ( "\n ERROR: Implicit time scheme requires HYPRE\n", __FILE__, __LINE__ ) );
+
+    if ( AMR )
+    {
+        this->setLockstepAMR ( true );
+
+        c2f[u_label->getName()] = ( VAR == CC ) ? FC::FC0 : FC::FC1;
+
+        heat->require ( "refine_threshold", refine_threshold );
+        ProblemSpecP amr, regridder, fci;
+        if ( ! ( amr = params->findBlock ( "AMR" ) ) ) return;
+        if ( ! ( fci = amr->findBlock ( "FineCoarseInterfaces" ) ) ) return;
+        if ( ! ( fci = fci->findBlock ( "FCIType" ) ) ) return;
+        do
+        {
+            std::string label, var;
+            fci->getAttribute ( "label", label );
+            fci->getAttribute ( "var", var );
+            c2f[label] = str_to_fc ( var );
+        }
+        while ( fci = fci->findNextBlock ( "FCIType" ) );
+    }
+
+}
+
+// SCHEDULINGS
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleInitialize (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleInitialize" << std::endl;
+
+    scheduleInitialize_subproblems<AMR> ( level, sched );
+    scheduleInitialize_solution<AMR> ( level, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleInitialize_subproblems (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleInitialize_subproblems" << std::endl;
+
+    Task * task = scinew Task ( "Heat::task_initialize_subproblems", this, &Heat::task_initialize_subproblems );
+    task->computes ( subproblems_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+/**
+ * @remark we need to schedule all levels before task_error_estimate_solution to avoid
+ * the error "Failure finding [subproblems , coarseLevel, MI: none, NewDW
+ * (mapped to dw index 1), ####] for Heat::task_error_estimate_solution",
+ * on patch #, Level #, on material #, resource (rank): #" while compiling the
+ * TaskGraph
+ */
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleInitialize_subproblems (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleInitialize_subproblems" << std::endl;
+
+    // since the SimulationController is calling this scheduler starting from
+    // the finest level we schedule only on the finest level
+    if ( level->hasFinerLevel() ) return;
+
+    GridP grid = level->getGrid();
+    for ( int l = 0; l < grid->numLevels(); ++l )
+        scheduleInitialize_subproblems < !MG > ( grid->getLevel ( l ), sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleInitialize_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleInitialize_solution" << std::endl;
+    Task * task = scinew Task ( "Heat::task_initialize_solution", this, &Heat::task_initialize_solution );
+    task->computes ( u_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+/**
+ * @remark we need to schedule all levels before task_error_estimate_solution to avoid
+ * the error "Failure finding [u , coarseLevel, MI: none, NewDW
+ * (mapped to dw index 1), ####] for Heat::task_error_estimate_solution",
+ * on patch #, Level #, on material #, resource (rank): #" while compiling the
+ * TaskGraph
+ */
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleInitialize_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleInitialize_solution" << std::endl;
+
+    // since the SimulationController is calling this scheduler starting from
+    // the finest level we schedule only on the finest level
+    if ( level->hasFinerLevel() ) return;
+
+    GridP grid = level->getGrid();
+    for ( int l = 0; l < grid->numLevels(); ++l )
+        scheduleInitialize_solution < !MG > ( grid->getLevel ( l ), sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleRestartInitialize (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleRestartInitialize" << std::endl;
+    scheduleInitialize_subproblems<AMR> ( level, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleComputeStableTimeStep (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "Heat::task_compute_stable_timestep ", this, &Heat::task_compute_stable_timestep );
+    task->computes ( this->getDelTLabel(), level.get_rep() );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+
+    is_first_schedule_refine = false;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance" << std::endl;
+
+    scheduleTimeAdvance_subproblems<AMR> ( level, sched );
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+    scheduleTimeAdvance_dbg_derivatives<AMR> ( level, sched );
+    if ( test ) scheduleTimeAdvance_dbg_derivatives_error<AMR> ( level, sched );
+#endif
+
+    scheduleTimeAdvance_solution<AMR> ( level, sched );
+    if ( test ) scheduleTimeAdvance_solution_error ( level, sched );
+};
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_subproblems (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_subproblems" << std::endl;
+
+    Task * task = scinew Task ( "Heat::task_time_advance_subproblems", this, &Heat::task_time_advance_subproblems );
+    task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+    task->computes ( subproblems_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_subproblems (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_subproblems" << std::endl;
+
+    if ( level->hasCoarserLevel() ) return;
+
+    GridP grid = level->getGrid();
+    for ( int l = 0; l < grid->numLevels(); ++l )
+        scheduleTimeAdvance_subproblems < !MG > ( grid->getLevel ( l ), sched );
+}
+
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_dbg_derivatives (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_dbg_derivatives" << std::endl;
+
+    Task * task = scinew Task ( "Heat::task_time_advance_dbg_derivatives", this, &Heat::task_time_advance_dbg_derivatives );
+    task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::OldDW, u_label, FGT, FGN );
+    for ( size_t D = 0; D < DIM; ++D )
+    {
+        task->computes ( du_label[D] );
+        task->computes ( ddu_label[D] );
+    }
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_dbg_derivatives (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_dbg_derivatives" << std::endl;
+
+    if ( !level->hasCoarserLevel() ) scheduleTimeAdvance_dbg_derivatives < !MG > ( level, sched );
+    else
+    {
+        Task * task = scinew Task ( "Heat::task_time_advance_dbg_derivatives", this, &Heat::task_time_advance_dbg_derivatives );
+        task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+        task->requires ( Task::OldDW, subproblems_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->requires ( Task::OldDW, u_label, FGT, FGN );
+        task->requires ( Task::OldDW, u_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        for ( size_t D = 0; D < DIM; ++D )
+        {
+            task->computes ( du_label[D] );
+            task->computes ( ddu_label[D] );
+        }
+        sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_dbg_derivatives_error (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_dbg_derivatives_error" << std::endl;
+
+    Task * task = scinew Task ( "Heat::task_time_advance_dbg_derivatives_error", this, &Heat::task_time_advance_dbg_derivatives_error );
+    task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+    for ( size_t D = 0; D < DIM; ++D )
+    {
+        task->requires ( Task::NewDW, du_label[D], Ghost::None, 0 );
+        task->requires ( Task::NewDW, ddu_label[D], Ghost::None, 0 );
+        task->computes ( error_du_label[D] );
+        task->computes ( error_ddu_label[D] );
+    }
+    task->computes ( u_normH10_label );
+    task->computes ( error_normH10_label );
+    task->computes ( u_normH20_label );
+    task->computes ( error_normH20_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_dbg_derivatives_error (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_dbg_derivatives_error" << std::endl;
+
+    if ( !level->hasCoarserLevel() ) scheduleTimeAdvance_dbg_derivatives_error < !MG > ( level, sched );
+    else
+    {
+        Task * task = scinew Task ( "Heat::task_time_advance_dbg_derivatives_error", this, &Heat::task_time_advance_dbg_derivatives_error );
+        task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+        task->requires ( Task::NewDW, subproblems_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        for ( size_t D = 0; D < DIM; ++D )
+        {
+            task->requires ( Task::NewDW, du_label[D], Ghost::None, 0 );
+            task->requires ( Task::NewDW, ddu_label[D], Ghost::None, 0 );
+            task->computes ( error_du_label[D] );
+            task->computes ( error_ddu_label[D] );
+        }
+        task->computes ( u_normH10_label );
+        task->computes ( error_normH10_label );
+        task->computes ( u_normH20_label );
+        task->computes ( error_normH20_label );
+        sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+    }
+}
+#endif
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_solution " << std::endl;
+
+    Task * task = scinew Task ( "Heat::task_time_advance_solution", this, &Heat::task_time_advance_solution );
+    task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::OldDW, u_label, FGT, FGN );
+    task->computes ( u_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_solution" << std::endl;
+
+    if ( !level->hasCoarserLevel() ) scheduleTimeAdvance_solution < !MG > ( level, sched );
+    else
+    {
+        Task * task = scinew Task ( "Heat::task_time_advance_solution", this, &Heat::task_time_advance_solution );
+        task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+        task->requires ( Task::OldDW, subproblems_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->requires ( Task::OldDW, u_label, FGT, FGN );
+        task->requires ( Task::OldDW, u_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->computes ( u_label );
+        sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleTimeAdvance_solution_error (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleTimeAdvance_solution_error" << std::endl;
+
+    Task * task = scinew Task ( "Heat::task_time_advance_solution_error", this, &Heat::task_time_advance_solution_error );
+    task->requires ( Task::NewDW, u_label, Ghost::None, 0 );
+    task->computes ( delta_u_label );
+    task->computes ( error_u_label );
+    task->computes ( u_normL2_label );
+    task->computes ( error_normL2_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleRefine
+(
+    const PatchSet * new_patches,
+    SchedulerP & sched
+)
+{
+    // we need to create subproblems for new patches.
+    // moreover, since SchedulerCommon::copyDataToNewGrid is not copying PerPatch
+    // variable to the new grid (which is fine since the geometry -thus the subproblems-
+    // has changed) we need to schedule their creation within scheduleRefine/scheduleRefineInterface
+    // since this tasks are compiled separately from those scheduled by scheduleTimeAdvance
+    cout_heat_scheduling << "scheduleRefine" << std::endl;
+
+    const Level * level = getLevel ( new_patches );
+
+    if ( !is_first_schedule_refine )
+    {
+        scheduleRefine_subproblems ( new_patches, sched );
+        is_first_schedule_refine = true;
+    };
+
+    // no need to refine on coarser level
+    if ( level->hasCoarserLevel() )
+        scheduleRefine_solution ( new_patches, sched );
+}
+
+/**
+ * @remark we need to schedule all levels before task_error_estimate_solution to avoid
+ * the error "Failure finding [subproblems , coarseLevel, MI: none, NewDW
+ * (mapped to dw index 1), ####] for Heat::task_error_estimate_solution",
+ * on patch #, Level #, on material #, resource (rank): #" while compiling the
+ * TaskGraph
+ */
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleRefine_subproblems (
+    const PatchSet * new_patches,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleRefine_update_subproblems" << std::endl;
+
+    const GridP & grid = getLevel ( new_patches )->getGrid();
+    for ( int l = 0; l < grid->numLevels(); ++l )
+    {
+        Task * task = scinew Task ( "Heat::task_refine_update_subproblems", this, &Heat::task_initialize_subproblems );
+        task->computes ( subproblems_label );
+        sched->addTask ( task, grid->getLevel ( l )->eachPatch(), this->m_materialManager->allMaterials() );
+    }
+}
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleRefine_solution (
+    const PatchSet * new_patches,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleRefine_solution" << std::endl;
+
+        Task * task = scinew Task ( "Heat::task_refine_solution", this, &Heat::task_refine_solution );
+        task->requires ( Task::NewDW, u_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+        task->requires ( Task::NewDW, subproblems_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->computes ( u_label );
+        sched->addTask ( task, new_patches, this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleRefineInterface (
+    const LevelP & /*level_fine*/,
+    SchedulerP & /*sched*/,
+    bool /*need_old_coarse*/,
+    bool /*need_new_coarse*/
+)
+{};
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleCoarsen
+(
+    const LevelP & level_coarse,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleCoarsen" << std::endl;
+
+    scheduleCoarsen_solution ( level_coarse, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleCoarsen_solution (
+    const LevelP & level_coarse,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleCoarsen" << std::endl;
+
+    Task * task = scinew Task ( "Heat::task_coarsen_solution", this, &Heat::task_coarsen_solution );
+    task->requires ( Task::NewDW, u_label, nullptr, Task::FineLevel, nullptr, Task::NormalDomain, Ghost::None, 0 );
+    task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::NewDW, subproblems_label, nullptr, Task::FineLevel, nullptr, Task::NormalDomain, Ghost::None, 0 );
+    task->modifies ( u_label );
+    sched->addTask ( task, level_coarse->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::scheduleErrorEstimate
+(
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleErrorEstimate" << std::endl;
+
+    scheduleErrorEstimate_solution<AMR> ( level, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleErrorEstimate_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleErrorEstimate_solution" << std::endl;
+
+    Task * task = scinew Task ( "Heat::task_error_estimate_solution", this, &Heat::task_error_estimate_solution );
+    task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::NewDW, u_label, FGT, FGN );
+    task->modifies ( this->m_regridder->getRefineFlagLabel(), this->m_regridder->refineFlagMaterials() );
+    task->modifies ( this->m_regridder->getRefinePatchFlagLabel(), this->m_regridder->refineFlagMaterials() );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+Heat<VAR, DIM, STN, AMR>::scheduleErrorEstimate_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleErrorEstimate_solution" << std::endl;
+
+    if ( !level->hasCoarserLevel() ) scheduleErrorEstimate_solution < !MG > ( level, sched );
+    else
+    {
+        Task * task = scinew Task ( "Heat::task_error_estimate_solution", this, &Heat::task_error_estimate_solution );
+        task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+        task->requires ( Task::NewDW, subproblems_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->requires ( Task::NewDW, u_label, FGT, FGN );
+        task->requires ( Task::NewDW, u_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->modifies ( this->m_regridder->getRefineFlagLabel(), this->m_regridder->refineFlagMaterials() );
+        task->modifies ( this->m_regridder->getRefinePatchFlagLabel(), this->m_regridder->refineFlagMaterials() );
+        sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void Heat<VAR, DIM, STN, AMR>::scheduleInitialErrorEstimate
+(
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    cout_heat_scheduling << "scheduleInitialErrorEstimate" << std::endl;
+
+    scheduleErrorEstimate ( level, sched );
+}
+
+// TASKS
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_initialize_subproblems (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse *,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_initialize_subproblems ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        Variable < PP, SubProblems < HeatProblem<VAR, STN> > > subproblems;
+        subproblems.setData ( scinew SubProblems < HeatProblem<VAR, STN> > ( this, u_label, subproblems_label, material, patch, &c2f ) );
+        dw_new->put ( subproblems, subproblems_label, material, patch );
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_initialize_solution (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse *,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_initialize_solution ====" << std::endl;
+
+    BBox box;
+    getLevel ( patches )->getGrid()->getSpatialRange ( box );
+    Vector L = box.max().asVector();
+
+    ASSERTMSG ( DIM < D2 || L[Y] == L[X], "grid geometry must be a square" );
+    ASSERTMSG ( DIM < D3 || L[Z] == L[X], "grid geometry must be a cube" );
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        BlockRange range ( this->get_range ( patch ) );
+        dbg_out3 << myrank << "= Iterating over range " << range << std::endl;
+
+        DWView < ScalarField<double>, VAR, DIM > u ( dw_new, u_label, material, patch );
+        parallel_for ( range, [patch, &L, &u, this] ( int i, int j, int k )->void { initialize_solution ( {i, j, k}, patch, L[X], u ); } );
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_compute_stable_timestep (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse *,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_compute_stable_timestep ====" << std::endl;
+    dw_new->put ( delt_vartype ( delt ), this->getDelTLabel(), getLevel ( patches ) );
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_time_advance_subproblems (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_time_advance_subproblems ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        if ( dw_old->exists ( subproblems_label, material, patch ) )
+        {
+            Variable < PP, SubProblems < HeatProblem<VAR, STN> > > subproblems;
+            dw_old->get ( subproblems, subproblems_label, material, patch );
+            dw_new->put ( subproblems, subproblems_label, material, patch );
+            dbg_out4 << "subproblems moved from OldDW to NewDW" << std::endl;
+        }
+        else // after a regrid all patches are new thus subproblems does not exists in old db
+            // not bad since we want re recompute them!
+        {
+            Variable < PP, SubProblems < HeatProblem<VAR, STN> > > subproblems;
+            subproblems.setData ( scinew SubProblems < HeatProblem<VAR, STN> > ( this, u_label, subproblems_label, material, patch, &c2f ) );
+            dw_new->put ( subproblems, subproblems_label, material, patch );
+            dbg_out4 << "subproblems initialized in NewDW" << std::endl;
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_time_advance_dbg_derivatives (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_time_advance_dbg_derivatives ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        DWView < VectorField<double, DIM>, VAR, DIM > du ( dw_new, du_label, material, patch );
+        DWView < VectorField<double, DIM>, VAR, DIM > ddu ( dw_new, ddu_label, material, patch );
+
+        Variable < PP, SubProblems < HeatProblem<VAR, STN> > > subproblems;
+        dw_new->get ( subproblems, subproblems_label, material, patch );
+        auto problems = subproblems.get().get_rep();
+
+        for ( const auto & p : *problems )
+        {
+            dbg_out3 << myrank << "= Iterating over " << p << std::endl;
+            FDView < ScalarField<const double>, STN > & u_old = p.template get_fd_view<U> ( dw_old );
+            parallel_for ( p.get_range(), [patch, &u_old, &du, &ddu, this] ( int i, int j, int k )->void { time_advance_dbg_derivatives ( {i, j, k}, u_old, du, ddu ); } );
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_time_advance_dbg_derivatives_error
+(
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset * /*matls*/,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_time_advance_dbg_derivatives_error ====" << std::endl;
+
+    std::array<double, 4> norms {{ 0., 0., 0., 0. }}; // { u_normH10, u_normH20, error_normH10, error_normH20 }
+
+    simTime_vartype simTimeVar;
+    dw_old->get ( simTimeVar, VarLabel::find ( simTime_name ) );
+    double simTime = simTimeVar;
+
+    BBox box;
+    getLevel ( patches )->getGrid()->getSpatialRange ( box );
+    Vector L = box.max() - box.min();
+
+    ASSERTMSG ( DIM < D2 || L[Y] == L[X], "grid geometry must be a square" );
+    ASSERTMSG ( DIM < D3 || L[Z] == L[X], "grid geometry must be a cube" );
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << std::endl;
+
+        DWView < VectorField<const double, DIM>, VAR, DIM > du ( dw_new, du_label, material, patch );
+        DWView < VectorField<const double, DIM>, VAR, DIM > ddu ( dw_new, ddu_label, material, patch );
+
+        DWView < VectorField<double, DIM>, VAR, DIM > error_du ( dw_new, error_du_label, material, patch );
+        DWView < VectorField<double, DIM>, VAR, DIM > error_ddu ( dw_new, error_ddu_label, material, patch );
+
+        BlockRange range ( this->get_range ( patch ) );
+        dbg_out3 << "= Iterating over range " << range << std::endl;
+
+        parallel_reduce_sum (
+            range,
+            [patch, &simTime, &L, &du, &ddu, &error_du, &error_ddu, this] ( int i, int j, int k, std::array<double, 4> & norms )->void { time_advance_dbg_derivatives_error ( {i, j, k}, patch, simTime, L[0], du, ddu, error_du, error_ddu, norms[0], norms[1], norms[2], norms[3] ); },
+            norms
+        );
+    }
+
+    dw_new->put ( sum_vartype ( norms[0] ), u_normH10_label );
+    dw_new->put ( sum_vartype ( norms[1] ), u_normH20_label );
+    dw_new->put ( sum_vartype ( norms[2] ), error_normH10_label );
+    dw_new->put ( sum_vartype ( norms[3] ), error_normH20_label );
+
+    dbg_out2 << myrank << std::endl;
+}
+#endif
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_time_advance_solution (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_time_advance_solution ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        DWView < ScalarField<double>, VAR, DIM > u_new ( dw_new, u_label, material, patch );
+
+        Variable < PP, SubProblems < HeatProblem<VAR, STN> > > subproblems;
+        dw_new->get ( subproblems, subproblems_label, material, patch );
+        auto problems = subproblems.get().get_rep();
+
+        for ( const auto & p : *problems )
+        {
+            dbg_out3 << myrank << "= Iterating over " << p << std::endl;
+
+            FDView < ScalarField<const double>, STN > & u_old = p.template get_fd_view<U> ( dw_old );
+            parallel_for ( p.get_range(), [patch, &u_old, &u_new, this] ( int i, int j, int k )->void { time_advance_solution ( {i, j, k}, u_old, u_new ); } );
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_time_advance_solution_error
+(
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset * /*matls*/,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_time_advance_solution_error ====" << std::endl;
+
+    std::array<double, 2> norms {{ 0., 0. }}; // { u_normL2, error_normL2 }
+
+    simTime_vartype simTimeVar;
+    dw_old->get ( simTimeVar, VarLabel::find ( simTime_name ) );
+    double simTime = simTimeVar;
+
+    BBox box;
+    getLevel ( patches )->getGrid()->getSpatialRange ( box );
+    Vector L = box.max() - box.min();
+
+    ASSERTMSG ( DIM < D2 || L[Y] == L[X], "grid geometry must be a square" );
+    ASSERTMSG ( DIM < D3 || L[Z] == L[X], "grid geometry must be a cube" );
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << std::endl;
+
+        DWView < ScalarField<const double>, VAR, DIM > u ( dw_new, u_label, material, patch );
+
+        DWView < ScalarField<double>, VAR, DIM > delta_u ( dw_new, delta_u_label, material, patch );
+        DWView < ScalarField<double>, VAR, DIM > error_u ( dw_new, error_u_label, material, patch );
+
+        BlockRange range ( this->get_range ( patch ) );
+        dbg_out3 << "= Iterating over range " << range << std::endl;
+
+        parallel_reduce_sum ( range, [patch, &simTime, &L, &u, &delta_u, &error_u, this] ( int i, int j, int k, std::array<double, 2> & norms )->void { time_advance_solution_error ( {i, j, k}, patch, simTime, L[X], u, delta_u, error_u, norms[0], norms[1] ); }, norms );
+    }
+
+    dw_new->put ( sum_vartype ( norms[0] ), u_normL2_label );
+    dw_new->put ( sum_vartype ( norms[1] ), error_normL2_label );
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_refine_solution
+(
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches_fine,
+    const MaterialSubset * /*matls*/,
+    DataWarehouse * /*dw_old*/,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_refine_solution ====" << std::endl;
+
+    for ( int p = 0; p < patches_fine->size(); ++p )
+    {
+        const Patch * patch_fine = patches_fine->get ( p );
+        dbg_out2 << myrank << "== Fine Patch: " << *patch_fine << " Level: " << patch_fine->getLevel()->getIndex() << std::endl;
+
+        DWView < ScalarField<double>, VAR, DIM > u_fine ( dw_new, u_label, material, patch_fine );
+
+        AMRInterpolator < HeatProblem<VAR, STN>, U, C2F > u_coarse_interp ( dw_new, u_label, subproblems_label, material, patch_fine );
+
+        BlockRange range_fine ( this->get_range ( patch_fine ) );
+        dbg_out3 << myrank << "= Iterating over fine range" << range_fine << std::endl;
+        parallel_for ( range_fine, [&u_coarse_interp, &u_fine, this] ( int i, int j, int k )->void { refine_solution ( {i, j, k}, u_coarse_interp, u_fine ); } );
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_coarsen_solution (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches_coarse,
+    const MaterialSubset * /*matls*/,
+    DataWarehouse * /*dw_old*/,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_coarsen_solution " << std::endl;
+
+    for ( int p = 0; p < patches_coarse->size(); ++p )
+    {
+        const Patch * patch_coarse = patches_coarse->get ( p );
+        dbg_out2 << myrank << "== Coarse Patch: " << *patch_coarse << " Level: " << patch_coarse->getLevel()->getIndex() << std::endl;
+
+        DWView < ScalarField<double>, VAR, DIM > u_coarse ( dw_new, u_label, material, patch_coarse );
+
+        AMRRestrictor < HeatProblem<VAR, STN>, U, F2C > u_fine_restr ( dw_new, u_label, subproblems_label, material, patch_coarse, false );
+
+        for ( const auto & region : u_fine_restr.get_support() )
+        {
+            dbg_out3 << myrank << "= Iterating over coarse cells region " << region << std::endl;
+            BlockRange range_coarse (
+                Max ( region.getLow(), this->get_low ( patch_coarse ) ),
+                Min ( region.getHigh(), this->get_high ( patch_coarse ) )
+            );
+
+            parallel_for ( range_coarse, [&u_fine_restr, &u_coarse, this] ( int i, int j, int k )->void { coarsen_solution ( {i, j, k}, u_fine_restr, u_coarse ); } );
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::task_error_estimate_solution
+(
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset * /*matls*/,
+    DataWarehouse * /*dw_old*/,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== Heat::task_error_estimate_solution " << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        Variable<PP, PatchFlag> refine_patch_flag;
+        dw_new->get ( refine_patch_flag, this->m_regridder->getRefinePatchFlagLabel(), material, patch );
+
+        PatchFlag * patch_flag_refine = refine_patch_flag.get().get_rep();
+
+        bool refine_patch = false;
+
+        DWView < ScalarField<int>, CC, DIM > refine_flag ( dw_new, this->m_regridder->getRefineFlagLabel(), material, patch );
+
+        Variable < PP, SubProblems < HeatProblem<VAR, STN> > > subproblems;
+        dw_new->get ( subproblems, subproblems_label, material, patch );
+
+        auto problems = subproblems.get().get_rep();
+
+        for ( const auto & p : *problems )
+        {
+            dbg_out3 << myrank << "= Iterating over " << p << std::endl;
+
+            FDView < ScalarField<const double>, STN > & u = p.template get_fd_view<U> ( dw_new );
+            parallel_reduce_sum ( p.get_range(), [&u, &refine_flag, &refine_patch, this] ( int i, int j, int k, bool & refine_patch )->void { error_estimate_solution<VAR> ( {i, j, k}, u, refine_flag, refine_patch ); }, refine_patch );
+        }
+
+        if ( refine_patch )
+        {
+            dbg_out3 << myrank << "= Setting refine flag" << std::endl;
+            patch_flag_refine->set();
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+// IMPLEMENTATIONS
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::initialize_solution (
+    const IntVector & id,
+    Patch const * patch,
+    const double & L,
+    View < ScalarField<double> > & u
+)
+{
+    Vector v ( this->get_position ( patch, id ).asVector() );
+
+    // BUG workaround
+    std::stringstream ss;
+    ss << v << std::endl;
+
+    double a = M_PI_2 / L;
+    u[id] = 1.;
+    for ( size_t d = 0; d < DIM; ++d )
+        u[id] *= cos ( a * v[d] );
+}
+
+#ifdef PhaseField_Heat_DBG_DERIVATIVES
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::time_advance_dbg_derivatives (
+    const IntVector & id,
+    const FDView < ScalarField<const double>, STN > & u_old,
+    View < VectorField<double, DIM> > & du,
+    View < VectorField<double, DIM> > & ddu
+)
+{
+    du[X][id] = u_old.dx ( id );
+    ddu[X][id] = u_old.dxx ( id );
+    if ( DIM > D1 )
+    {
+        du[Y][id] = u_old.dy ( id );
+        ddu[Y][id] = u_old.dyy ( id );
+    }
+    if ( DIM > D2 )
+    {
+        du[Z][id] = u_old.dz ( id );
+        ddu[Z][id] = u_old.dzz ( id );
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::time_advance_dbg_derivatives_error (
+    const IntVector & id,
+    const Patch * patch,
+    const double & t,
+    const double & L,
+    View < VectorField<const double, DIM> > & du,
+    View < VectorField<const double, DIM> > & ddu,
+    View < VectorField<double, DIM> > & error_du,
+    View < VectorField<double, DIM> > & error_ddu,
+    double & u_normH10,
+    double & u_normH20,
+    double & error_normH10,
+    double & error_normH20
+)
+{
+    const Level  * level ( patch->getLevel() );
+    if ( level->hasFinerLevel() && level->getFinerLevel()->containsCell ( level->mapCellToFiner ( id ) ) )
+    {
+        for ( size_t i = 0; i < DIM; ++i )
+        {
+            error_du[i][id] = 0.;
+            error_ddu[i][id] = 0.;
+        }
+    }
+    else
+    {
+        Vector v ( this->get_position ( patch, id ).asVector() );
+        Vector dCell ( level->dCell() );
+
+        // BUG workaround
+        std::stringstream ss;
+        ss << v << std::endl;
+
+        double a = M_PI_2 / L;
+        double da2 = a * a * static_cast<double> ( DIM );
+        double area = 1.;
+        double int_u = exp ( -da2 * ( t + delt ) );
+        double int_u2 = exp ( -2.* da2 * ( t + delt ) );
+        double laplacian = 0;
+        for ( size_t i = 0; i < DIM; ++i )
+        {
+            double vi0 = v[i] - 0.5 * dCell[i];
+            double vi1 = v[i] + 0.5 * dCell[i];
+            area *= dCell[i];
+            int_u *= ( sin ( a * vi1 ) - sin ( a * vi0 ) ) / a;
+            int_u2 *= ( vi1 - vi0 ) / 2. + ( sin ( 2.*a * vi1 ) - sin ( 2.*a * vi0 ) ) / ( 4. * a );
+            laplacian += ddu[i][id];
+        }
+
+        for ( size_t i = 0; i < DIM; ++i )
+        {
+            double int_diu = a * exp ( -da2 * ( t + delt ) );
+            double int_diu2 = int_diu * int_diu;
+
+            for ( size_t j = 0; j < DIM; ++j )
+            {
+                double vj0 = v[j] - 0.5 * dCell[j];
+                double vj1 = v[j] + 0.5 * dCell[j];
+                int_diu *= ( j == i ) ? ( cos ( a * vj1 ) - cos ( a * vj0 ) ) / a
+                           : ( sin ( a * vj1 ) - sin ( a * vj0 ) ) / a;
+                int_diu2 *= ( j == i ) ?
+                            ( vj1 - vj0 ) / 2. - ( sin ( 2.*a * vj1 ) - sin ( 2.*a * vj0 ) ) / ( 4. * a ) :
+                            ( vj1 - vj0 ) / 2. + ( sin ( 2.*a * vj1 ) - sin ( 2.*a * vj0 ) ) / ( 4. * a );
+            }
+
+            double int_die2 = area * du[i][id] * du[i][id] - 2. * du[i][id] * int_diu + int_diu2;
+            double int_ddie2 = area * ddu[i][id] * ddu[i][id] + 2. * a * a * ddu[i][id] * int_u + a * a * a * a * int_u2;
+
+            error_du[i][id] = sqrt ( int_die2 / area );
+            error_ddu[i][id] = sqrt ( int_ddie2 / area );
+
+            u_normH10 += int_diu2;
+            error_normH10 += int_die2;
+        }
+        u_normH20 += da2 * da2 * int_u2;
+
+        error_normH20 += area * laplacian * laplacian + 2. * da2 * laplacian * int_u + da2 * da2 * int_u2;
+    }
+}
+#endif
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::time_advance_solution (
+    const IntVector & id,
+    const FDView < ScalarField<const double>, STN > & u_old,
+    View < ScalarField<double> > & u_new
+)
+{
+    double delta_u = delt * alpha * u_old.laplacian ( id );
+    u_new[id] = u_old[id] + delta_u;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::time_advance_solution_error
+(
+    const IntVector & id,
+    const Patch * patch,
+    const double & t,
+    const double & L,
+    View < ScalarField<const double> > & u,
+    View < ScalarField<double> > & delta_u,
+    View < ScalarField<double> > & error_u,
+    double & u_normL2,
+    double & error_normL2
+)
+{
+    const Level  * level ( patch->getLevel() );
+    if ( level->hasFinerLevel() && level->getFinerLevel()->containsCell ( level->mapCellToFiner ( id ) ) )
+    {
+        error_u[id] = 0;
+        delta_u[id] = 0;
+    }
+    else
+    {
+        Vector v ( this->get_position ( patch, id ).asVector() );
+        Vector dCell ( level->dCell() );
+
+        // BUG workaround
+        std::stringstream ss;
+        ss << v << std::endl;
+
+        double a = M_PI_2 / L;
+        double da2 = a * a * static_cast<double> ( DIM );
+        double area = 1.;
+        double del_u = exp ( -da2 * ( t + delt ) );
+        double int_u = del_u;
+        double int_u2 = del_u * del_u;
+
+        for ( size_t i = 0; i < DIM; ++i )
+        {
+            double vi0 = v[i] - 0.5 * dCell[i];
+            double vi1 = v[i] + 0.5 * dCell[i];
+            area *= dCell[i];
+            del_u *= cos ( a * v[i] );;
+            int_u *= ( sin ( a * vi1 ) - sin ( a * vi0 ) ) / a;
+            int_u2 *= ( vi1 - vi0 ) / 2. + ( sin ( 2.*a * vi1 ) - sin ( 2.*a * vi0 ) ) / ( 4. * a );
+        }
+
+        double int_e2 = area * u[id] * u[id] - 2. * u[id] * int_u + int_u2;
+
+        delta_u[id] = del_u - u[id];
+        error_u[id] = sqrt ( int_e2 / area );
+
+        u_normL2 += int_u2;
+        error_normL2 += int_e2;
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::refine_solution
+(
+    const IntVector id_fine,
+    const View < ScalarField<const double> > & u_coarse_interp,
+    View < ScalarField<double> > & u_fine
+)
+{
+    u_fine[id_fine] = u_coarse_interp[id_fine];
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+Heat<VAR, DIM, STN, AMR>::coarsen_solution
+(
+    const IntVector id_coarse,
+    const View < ScalarField<const double> > & u_fine_restr,
+    View < ScalarField<double> > & u_coarse
+)
+{
+    u_coarse[id_coarse] = u_fine_restr[id_coarse];
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template<VarType V>
+typename std::enable_if < V == CC, void >::type
+Heat<VAR, DIM, STN, AMR>::error_estimate_solution
+(
+    const IntVector id,
+    FDView < ScalarField<const double>, STN > & u,
+    View < ScalarField<int> > & refine_flag,
+    bool & refine_patch
+)
+{
+    bool refine = false;
+    auto grad = u.gradient ( id );
+    double err2 = 0;
+    for ( size_t d = 0; d < DIM; ++d )
+        err2 += grad[d] * grad[d];
+    refine = err2 > refine_threshold * refine_threshold;
+    refine_flag[id] = refine;
+    refine_patch |= refine;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template<VarType V>
+typename std::enable_if < V == NC, void >::type
+Heat<VAR, DIM, STN, AMR>::error_estimate_solution
+(
+    const IntVector id,
+    FDView < ScalarField<const double>, STN > & u,
+    View < ScalarField<int> > & refine_flag,
+    bool & refine_patch
+)
+{
+    bool refine = false;
+    auto grad = u.gradient ( id );
+    double err2 = 0;
+    for ( size_t d = 0; d < DIM; ++d )
+        err2 += grad[d] * grad[d];
+    refine = err2 > refine_threshold * refine_threshold;
+    if ( refine_flag.is_defined_at ( id ) ) refine_flag[id] = refine;
+    for ( size_t d = 0; d < DIM; ++d )
+    {
+        IntVector id0 ( id );
+        id0[d] -= 1;
+        if ( refine_flag.is_defined_at ( id0 ) ) refine_flag[id0] = refine;
+    }
+
+    refine_patch |= refine;
+}
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Applications_Heat_h
diff --git a/src/CCA/Components/PhaseField/Applications/sub.mk b/src/CCA/Components/PhaseField/Applications/sub.mk
index b3ccd418..51d03193 100644
--- a/src/CCA/Components/PhaseField/Applications/sub.mk
+++ b/src/CCA/Components/PhaseField/Applications/sub.mk
@@ -32,3 +32,4 @@ SRCDIR := CCA/Components/PhaseField/Applications
 SRCS += \
   $(SRCDIR)/ApplicationFactory.cc \
   $(SRCDIR)/PureMetal.cc \
+  $(SRCDIR)/Heat.cc \
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView-bld.sh b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView-bld.sh
index 2649d63d..4e84631b 100755
--- a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView-bld.sh
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView-bld.sh
@@ -27,12 +27,12 @@ VARs=(CC NC)
 STNs=(P5 P7)
 DIMs=(2 3)
 PPPs=(
-  "PureMetalProblem"
-  "PureMetalProblem"
+  "PureMetalProblem;HeatProblem"
+  "PureMetalProblem;HeatProblem"
 )
 NFFs=(
-  "4"
-  "4"
+  "4;1"
+  "4;1"
 )
 DIRs=(x y z)
 SIGNs=(minus plus)
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory-bld.sh b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory-bld.sh
index cede1b22..ad5b9f02 100755
--- a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory-bld.sh
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory-bld.sh
@@ -27,12 +27,12 @@ VARs=(CC NC)
 STNs=(P5 P7)
 DIMs=(2 3)
 PPPs=(
-  "PureMetalProblem"
-  "PureMetalProblem"
+  "PureMetalProblem;HeatProblem"
+  "PureMetalProblem;HeatProblem"
 )
 NFFs=(
-  "4"
-  "4"
+  "4;1"
+  "4;1"
 )
 DIRs=(x y z)
 SIGNs=(minus plus)
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemCCP5-bld.sh b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemCCP5-bld.sh
new file mode 100755
index 00000000..14c46c0c
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemCCP5-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/BCFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P5
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemCCP7-bld.sh b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemCCP7-bld.sh
new file mode 100755
index 00000000..cda63508
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemCCP7-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/BCFDView-bld.sh
+${SCRIPT} -p HeatProblem -v CC -s P7
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemNCP5-bld.sh b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemNCP5-bld.sh
new file mode 100755
index 00000000..cff5536a
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemNCP5-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/BCFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P5
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemNCP7-bld.sh b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemNCP7-bld.sh
new file mode 100755
index 00000000..55789978
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewHeatProblemNCP7-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/BCFDView-bld.sh
+${SCRIPT} -p HeatProblem -v NC -s P7
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/sub.mk b/src/CCA/Components/PhaseField/BoundaryConditions/sub.mk
index 6f1aa5e7..84e74571 100644
--- a/src/CCA/Components/PhaseField/BoundaryConditions/sub.mk
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/sub.mk
@@ -31,8 +31,17 @@ SRCDIR := CCA/Components/PhaseField/BoundaryConditions
 
 SRCS += \
   $(SRCDIR)/BCFDViewFactory-bld.cc \
+  $(SRCDIR)/BCFDViewHeatProblemCCP5-bld.cc \
+  $(SRCDIR)/BCFDViewHeatProblemCCP5-bld.cc \
+  $(SRCDIR)/BCFDViewHeatProblemCCP7-bld.cc \
+  $(SRCDIR)/BCFDViewHeatProblemNCP5-bld.cc \
+  $(SRCDIR)/BCFDViewHeatProblemNCP7-bld.cc \
 
 BLDDIR := $(SRCTOP)/$(SRCDIR)
 
 BLDSRCS += \
   $(BLDDIR)/BCFDViewFactory-bld.cc \
+  $(BLDDIR)/BCFDViewHeatProblemCCP5-bld.cc \
+  $(BLDDIR)/BCFDViewHeatProblemCCP7-bld.cc \
+  $(BLDDIR)/BCFDViewHeatProblemNCP5-bld.cc \
+  $(BLDDIR)/BCFDViewHeatProblemNCP7-bld.cc \
diff --git a/src/CCA/Components/Heat/blockrange_io.h b/src/CCA/Components/PhaseField/DataTypes/HeatProblem.h
similarity index 62%
rename from src/CCA/Components/Heat/blockrange_io.h
rename to src/CCA/Components/PhaseField/DataTypes/HeatProblem.h
index e431b00a..e23c8ab7 100644
--- a/src/CCA/Components/Heat/blockrange_io.h
+++ b/src/CCA/Components/PhaseField/DataTypes/HeatProblem.h
@@ -22,21 +22,30 @@
  * IN THE SOFTWARE.
  */
 
-#ifndef Packages_Uintah_CCA_Components_Heat_blockrange_io_h
-#define Packages_Uintah_CCA_Components_Heat_blockrange_io_h
+/**
+ * @file CCA/Components/PhaseField/DataTypes/HeatProblem.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
 
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataTypes_HeatProblem_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataTypes_HeatProblem_h
 
-#include <ostream>
-#include <Core/Grid/Variables/BlockRange.hpp>
+#include <CCA/Components/PhaseField/DataTypes/Problem.h>
+#include <CCA/Components/PhaseField/DataTypes/ScalarField.h>
 
 namespace Uintah
 {
-    
-inline std::ostream& operator << ( std::ostream& stream, const BlockRange& range )
+namespace PhaseField
 {
-    return stream << "(" << range.begin ( 0 ) << "," <<  range.begin ( 1 ) <<"," <<  range.begin ( 2 ) <<") - (" << range.end ( 0 ) <<"," << range.end ( 1 ) <<"," << range.end ( 2 ) << ")";
-}
 
-}
+/// Type of Problem used by Heat application
+template<VarType VAR, StnType STN> using HeatProblem = Problem < VAR, STN, ScalarField<const double> >;
+
+} // namespace PhaseFieldSTNSTN
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataTypes_HeatProblem_h
+
+
 
-#endif // Packages_Uintah_CCA_Components_Heat_blockrange_io_h
diff --git a/src/StandAlone/inputs/Heat/amr_nc_heat.ups b/src/StandAlone/inputs/Heat/amr_nc_heat.ups
deleted file mode 100644
index 18c5d6f5..00000000
--- a/src/StandAlone/inputs/Heat/amr_nc_heat.ups
+++ /dev/null
@@ -1,75 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>AMR NC Heat test</title>
-    </Meta>
-    <SimulationComponent type="fdheat" />
-<!--__________________________________-->
-    <FDHeat>
-        <delt>.0125</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <node_centered>true</node_centered>
-        <verbosity>0</verbosity>
-        <dimension>2</dimension>
-        <refine_threshold>1.e-02</refine_threshold>
-    </FDHeat>
-<!--__________________________________-->
-    <Time>
-        <maxTime>100.</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[  0.,  0., 0.]</lower>
-                <upper>[ 20., 20., 1.]</upper>
-                <patches>[2,2,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-        <BoundaryConditions>
-            <Face side="x-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="x+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-            <Face side="y-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="y+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-        </BoundaryConditions>
-    </Grid>
-<!--__________________________________-->
-    <AMR>
-        <Regridder type="Tiled">
-            <max_levels>3</max_levels>
-            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
-            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
-            <min_boundary_cells>[1,1,0]</min_boundary_cells>
-            <min_patch_size>[[4,4,1]]</min_patch_size>
-        </Regridder>
-   </AMR>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>amr_nc_heat.uda</filebase>
-        <outputTimestepInterval>8</outputTimestepInterval>
-        <save label="u" />
-        <!--save label="refineFlag" /-->
-    </DataArchiver>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/amr_nc_heat_3d.ups b/src/StandAlone/inputs/Heat/amr_nc_heat_3d.ups
deleted file mode 100644
index c013d440..00000000
--- a/src/StandAlone/inputs/Heat/amr_nc_heat_3d.ups
+++ /dev/null
@@ -1,85 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>AMR NC Heat 3D test</title>
-    </Meta>
-    <SimulationComponent type="fdheat" />
-<!--__________________________________-->
-    <FDHeat>
-        <delt>.01</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <node_centered>true</node_centered>
-        <verbosity>0</verbosity>
-        <dimension>3</dimension>
-        <refine_threshold>1.e-02</refine_threshold>
-    </FDHeat>
-<!--__________________________________-->
-    <Time>
-        <maxTime>100.</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[  0.,  0.,  0.]</lower>
-                <upper>[ 20., 20., 20.]</upper>
-                <patches>[2,2,2]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-        <BoundaryConditions>
-            <Face side="x-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="x+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-            <Face side="y-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="y+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-            <Face side="z-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="z+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-        </BoundaryConditions>
-    </Grid>
-<!--__________________________________-->
-    <AMR>
-        <Regridder type="Tiled">
-            <max_levels>3</max_levels>
-            <cell_refinement_ratio>[[2,2,2]]</cell_refinement_ratio>
-            <cell_stability_dilation>[2,2,2]</cell_stability_dilation>
-            <min_boundary_cells>[1,1,1]</min_boundary_cells>
-            <min_patch_size>[[4,4,4]]</min_patch_size>
-        </Regridder>
-   </AMR>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>amr_nc_heat_3d.uda</filebase>
-        <outputTimestepInterval>10</outputTimestepInterval>
-        <save label="u" />
-        <!--save label="refineFlag" /-->
-    </DataArchiver>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/cc_heat_3d_impl.ups b/src/StandAlone/inputs/Heat/cc_heat_3d_impl.ups
deleted file mode 100644
index 127fcf92..00000000
--- a/src/StandAlone/inputs/Heat/cc_heat_3d_impl.ups
+++ /dev/null
@@ -1,101 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>CC Heat test</title>
-    </Meta>
-    <SimulationComponent type="fdheat" />
-<!--__________________________________-->
-    <FDHeat>
-        <delt>1.</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <scheme>backward_euler</scheme>
-        <node_centered>false</node_centered>
-        <verbosity>0</verbosity>
-        <dimension>3</dimension>
-    </FDHeat>
-<!--__________________________________-->
-    <Time>
-        <maxTime>100.</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[  0.,  0.,  0.]</lower>
-                <upper>[ 20., 20., 20.]</upper>
-                <patches>[2,2,2]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-        <BoundaryConditions>
-            <Face side="x-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="x+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-            <Face side="y-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="y+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-            <Face side="z-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="z+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-        </BoundaryConditions>
-    </Grid>
-<!--__________________________________-->
-    <Solver type="hypre">
-        <Parameters variable="u">
-            <solver>smg</solver>
-            <preconditioner>diagonal</preconditioner>
-            <tolerance>1.e-10</tolerance>
-            <maxiterations>75</maxiterations>
-            <npre>1</npre>
-            <npost>1</npost>
-            <skip>0</skip>
-            <jump>0</jump>
-            <logging>0</logging>
-            <setupFrequency>1</setupFrequency>
-            <updateCoefFrequency>1</updateCoefFrequency>
-            <solveFrequency>1</solveFrequency>
-            <relax_type>1</relax_type><!-- 0=jacobi,1=weighted jacobi,2=rb symmetric,3=rb non-symmetric --> 
-            <outputEquations>false</outputEquations>
-        </Parameters>
-    </Solver>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_heat_3d_impl.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="u" />
-        <!--save label="Ap" /-->
-        <!--save label="Ae" /-->
-        <!--save label="Aw" /-->
-        <!--save label="As" /-->
-        <!--save label="An" /-->
-        <!--save label="Ab" /-->
-        <!--save label="At" /-->
-        <!--save label="b" /-->
-    </DataArchiver>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/cc_heat_impl.ups b/src/StandAlone/inputs/Heat/cc_heat_impl.ups
deleted file mode 100644
index 5f1047f8..00000000
--- a/src/StandAlone/inputs/Heat/cc_heat_impl.ups
+++ /dev/null
@@ -1,91 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>CC Heat test</title>
-    </Meta>
-    <SimulationComponent type="fdheat" />
-<!--__________________________________-->
-    <FDHeat>
-        <delt>1.</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <scheme>backward_euler</scheme>
-        <node_centered>false</node_centered>
-        <verbosity>0</verbosity>
-        <dimension>2</dimension>
-    </FDHeat>
-<!--__________________________________-->
-    <Time>
-        <maxTime>100.</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[  0.,  0., 0.]</lower>
-                <upper>[ 20., 20., 1.]</upper>
-                <patches>[2,2,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-        <BoundaryConditions>
-            <Face side="x+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-            <Face side="x-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-            <Face side="y+">
-                <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
-                </BCType>
-            </Face>
-            <Face side="y-">
-                <BCType id="0" label="u" var="Neumann">
-                    <value>0.</value>
-                </BCType>
-            </Face>
-        </BoundaryConditions>
-    </Grid>
-<!--__________________________________-->
-    <Solver type="hypre">
-        <Parameters variable="u">
-            <solver>smg</solver>
-            <preconditioner>diagonal</preconditioner>
-            <tolerance>1.e-10</tolerance>
-            <maxiterations>75</maxiterations>
-            <npre>1</npre>
-            <npost>1</npost>
-            <skip>0</skip>
-            <jump>0</jump>
-            <logging>0</logging>
-            <setupFrequency>1</setupFrequency>
-            <updateCoefFrequency>1</updateCoefFrequency>
-            <solveFrequency>1</solveFrequency>
-            <relax_type>1</relax_type><!-- 0=jacobi,1=weighted jacobi,2=rb symmetric,3=rb non-symmetric --> 
-            <outputEquations>false</outputEquations>
-        </Parameters>
-    </Solver>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_heat_impl.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="u" />
-        <!--save label="Ap" /-->
-        <!--save label="Ae" /-->
-        <!--save label="Aw" /-->
-        <!--save label="As" /-->
-        <!--save label="An" /-->
-        <!--save label="Ab" /-->
-        <!--save label="At" /-->
-        <!--save label="b" /-->
-    </DataArchiver>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/tipinfo_PureMetal.m b/src/StandAlone/inputs/Heat/tipinfo_PureMetal.m
deleted file mode 100644
index 1c13f5d3..00000000
--- a/src/StandAlone/inputs/Heat/tipinfo_PureMetal.m
+++ /dev/null
@@ -1,347 +0,0 @@
-#! /usr/bin/octave -qf
-
-clear all;
-close all;
-format short e;
-
-global udaFile utilPath makePlot outputFile;
-
-function res = check_input(argv)
-  res = length(argv)~=0;
-end
-
-function res = check_utilities()
-  global utilPath
-  res = ~(unix([utilPath 'puda &> /dev/null'])>1 || unix([utilPath 'lineextract &> /dev/null'])>1);
-end
-
-function [] = disp_usage()
-  printf('tipinfo_PureMetal.m <options>\n')                                                                    
-  printf('options:\n')                                                                                       
-  printf('  -uda  <udaFileName>  - name of the uda file \n') 
-  printf('  -path <utilitesPath> - specify path to Uintah utilites \n')                                                        
-  printf('  -plot <true, false>  - produce a plot \n')                                                        
-  printf('  -o    <fname>        - Dump the output to a file\n')                                    
-end 
-
-function [] = disp_utilities_error()
-  disp('Cannot execute the Uintah utilites puda, lineextract');
-  disp('  a) make sure you are in the right directory or the specified <utilitesPath> is correct, and');
-  disp('  b) the utilities (puda/lineextract) have been compiled');
-end
-
-function [] = parse_input(argv)
-  global udaFile utilPath makePlot outputFile
-  udaFile    = '*.uda';
-  utilPath   = './';
-  makePlot   = true;
-  outputFile = 'tipinfo';
-
-  arg_list = argv ();
-  for i = 1:2:nargin
-    option    = sprintf("%s",arg_list{i} );
-    opt_value = sprintf("%s",arg_list{++i});
-
-    if ( strcmp(option,"-uda") )   
-      udaFile = opt_value;
-    elseif (strcmp(option,"-path") )
-      utilPath = opt_value;
-    elseif (strcmp(option,"-plot") )
-      makePlot = opt_value;
-    elseif (strcmp(option,"-o") )  
-      outputFile = opt_value;    
-    end                                      
-  end
-
-  if utilPath(end) != '/' 
-    utilPath = [utilPath '/'];
-  end
-end
-
-function [TS, T] = get_timesteps()
-  global udaFile utilPath
-  c0 = sprintf('%spuda -timesteps %s 2> /dev/null | grep "^[0-9]\\+:" > tmp', utilPath, udaFile); s = unix(c0);
-  [s,r0] = unix('cut -f 1 -d":" tmp');
-  [s,r1] = unix('cut -f 2 -d":" tmp');
-  s = unix('rm tmp');
-  TS = str2num(r0);
-  T = str2num(r1);
-end
-
-function [DX, N] = get_gridstats()
-  global udaFile utilPath
-  c0 = sprintf('%spuda -gridstats %s > tmp 2> /dev/null', utilPath, udaFile); s = unix(c0);
-  [s,r0] = unix('grep -m1 dx: tmp | cut -f 2 -d":"');
-  [s,r1] = unix('grep -m1 -w "Total Number of Cells" tmp | tr -d [:alpha:] | cut -f 2 -d":"');
-  s = unix('rm tmp');
-  DX = str2num(r0);
-  N = str2num(r1);
-end
-
-function [x, y, z] = line_extract(i0, i1, j, k)
-  global udaFile utilPath
-  c0 = sprintf('%slineextract -v phi -timestep %d -istart %d %d 0 -iend %d %d 0 -nodeCoords -uda %s 2>/dev/null | grep "^-\\?[0-9]\\+"', utilPath, k-1, i0, j, i1, j, udaFile);
-  [s, r] = unix(c0);
-  data = str2num(r);
-  x = data(:,1);
-  y = data(:,2);
-  z = data(:,4);
-end
-
-function [x, y, z] = vert_line_extract(j0, j1, i, k)
-  global udaFile utilPath
-  c0 = sprintf('%slineextract -v phi -timestep %d -istart %d %d 0 -iend %d %d 0 -nodeCoords -uda %s 2>/dev/null | grep "^-\\?[0-9]\\+"', utilPath, k-1, i, j0, i, j1, udaFile);
-  [s, r] = unix(c0);
-  data = str2num(r);
-  x = data(:,1);
-  y = data(:,2);
-  z = data(:,4);
-end
-
-function [X, Y, Z] = get_interface_neighbour(j, k)
-  global iRange
-  [x0, y0, z0] = line_extract(iRange(1), iRange(2), j, k);
-  intf = find(z0(2:end).*z0(1:end-1)<=0,1);
-  if (-z0(intf+1)<z0(intf))
-    iRange(1) += intf-2;
-    i0 = intf+(-1:3);
-    x0 = x0(i0);
-    y0 = y0(i0);
-    z0 = z0(i0);
-  else
-    iRange(1) += intf-3;
-    i0 = intf+(-2:2);
-    x0 = x0(i0);
-    y0 = y0(i0);
-    z0 = z0(i0);
-  end
-  [x1, y1, z1] = line_extract(iRange(1), iRange(1)+4, j+1, k);
-  [x2, y2, z2] = line_extract(iRange(1), iRange(1)+4, j+2, k);
-  X = [x0 x1 x2];
-  Y = [y0 y1 y2];
-  Z = [z0 z1 z2];
-end
-
-function [x, y] = compute_interface_vert_position(X, Y, Z)
-  P = polyfit(Y, Z, 4);
-  rts = roots(P);
-  rts = rts(imag(rts)==0);
-  x = X(1);
-  y = rts(find(Y(1)<=rts & rts<=Y(5),1));
-end
-
-function [X, Y, Z] = get_interface_vert_neighbour(i, k)
-  global jRange
-  [x0, y0, z0] = vert_line_extract(jRange(1), jRange(2), i, k);
-  intf = find(z0(2:end).*z0(1:end-1)<=0,1);
-  j0 = intf-3;
-  if (-z0(intf+1)<z0(intf))
-    j0 += 1;
-  end
-  if (j0<0)
-    j0 = 0;
-  end
-  jj = j0 + (1:5);
-  jRange(1) += intf-2;
-  X = x0(jj);
-  Y = y0(jj);
-  Z = z0(jj);
-end
-
-function [x, y] = get_arm(k, N, DX, p)
-% figure(1);
-  global jRange
-  i = N(1)/2 + floor(p/DX(1));
-  jRange = [N(2)/2 N(2)];
-  x = []; y = [];
-  xi = p; yi = 0;
-  do
-    x = [x, xi];
-    y = [y, yi];
-    [X, Y, Z] = get_interface_vert_neighbour(i, k);    
-%   plot (X,Y,'ko')
-    [xi, yi] = compute_interface_vert_position(X, Y, Z);
-    i -= 1;
-  until ( yi<=y(end) ) 
-end
-
-function [x, y] = rm_tip(x, y)
-  ind = [(y(2:end)-y(1:end-1))./(x(1:end-1)-x(2:end)) 0] <= 1;
-  x = x(ind);
-  y = y(ind);
-end
-
-function [p, px] = compute_interface_position(X, Z)
-% figure(2); 
-% plot3(X,0*X,Z, 'ko'); hold on
-% view(60,60)
-  P = polyfit(X(:,1), Z(:,1), 4);
-% xx = linspace(X(1,1),X(5,1),100);
-% plot3(xx,0*xx,polyval(P,xx),'m-')  
-  rts = roots(P);
-  rts = rts(imag(rts)==0);
-  p = rts(find(X(2,1)<=rts & rts<=X(4,1),1));
-% plot3(p,0,0,'k*')
-  px = polyval(polyder(P),p);
-% plot3(xx,0*xx,px*(xx-p),'g-')
-end
-
-function kloc = compute_interface_local_curvature(X, Y, Z, p, px)
-% figure(1);
-% plot(p,0,'k*')
-  P0 = zeros(5,3);
-% figure(2);
-% mesh(X, Y, Z);
-% mesh(X, -Y, Z);
-% axis square
-% zlim([-1,1])
-% yy = linspace(-Y(1,end),Y(1,end),100);
-  for i=1:5  
-    P0(i,:) = polyfit(Y(i,:).^2,Z(i,:),2);
-%   plot3(X(i,1)+0*yy,yy,polyval(P0(i,:),yy.^2),'c-')
-  end;
-% figure(3)
-% plot(X(:,1),2*P0(:,2),'ko'); hold on;
-% xx = linspace(X(1,1),X(5,1),100);
-  P1 = polyfit(X(:,1),2*P0(:,2),4);
-% plot(xx,polyval(P1,xx),'b-');  
-  pyy = polyval(P1,p);
-% plot(p,pyy,'m*')
-  kloc = -pyy/px^2;
-% figure(2)
-% plot3(p+0*yy,yy,pyy*yy.^2,'m-')
-% plot3(p-kloc/2*yy.^2,yy,0*yy,'g-') 
-% hidden('off')
-% yy = linspace(0,5,100);
-% xlim([0,2*p])
-% figure(1);
-% yy = linspace(0,5,100);
-% plot (p-kloc/2*yy.^2,yy,'g:') 
-end
-
-function kpar = compute_interface_parabolic_curvature(k, N, DX, p)
-% figure(1);
-  [x, y] = get_arm(k, N, DX, p);
-% plot(x, y, 'r-');
-  [x, y] = rm_tip(x, y);
-  P = polyfit(y.^2, x, 1);
-  kpar = 2*P(1);
-% plot(x, y, 'b*');
-% yy = linspace(0,5,100);
-% plot(polyval(P,yy.^2),yy,'k:')
-% xlim([0 2*P(2)])
-% axis equal
-% pause
-end;
-
-function [P, V, Kloc, Kpar] = compute_interface_info(T, N, DX)
-  global udaFile utilPath iRange;
-
-  P = zeros(length(T),1);
-  V = zeros(length(T),1);
-  Kloc = zeros(length(T),1);
-  Kpar = zeros(length(T),1);
-
-  iRange = [N(1)/2 N(1)];
-  j = N(2)/2;
- 
-  for k=1:length(T)
-    progress = round(100*k/length(T))
-%   figure(1); clf; hold on;
-    [X, Y, Z] = get_interface_neighbour(j, k);
-%   plot (X,Y,'ro')
-    [p, px] = compute_interface_position(X, Z);
-%   plot(p,0,'b*')
-    v = NaN;
-    if(k>1)
-      v = (p-P(k-1))/(T(k)-T(k-1));
-    end
-    kloc = compute_interface_local_curvature(X, Y, Z, p, px);
-    kpar = compute_interface_parabolic_curvature(k, N, DX, p);
-    P(k) = p;
-    V(k) = v;
-    Kloc(k) = kloc;
-    Kpar(k) = kpar;
-  end
-end
-
-function [] = write_interface_info(T, P, V, Kloc, Kpar)
-  global outputFile
-  if (length(outputFile) > 0)
-    fid = fopen(outputFile, 'w');
-    for k = 1:length(T)
-      fprintf(fid,'%g %g %g %g %g \n', T(k), P(k), V(k), Kloc(k), Kpar(k));
-    end
-    fprintf(fid,'\n');
-    fclose(fid);
-  end
-end
-
-function [] = plot_interface_info(T, P, V, Kloc, Kpar);
-  global outputFile
-  figure
-  plot(T, P);
-  xlabel('t')
-  ylabel('x')
-  title('interface position');
-  grid on;
-  fname = sprintf([outputFile '_p.eps']);
-  print ( fname, '-deps');
-
-  figure
-  plot(T, V);
-  xlabel('t')
-  ylabel('v')
-  title('interface velocity');
-  grid on;
-
-  fname = sprintf([outputFile  '_v.eps']);
-  print ( fname, '-deps');
-
-  figure
-  plot(T, Kloc);
-  xlabel('t')
-  ylabel('{{\kappa}_{loc}}')
-  title('interface local curvature');
-  grid on;
-
-  fname = sprintf([outputFile  '_kloc.eps']);
-  print ( fname, '-deps');
-
-  figure
-  plot(T, Kpar);
-  xlabel('t')
-  ylabel('{{\kappa}_{par}}')
-  title('interface parabolic curvature');
-  grid on;
-
-  fname = sprintf([outputFile  '_kpar.eps']);
-  print ( fname, '-deps');
-end
-  
-%________________________________            
-
-if (~check_input(argv))
-  disp_usage();
-  exit(-1);
-end
-
-parse_input(argv);
-
-if (~check_utilities())
-  disp_utilities_error();
-  exit(-1);
-end
-
-[TS, T] = get_timesteps();
-
-[DX, N] = get_gridstats();
-
-[P, V, Kloc, Kpar] = compute_interface_info(T, N, DX);
-
-write_interface_info(T, P, V, Kloc, Kpar);
-
-if(makePlot)
-  plot_interface_info(T, P, V, Kloc, Kpar);
-end
-  
diff --git a/src/StandAlone/inputs/Heat/nc_heat.ups b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_2d.ups
similarity index 60%
rename from src/StandAlone/inputs/Heat/nc_heat.ups
rename to src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_2d.ups
index 49457ba4..cc9ca024 100644
--- a/src/StandAlone/inputs/Heat/nc_heat.ups
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_2d.ups
@@ -1,18 +1,17 @@
 <Uintah_specification>
     <Meta>
-        <title>NC Heat test</title>
+        <title>heat_bc_test_cc_d2_p5_fe</title>
     </Meta>
-    <SimulationComponent type="fdheat" />
+    <SimulationComponent type="phasefield" />
 <!--__________________________________-->
-    <FDHeat>
+    <PhaseField type="heat">
+        <var>cc</var>
+        <dim>2</dim>
         <delt>.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <node_centered>true</node_centered>
+        <alpha>0.19635</alpha>
+        <test>true</test>
         <verbosity>0</verbosity>
-        <dimension>2</dimension>
-    </FDHeat>
+    </PhaseField>
 <!--__________________________________-->
     <Time>
         <maxTime>100.</maxTime>
@@ -26,8 +25,8 @@
         <Level>
             <Box label="1">
                 <lower>[  0.,  0., 0.]</lower>
-                <upper>[ 20., 20., 1.]</upper>
-                <patches>[2,2,1]</patches>
+                <upper>[ 32., 32., 1.]</upper>
+                <patches>[4,4,1]</patches>
             </Box>
             <spacing>[1.,1.,1.]</spacing>
         </Level>
@@ -39,7 +38,7 @@
             </Face>
             <Face side="x+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="y-">
@@ -49,15 +48,30 @@
             </Face>
             <Face side="y+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
         </BoundaryConditions>
     </Grid>
 <!--__________________________________-->
     <DataArchiver>
-        <filebase>nc_heat.uda</filebase>
+        <filebase>heat_bc_test_cc_d2_p5_fe.uda</filebase>
         <outputTimestepInterval>1</outputTimestepInterval>
         <save label="u" />
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_u" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
     </DataArchiver>
 </Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/amr_cc_heat_impl.ups b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_2d_amr.ups
similarity index 55%
rename from src/StandAlone/inputs/Heat/amr_cc_heat_impl.ups
rename to src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_2d_amr.ups
index 2b0588dd..71dc8235 100644
--- a/src/StandAlone/inputs/Heat/amr_cc_heat_impl.ups
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_2d_amr.ups
@@ -1,20 +1,18 @@
 <Uintah_specification>
     <Meta>
-        <title>AMR CC Heat test</title>
+        <title>heat_bc_test_cc_d2_p5_fe_amr</title>
     </Meta>
-    <SimulationComponent type="fdheat" />
+    <SimulationComponent type="phasefield" />
 <!--__________________________________-->
-    <FDHeat>
-        <delt>1.</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <scheme>backward_euler</scheme>
-        <node_centered>false</node_centered>
+    <PhaseField type="heat">
+        <var>cc</var>
+        <dim>2</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
         <verbosity>0</verbosity>
-        <dimension>2</dimension>
-        <refine_threshold>1.e-02</refine_threshold>
-    </FDHeat>
+        <refine_threshold>0.3</refine_threshold>
+    </PhaseField>
 <!--__________________________________-->
     <Time>
         <maxTime>100.</maxTime>
@@ -28,10 +26,10 @@
         <Level>
             <Box label="1">
                 <lower>[  0.,  0., 0.]</lower>
-                <upper>[ 20., 20., 1.]</upper>
-                <patches>[2,2,1]</patches>
+                <upper>[ 32., 32., 1.]</upper>
+                <patches>[4,4,1]</patches>
             </Box>
-            <spacing>[1.,1.,1.]</spacing>
+            <spacing>[2.,2.,1.]</spacing>
         </Level>
         <BoundaryConditions>
             <Face side="x-">
@@ -41,7 +39,7 @@
             </Face>
             <Face side="x+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="y-">
@@ -51,7 +49,7 @@
             </Face>
             <Face side="y+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
         </BoundaryConditions>
@@ -59,37 +57,39 @@
 <!--__________________________________-->
     <AMR>
         <Regridder type="Tiled">
+            <adaptive>true</adaptive>
             <max_levels>2</max_levels>
             <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
             <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
             <min_boundary_cells>[1,1,0]</min_boundary_cells>
             <min_patch_size>[[4,4,1]]</min_patch_size>
         </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="u" var="FC1" />
+        </FineCoarseInterfaces>
     </AMR>
 <!--__________________________________-->
-    <Solver type="hypreamr">
-        <Parameters variable="u">
-            <solver>amg</solver>
-            <preconditioner>diagonal</preconditioner>
-            <tolerance>1.e-10</tolerance>
-            <maxiterations>75</maxiterations>
-            <npre>1</npre>
-            <npost>1</npost>
-            <skip>0</skip>
-            <jump>0</jump>
-            <logging>0</logging>
-            <setupFrequency>1</setupFrequency>
-            <updateCoefFrequency>1</updateCoefFrequency>
-            <solveFrequency>1</solveFrequency>
-            <relax_type>1</relax_type><!-- 0=jacobi,1=weighted jacobi,2=rb symmetric,3=rb non-symmetric --> 
-            <outputEquations>false</outputEquations>
-        </Parameters>
-    </Solver>
-<!--__________________________________-->
     <DataArchiver>
-        <filebase>amr_cc_heat_imp.uda</filebase>
+        <filebase>heat_bc_test_cc_d2_p5_fe_amr.uda</filebase>
         <outputTimestepInterval>1</outputTimestepInterval>
         <save label="u" />
-        <!--save label="refineFlag" /-->
+        <save label="refineFlag" />
+        <save label="error_u" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+        <!-- if defined PhaseField_Heat_DBG_DERIVATIVES -->
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <!-- end if defined -->
     </DataArchiver>
 </Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/nc_heat_3d.ups b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_3d.ups
similarity index 61%
rename from src/StandAlone/inputs/Heat/nc_heat_3d.ups
rename to src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_3d.ups
index 82174dfb..85d5b8c3 100644
--- a/src/StandAlone/inputs/Heat/nc_heat_3d.ups
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_3d.ups
@@ -1,18 +1,17 @@
 <Uintah_specification>
     <Meta>
-        <title>NC Heat 3D test</title>
+        <title>heat_bc_test_cc_d3_p7_fe</title>
     </Meta>
-    <SimulationComponent type="fdheat" />
+    <SimulationComponent type="phasefield" />
 <!--__________________________________-->
-    <FDHeat>
+    <PhaseField type="heat">
+        <var>cc</var>
+        <dim>3</dim>
         <delt>.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <node_centered>true</node_centered>
+        <alpha>0.19635</alpha>
+        <test>true</test>
         <verbosity>0</verbosity>
-        <dimension>3</dimension>
-    </FDHeat>
+    </PhaseField>
 <!--__________________________________-->
     <Time>
         <maxTime>100.</maxTime>
@@ -26,8 +25,8 @@
         <Level>
             <Box label="1">
                 <lower>[  0.,  0.,  0.]</lower>
-                <upper>[ 20., 20., 20.]</upper>
-                <patches>[2,2,2]</patches>
+                <upper>[ 32., 32., 32.]</upper>
+                <patches>[4,4,4]</patches>
             </Box>
             <spacing>[1.,1.,1.]</spacing>
         </Level>
@@ -39,7 +38,7 @@
             </Face>
             <Face side="x+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="y-">
@@ -49,7 +48,7 @@
             </Face>
             <Face side="y+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="z-">
@@ -59,15 +58,34 @@
             </Face>
             <Face side="z+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
         </BoundaryConditions>
     </Grid>
 <!--__________________________________-->
     <DataArchiver>
-        <filebase>nc_heat_3d.uda</filebase>
+        <filebase>heat_bc_test_cc_d3_p7_fe.uda</filebase>
         <outputTimestepInterval>1</outputTimestepInterval>
         <save label="u" />
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uz" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="uzz" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_u" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uz" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_uzz" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
     </DataArchiver>
 </Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/amr_cc_heat_3d_impl.ups b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_3d_amr.ups
similarity index 53%
rename from src/StandAlone/inputs/Heat/amr_cc_heat_3d_impl.ups
rename to src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_3d_amr.ups
index a185eab6..228c4c42 100644
--- a/src/StandAlone/inputs/Heat/amr_cc_heat_3d_impl.ups
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_cc_3d_amr.ups
@@ -1,20 +1,18 @@
 <Uintah_specification>
     <Meta>
-        <title>AMR CC Heat test</title>
+        <title>heat_bc_test_cc_d3_p7_fe_amr</title>
     </Meta>
-    <SimulationComponent type="fdheat" />
+    <SimulationComponent type="phasefield" />
 <!--__________________________________-->
-    <FDHeat>
-        <delt>1.</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <scheme>backward_euler</scheme>
-        <node_centered>false</node_centered>
+    <PhaseField type="heat">
+        <var>cc</var>
+        <dim>3</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
         <verbosity>0</verbosity>
-        <dimension>3</dimension>
-        <refine_threshold>1.e-02</refine_threshold>
-    </FDHeat>
+        <refine_threshold>0.03</refine_threshold>
+    </PhaseField>
 <!--__________________________________-->
     <Time>
         <maxTime>100.</maxTime>
@@ -27,11 +25,11 @@
     <Grid>
         <Level>
             <Box label="1">
-                <lower>[  0.,  0.,  0.]</lower>
-                <upper>[ 20., 20., 20.]</upper>
-                <patches>[2,2,2]</patches>
+                <lower>[  0.,  0., 0.]</lower>
+                <upper>[ 32., 32., 32.]</upper>
+                <patches>[4,4,4]</patches>
             </Box>
-            <spacing>[1.,1.,1.]</spacing>
+            <spacing>[2.,2.,2.]</spacing>
         </Level>
         <BoundaryConditions>
             <Face side="x-">
@@ -41,7 +39,7 @@
             </Face>
             <Face side="x+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="y-">
@@ -51,7 +49,7 @@
             </Face>
             <Face side="y+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="z-">
@@ -61,7 +59,7 @@
             </Face>
             <Face side="z+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
         </BoundaryConditions>
@@ -69,45 +67,43 @@
 <!--__________________________________-->
     <AMR>
         <Regridder type="Tiled">
+            <adaptive>true</adaptive>
             <max_levels>2</max_levels>
             <cell_refinement_ratio>[[2,2,2]]</cell_refinement_ratio>
             <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
             <min_boundary_cells>[1,1,1]</min_boundary_cells>
             <min_patch_size>[[4,4,4]]</min_patch_size>
         </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="u" var="FC1" />
+        </FineCoarseInterfaces>
     </AMR>
 <!--__________________________________-->
-    <Solver type="hypreamr">
-        <Parameters variable="u">
-            <solver>amg</solver>
-            <preconditioner>diagonal</preconditioner>
-            <tolerance>1.e-10</tolerance>
-            <maxiterations>75</maxiterations>
-            <npre>1</npre>
-            <npost>1</npost>
-            <skip>0</skip>
-            <jump>0</jump>
-            <logging>0</logging>
-            <setupFrequency>1</setupFrequency>
-            <updateCoefFrequency>1</updateCoefFrequency>
-            <solveFrequency>1</solveFrequency>
-            <relax_type>1</relax_type><!-- 0=jacobi,1=weighted jacobi,2=rb symmetric,3=rb non-symmetric --> 
-            <outputEquations>false</outputEquations>
-        </Parameters>
-    </Solver>
-<!--__________________________________-->
     <DataArchiver>
-        <filebase>amr_cc_heat_3d_impl.uda</filebase>
+        <filebase>heat_bc_test_cc_d3_p7_fe_amr.uda</filebase>
         <outputTimestepInterval>1</outputTimestepInterval>
         <save label="u" />
-        <!--save label="refineFlag" /-->
-        <!--save label="Ap" /-->
-        <!--save label="Ae" /-->
-        <!--save label="Aw" /-->
-        <!--save label="As" /-->
-        <!--save label="An" /-->
-        <!--save label="Ab" /-->
-        <!--save label="At" /-->
-        <!--save label="b" /-->
+        <save label="refineFlag" />
+        <save label="error_u" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+        <!-- if defined PhaseField_Heat_DBG_DERIVATIVES -->
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uz" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="uzz" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uz" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_uzz" />
+        <!-- end if defined -->
     </DataArchiver>
 </Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/cc_heat.ups b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_2d.ups
similarity index 60%
rename from src/StandAlone/inputs/Heat/cc_heat.ups
rename to src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_2d.ups
index c7e10dbe..9dc8f021 100644
--- a/src/StandAlone/inputs/Heat/cc_heat.ups
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_2d.ups
@@ -1,18 +1,17 @@
 <Uintah_specification>
     <Meta>
-        <title>CC Heat test</title>
+        <title>heat_bc_test_nc_d2_p5_fe</title>
     </Meta>
-    <SimulationComponent type="fdheat" />
+    <SimulationComponent type="phasefield" />
 <!--__________________________________-->
-    <FDHeat>
+    <PhaseField type="heat">
+        <var>nc</var>
+        <dim>2</dim>
         <delt>.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <node_centered>false</node_centered>
+        <alpha>0.19635</alpha>
+        <test>true</test>
         <verbosity>0</verbosity>
-        <dimension>2</dimension>
-    </FDHeat>
+    </PhaseField>
 <!--__________________________________-->
     <Time>
         <maxTime>100.</maxTime>
@@ -26,8 +25,8 @@
         <Level>
             <Box label="1">
                 <lower>[  0.,  0., 0.]</lower>
-                <upper>[ 20., 20., 1.]</upper>
-                <patches>[2,2,1]</patches>
+                <upper>[ 32., 32., 1.]</upper>
+                <patches>[4,4,1]</patches>
             </Box>
             <spacing>[1.,1.,1.]</spacing>
         </Level>
@@ -39,7 +38,7 @@
             </Face>
             <Face side="x+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="y-">
@@ -49,15 +48,30 @@
             </Face>
             <Face side="y+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
         </BoundaryConditions>
     </Grid>
 <!--__________________________________-->
     <DataArchiver>
-        <filebase>cc_heat.uda</filebase>
+        <filebase>heat_bc_test_nc_d2_p5_fe.uda</filebase>
         <outputTimestepInterval>1</outputTimestepInterval>
         <save label="u" />
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_u" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
     </DataArchiver>
 </Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/amr_cc_heat.ups b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_2d_amr.ups
similarity index 54%
rename from src/StandAlone/inputs/Heat/amr_cc_heat.ups
rename to src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_2d_amr.ups
index 55722b1b..51b6c482 100644
--- a/src/StandAlone/inputs/Heat/amr_cc_heat.ups
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_2d_amr.ups
@@ -1,19 +1,18 @@
 <Uintah_specification>
     <Meta>
-        <title>AMR CC Heat test</title>
+        <title>heat_bc_test_nc_d2_p5_fe_amr</title>
     </Meta>
-    <SimulationComponent type="fdheat" />
+    <SimulationComponent type="phasefield" />
 <!--__________________________________-->
-    <FDHeat>
-        <delt>.0125</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <node_centered>false</node_centered>
+    <PhaseField type="heat">
+        <var>nc</var>
+        <dim>2</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
         <verbosity>0</verbosity>
-        <dimension>2</dimension>
-        <refine_threshold>1.e-02</refine_threshold>
-    </FDHeat>
+        <refine_threshold>0.03</refine_threshold>
+    </PhaseField>
 <!--__________________________________-->
     <Time>
         <maxTime>100.</maxTime>
@@ -27,10 +26,10 @@
         <Level>
             <Box label="1">
                 <lower>[  0.,  0., 0.]</lower>
-                <upper>[ 20., 20., 1.]</upper>
-                <patches>[2,2,1]</patches>
+                <upper>[ 32., 32., 1.]</upper>
+                <patches>[4,4,1]</patches>
             </Box>
-            <spacing>[1.,1.,1.]</spacing>
+            <spacing>[2.,2.,1.]</spacing>
         </Level>
         <BoundaryConditions>
             <Face side="x-">
@@ -40,7 +39,7 @@
             </Face>
             <Face side="x+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="y-">
@@ -50,7 +49,7 @@
             </Face>
             <Face side="y+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
         </BoundaryConditions>
@@ -58,18 +57,39 @@
 <!--__________________________________-->
     <AMR>
         <Regridder type="Tiled">
-            <max_levels>3</max_levels>
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
             <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
             <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
             <min_boundary_cells>[1,1,0]</min_boundary_cells>
             <min_patch_size>[[4,4,1]]</min_patch_size>
         </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="u" var="FC1" />
+        </FineCoarseInterfaces>
     </AMR>
 <!--__________________________________-->
     <DataArchiver>
-        <filebase>amr_cc_heat.uda</filebase>
-        <outputTimestepInterval>8</outputTimestepInterval>
+        <filebase>heat_bc_test_nc_d2_p5_fe_amr.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
         <save label="u" />
-        <!--save label="refineFlag" /-->
+        <save label="refineFlag" />
+        <save label="error_u" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+        <!-- if defined PhaseField_Heat_DBG_DERIVATIVES -->
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <!-- end if defined -->
     </DataArchiver>
 </Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/cc_heat_3d.ups b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_3d.ups
similarity index 62%
rename from src/StandAlone/inputs/Heat/cc_heat_3d.ups
rename to src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_3d.ups
index f1d04d73..2cc2a169 100644
--- a/src/StandAlone/inputs/Heat/cc_heat_3d.ups
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_3d.ups
@@ -1,18 +1,17 @@
 <Uintah_specification>
     <Meta>
-        <title>CC Heat 3D test</title>
+        <title>heat_bc_test_nc_d3_p7_fe</title>
     </Meta>
-    <SimulationComponent type="fdheat" />
+    <SimulationComponent type="phasefield" />
 <!--__________________________________-->
-    <FDHeat>
+    <PhaseField type="heat">
+        <var>nc</var>
+        <dim>3</dim>
         <delt>.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <node_centered>false</node_centered>
+        <alpha>0.19635</alpha>
+        <test>true</test>
         <verbosity>0</verbosity>
-        <dimension>3</dimension>
-    </FDHeat>
+    </PhaseField>
 <!--__________________________________-->
     <Time>
         <maxTime>100.</maxTime>
@@ -26,8 +25,8 @@
         <Level>
             <Box label="1">
                 <lower>[  0.,  0.,  0.]</lower>
-                <upper>[ 20., 20., 20.]</upper>
-                <patches>[2,2,2]</patches>
+                <upper>[ 32., 32., 32.]</upper>
+                <patches>[4,4,4]</patches>
             </Box>
             <spacing>[1.,1.,1.]</spacing>
         </Level>
@@ -39,7 +38,7 @@
             </Face>
             <Face side="x+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="y-">
@@ -49,7 +48,7 @@
             </Face>
             <Face side="y+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="z-">
@@ -59,15 +58,34 @@
             </Face>
             <Face side="z+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
         </BoundaryConditions>
     </Grid>
 <!--__________________________________-->
     <DataArchiver>
-        <filebase>cc_heat_3d.uda</filebase>
+        <filebase>heat_bc_test_nc_d3_p7_fe.uda</filebase>
         <outputTimestepInterval>1</outputTimestepInterval>
         <save label="u" />
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uz" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="uzz" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_u" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uz" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_uzz" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
     </DataArchiver>
 </Uintah_specification>
diff --git a/src/StandAlone/inputs/Heat/amr_cc_heat_3d.ups b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_3d_amr.ups
similarity index 53%
rename from src/StandAlone/inputs/Heat/amr_cc_heat_3d.ups
rename to src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_3d_amr.ups
index 745d6828..cb2c1c29 100644
--- a/src/StandAlone/inputs/Heat/amr_cc_heat_3d.ups
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_bc_test_nc_3d_amr.ups
@@ -1,19 +1,18 @@
 <Uintah_specification>
     <Meta>
-        <title>AMR CC Heat 3D test</title>
+        <title>heat_bc_test_nc_d3_p7_fe_amr</title>
     </Meta>
-    <SimulationComponent type="fdheat" />
+    <SimulationComponent type="phasefield" />
 <!--__________________________________-->
-    <FDHeat>
-        <delt>.01</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <gamma>1.</gamma>
-        <node_centered>false</node_centered>
+    <PhaseField type="heat">
+        <var>nc</var>
+        <dim>3</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
         <verbosity>0</verbosity>
-        <dimension>3</dimension>
-        <refine_threshold>1.e-02</refine_threshold>
-    </FDHeat>
+        <refine_threshold>0.03</refine_threshold>
+    </PhaseField>
 <!--__________________________________-->
     <Time>
         <maxTime>100.</maxTime>
@@ -26,11 +25,11 @@
     <Grid>
         <Level>
             <Box label="1">
-                <lower>[  0.,  0.,  0.]</lower>
-                <upper>[ 20., 20., 20.]</upper>
-                <patches>[2,2,2]</patches>
+                <lower>[  0.,  0., 0.]</lower>
+                <upper>[ 32., 32., 32.]</upper>
+                <patches>[4,4,4]</patches>
             </Box>
-            <spacing>[1.,1.,1.]</spacing>
+            <spacing>[2.,2.,2.]</spacing>
         </Level>
         <BoundaryConditions>
             <Face side="x-">
@@ -40,7 +39,7 @@
             </Face>
             <Face side="x+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="y-">
@@ -50,7 +49,7 @@
             </Face>
             <Face side="y+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
             <Face side="z-">
@@ -60,7 +59,7 @@
             </Face>
             <Face side="z+">
                 <BCType id="0" label="u" var="Dirichlet">
-                    <value>-1.</value>
+                    <value>0.</value>
                 </BCType>
             </Face>
         </BoundaryConditions>
@@ -68,18 +67,43 @@
 <!--__________________________________-->
     <AMR>
         <Regridder type="Tiled">
-            <max_levels>3</max_levels>
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
             <cell_refinement_ratio>[[2,2,2]]</cell_refinement_ratio>
             <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
             <min_boundary_cells>[1,1,1]</min_boundary_cells>
             <min_patch_size>[[4,4,4]]</min_patch_size>
         </Regridder>
-   </AMR>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="u" var="FC1" />
+        </FineCoarseInterfaces>
+    </AMR>
 <!--__________________________________-->
     <DataArchiver>
-        <filebase>amr_cc_heat_3d.uda</filebase>
-        <outputTimestepInterval>10</outputTimestepInterval>
+        <filebase>heat_bc_test_nc_d3_p7_fe_amr.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
         <save label="u" />
-        <!--save label="refineFlag" /-->
+        <save label="refineFlag" />
+        <save label="error_u" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+        <!-- if defined PhaseField_Heat_DBG_DERIVATIVES -->
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uz" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="uzz" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uz" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_uzz" />
+        <!-- end if defined -->
     </DataArchiver>
- </Uintah_specification>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_2d.ups b/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_2d.ups
new file mode 100644
index 00000000..190393c0
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_2d.ups
@@ -0,0 +1,56 @@
+<Uintah_specification>
+    <Meta>
+        <title>heat_test_cc_d2_p5_fe</title>
+    </Meta>
+    <SimulationComponent type="phasefield" />
+<!--__________________________________-->
+    <PhaseField type="heat">
+        <var>cc</var>
+        <dim>2</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
+        <verbosity>0</verbosity>
+    </PhaseField>
+<!--__________________________________-->
+    <Time>
+        <maxTime>100.</maxTime>
+        <initTime>0.0</initTime>
+        <delt_min>0.01</delt_min>
+        <delt_max>1.</delt_max>
+        <timestep_multiplier>1.</timestep_multiplier>
+    </Time>
+<!--__________________________________-->
+    <Grid>
+        <Level>
+            <Box label="1">
+                <lower>[-32.,-32., 0.]</lower>
+                <upper>[ 32., 32., 1.]</upper>
+                <patches>[4,4,1]</patches>
+            </Box>
+            <periodic>[1,1,0]</periodic>
+            <spacing>[1.,1.,1.]</spacing>
+        </Level>
+    </Grid>
+<!--__________________________________-->
+    <DataArchiver>
+        <filebase>heat_test_cc_d2_p5_fe.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
+        <save label="u" />
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_u" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+    </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_2d_amr.ups b/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_2d_amr.ups
new file mode 100644
index 00000000..2ff345fb
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_2d_amr.ups
@@ -0,0 +1,74 @@
+<Uintah_specification>
+    <Meta>
+        <title>heat_test_cc_d2_p5_fe_amr</title>
+    </Meta>
+    <SimulationComponent type="phasefield" />
+<!--__________________________________-->
+    <PhaseField type="heat">
+        <var>cc</var>
+        <dim>2</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
+        <verbosity>0</verbosity>
+        <refine_threshold>0.0475</refine_threshold>
+    </PhaseField>
+<!--__________________________________-->
+    <Time>
+        <maxTime>100.</maxTime>
+        <initTime>0.0</initTime>
+        <delt_min>0.01</delt_min>
+        <delt_max>1.</delt_max>
+        <timestep_multiplier>1.</timestep_multiplier>
+    </Time>
+<!--__________________________________-->
+    <Grid>
+        <Level>
+            <Box label="1">
+                <lower>[-32.,-32., 0.]</lower>
+                <upper>[ 32., 32., 1.]</upper>
+                <patches>[2,2,1]</patches>
+            </Box>
+            <periodic>[1,1,0]</periodic>
+            <spacing>[2.,2.,1.]</spacing>
+        </Level>
+    </Grid>
+<!--__________________________________-->
+    <AMR>
+        <Regridder type="Tiled">
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
+            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
+            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
+            <min_boundary_cells>[1,1,0]</min_boundary_cells>
+            <min_patch_size>[[16,16,1]]</min_patch_size>
+        </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="u" var="FC1" />
+        </FineCoarseInterfaces>
+    </AMR>
+<!--__________________________________-->
+    <DataArchiver>
+        <filebase>heat_test_cc_d2_p5_fe_amr.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
+        <save label="u" />
+        <save label="refineFlag" />
+        <save label="error_u" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+        <!-- if defined PhaseField_Heat_DBG_DERIVATIVES -->
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <!-- end if defined -->
+    </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_3d.ups b/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_3d.ups
new file mode 100644
index 00000000..69886b5b
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_3d.ups
@@ -0,0 +1,60 @@
+<Uintah_specification>
+    <Meta>
+        <title>heat_test_cc_d3_p7_fe</title>
+    </Meta>
+    <SimulationComponent type="phasefield" />
+<!--__________________________________-->
+    <PhaseField type="heat">
+        <var>cc</var>
+        <dim>3</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
+        <verbosity>0</verbosity>
+    </PhaseField>
+<!--__________________________________-->
+    <Time>
+        <maxTime>100.</maxTime>
+        <initTime>0.0</initTime>
+        <delt_min>0.01</delt_min>
+        <delt_max>1.</delt_max>
+        <timestep_multiplier>1.</timestep_multiplier>
+    </Time>
+<!--__________________________________-->
+    <Grid>
+        <Level>
+            <Box label="1">
+                <lower>[-32.,-32.,-32.]</lower>
+                <upper>[ 32., 32., 32.]</upper>
+                <patches>[4,4,4]</patches>
+            </Box>
+            <periodic>[1,1,1]</periodic>
+            <spacing>[1.,1.,1.]</spacing>
+        </Level>
+    </Grid>
+<!--__________________________________-->
+    <DataArchiver>
+        <filebase>heat_test_cc_d3_p7_fe.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
+        <save label="u" />
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uz" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="uzz" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_u" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uz" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_uzz" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+    </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_3d_amr.ups b/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_3d_amr.ups
new file mode 100644
index 00000000..0b2da586
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_test_cc_3d_amr.ups
@@ -0,0 +1,78 @@
+<Uintah_specification>
+    <Meta>
+        <title>heat_test_cc_d3_p7_fe_amr</title>
+    </Meta>
+    <SimulationComponent type="phasefield" />
+<!--__________________________________-->
+    <PhaseField type="heat">
+        <var>cc</var>
+        <dim>3</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
+        <verbosity>0</verbosity>
+        <refine_threshold>0.04</refine_threshold>
+    </PhaseField>
+<!--__________________________________-->
+    <Time>
+        <maxTime>100.</maxTime>
+        <initTime>0.0</initTime>
+        <delt_min>0.01</delt_min>
+        <delt_max>1.</delt_max>
+        <timestep_multiplier>1.</timestep_multiplier>
+    </Time>
+<!--__________________________________-->
+    <Grid>
+        <Level>
+            <Box label="1">
+                <lower>[-32.,-32.,-32.]</lower>
+                <upper>[ 32., 32., 32.]</upper>
+                <patches>[4,4,4]</patches>
+            </Box>
+            <periodic>[1,1,1]</periodic>
+            <spacing>[2.,2.,2.]</spacing>
+        </Level>
+    </Grid>
+<!--__________________________________-->
+    <AMR>
+        <Regridder type="Tiled">
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
+            <cell_refinement_ratio>[[2,2,2]]</cell_refinement_ratio>
+            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
+            <min_boundary_cells>[1,1,1]</min_boundary_cells>
+            <min_patch_size>[[4,4,4]]</min_patch_size>
+        </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="u" var="FC1" />
+        </FineCoarseInterfaces>
+    </AMR>
+<!--__________________________________-->
+    <DataArchiver>
+        <filebase>heat_test_cc_d3_p7_fe_amr.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
+        <save label="u" />
+        <save label="refineFlag" />
+        <save label="error_u" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+        <!-- if defined PhaseField_Heat_DBG_DERIVATIVES -->
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uz" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="uzz" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uz" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_uzz" />
+        <!-- end if defined -->
+    </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_2d.ups b/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_2d.ups
new file mode 100644
index 00000000..5b06269f
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_2d.ups
@@ -0,0 +1,56 @@
+<Uintah_specification>
+    <Meta>
+        <title>heat_test_nc_d2_p5_fe</title>
+    </Meta>
+    <SimulationComponent type="phasefield" />
+<!--__________________________________-->
+    <PhaseField type="heat">
+        <var>nc</var>
+        <dim>2</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
+        <verbosity>0</verbosity>
+    </PhaseField>
+<!--__________________________________-->
+    <Time>
+        <maxTime>100.</maxTime>
+        <initTime>0.0</initTime>
+        <delt_min>0.01</delt_min>
+        <delt_max>1.</delt_max>
+        <timestep_multiplier>1.</timestep_multiplier>
+    </Time>
+<!--__________________________________-->
+    <Grid>
+        <Level>
+            <Box label="1">
+                <lower>[-32.,-32., 0.]</lower>
+                <upper>[ 32., 32., 1.]</upper>
+                <patches>[4,4,1]</patches>
+            </Box>
+            <periodic>[1,1,0]</periodic>
+            <spacing>[1.,1.,1.]</spacing>
+        </Level>
+    </Grid>
+<!--__________________________________-->
+    <DataArchiver>
+        <filebase>heat_test_nc_d2_p5_fe.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
+        <save label="u" />
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_u" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+    </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_2d_amr.ups b/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_2d_amr.ups
new file mode 100644
index 00000000..6dafc743
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_2d_amr.ups
@@ -0,0 +1,74 @@
+<Uintah_specification>
+    <Meta>
+        <title>heat_test_nc_d2_p5_fe_amr</title>
+    </Meta>
+    <SimulationComponent type="phasefield" />
+<!--__________________________________-->
+    <PhaseField type="heat">
+        <var>nc</var>
+        <dim>2</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
+        <verbosity>0</verbosity>
+        <refine_threshold>0.03</refine_threshold>
+    </PhaseField>
+<!--__________________________________-->
+    <Time>
+        <maxTime>100.</maxTime>
+        <initTime>0.0</initTime>
+        <delt_min>0.01</delt_min>
+        <delt_max>1.</delt_max>
+        <timestep_multiplier>1.</timestep_multiplier>
+    </Time>
+<!--__________________________________-->
+    <Grid>
+        <Level>
+            <Box label="1">
+                <lower>[-32.,-32., 0.]</lower>
+                <upper>[ 32., 32., 1.]</upper>
+                <patches>[4,4,1]</patches>
+            </Box>
+            <periodic>[1,1,0]</periodic>
+            <spacing>[2.,2.,1.]</spacing>
+        </Level>
+    </Grid>
+<!--__________________________________-->
+    <AMR>
+        <Regridder type="Tiled">
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
+            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
+            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
+            <min_boundary_cells>[1,1,0]</min_boundary_cells>
+            <min_patch_size>[[4,4,1]]</min_patch_size>
+        </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="u" var="FC1" />
+        </FineCoarseInterfaces>
+    </AMR>
+<!--__________________________________-->
+    <DataArchiver>
+        <filebase>heat_test_nc_d2_p5_fe_amr.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
+        <save label="u" />
+        <save label="refineFlag" />
+        <save label="error_u" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+        <!-- if defined PhaseField_Heat_DBG_DERIVATIVES -->
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <!-- end if defined -->
+    </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_3d.ups b/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_3d.ups
new file mode 100644
index 00000000..bba85d0c
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_3d.ups
@@ -0,0 +1,60 @@
+<Uintah_specification>
+    <Meta>
+        <title>heat_test_nc_d3_p7_fe</title>
+    </Meta>
+    <SimulationComponent type="phasefield" />
+<!--__________________________________-->
+    <PhaseField type="heat">
+        <var>nc</var>
+        <dim>3</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
+        <verbosity>0</verbosity>
+    </PhaseField>
+<!--__________________________________-->
+    <Time>
+        <maxTime>100.</maxTime>
+        <initTime>0.0</initTime>
+        <delt_min>0.01</delt_min>
+        <delt_max>1.</delt_max>
+        <timestep_multiplier>1.</timestep_multiplier>
+    </Time>
+<!--__________________________________-->
+    <Grid>
+        <Level>
+            <Box label="1">
+                <lower>[-32.,-32.,-32.]</lower>
+                <upper>[ 32., 32., 32.]</upper>
+                <patches>[4,4,4]</patches>
+            </Box>
+            <periodic>[1,1,1]</periodic>
+            <spacing>[1.,1.,1.]</spacing>
+        </Level>
+    </Grid>
+<!--__________________________________-->
+    <DataArchiver>
+        <filebase>heat_test_nc_d3_p7_fe.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
+        <save label="u" />
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uz" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="uzz" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_u" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uz" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_uzz" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+    </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_3d_amr.ups b/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_3d_amr.ups
new file mode 100644
index 00000000..0648591f
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/heat/heat_test_nc_3d_amr.ups
@@ -0,0 +1,74 @@
+<Uintah_specification>
+    <Meta>
+        <title>heat_test_nc_d3_p7_fe_amr</title>
+    </Meta>
+    <SimulationComponent type="phasefield" />
+<!--__________________________________-->
+    <PhaseField type="heat">
+        <var>nc</var>
+        <dim>3</dim>
+        <delt>.1</delt>
+        <alpha>0.19635</alpha>
+        <test>true</test>
+        <verbosity>0</verbosity>
+        <refine_threshold>0.04</refine_threshold>
+    </PhaseField>
+<!--__________________________________-->
+    <Time>
+        <maxTime>100.</maxTime>
+        <initTime>0.0</initTime>
+        <delt_min>0.01</delt_min>
+        <delt_max>1.</delt_max>
+        <timestep_multiplier>1.</timestep_multiplier>
+    </Time>
+<!--__________________________________-->
+    <Grid>
+        <Level>
+            <Box label="1">
+                <lower>[-32.,-32.,-32.]</lower>
+                <upper>[ 32., 32., 32.]</upper>
+                <patches>[4,4,4]</patches>
+            </Box>
+            <periodic>[1,1,1]</periodic>
+            <spacing>[4.,4.,4.]</spacing>
+        </Level>
+    </Grid>
+<!--__________________________________-->
+    <AMR>
+        <Regridder type="Tiled">
+            <max_levels>2</max_levels>
+            <cell_refinement_ratio>[[2,2,2]]</cell_refinement_ratio>
+            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
+            <min_boundary_cells>[1,1,1]</min_boundary_cells>
+            <min_patch_size>[[4,4,4]]</min_patch_size>
+        </Regridder>
+    </AMR>
+<!--__________________________________-->
+    <DataArchiver>
+        <filebase>heat_test_nc_d3_p7_fe_amr.uda</filebase>
+        <outputTimestepInterval>1</outputTimestepInterval>
+        <save label="u" />
+        <save label="refineFlag" />
+        <save label="error_u" />
+        <save label="u_normL2" />
+        <save label="u_normH10" />
+        <save label="u_normH20" />
+        <save label="error_normL2" />
+        <save label="error_normH10" />
+        <save label="error_normH20" />
+        <!-- if defined PhaseField_Heat_DBG_DERIVATIVES -->
+        <save label="ux" />
+        <save label="uy" />
+        <save label="uz" />
+        <save label="uxx" />
+        <save label="uyy" />
+        <save label="uzz" />
+        <save label="error_ux" />
+        <save label="error_uy" />
+        <save label="error_uz" />
+        <save label="error_uxx" />
+        <save label="error_uyy" />
+        <save label="error_uzz" />
+        <!-- end if defined -->
+    </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/UPS_SPEC/ups_spec.xml b/src/StandAlone/inputs/UPS_SPEC/ups_spec.xml
index e642f246..194cbd02b 100644
--- a/src/StandAlone/inputs/UPS_SPEC/ups_spec.xml
+++ b/src/StandAlone/inputs/UPS_SPEC/ups_spec.xml
@@ -383,7 +383,7 @@
                                                 rigidmpmice,reduce_uda, rmpmice,smpm,
                                                 smpmice,switcher,wave,
                                                 solvertest, solvertest2, heat,
-                                                fdheat, phasefield,
+                                                phasefield,
                                                 RMCRT_Test particletest'" >
                                   <!-- The 'type' above is used in CCA/Components/Parent/ComponentFactory.cc -->
         <carry_over               spec="MULTIPLE NO_DATA"
@@ -1141,20 +1141,8 @@
     <maxresidual              spec="REQUIRED DOUBLE" />
   </Poisson>
 
-  <FDHeat spec="OPTIONAL NO_DATA" >
-    <delt                     spec="REQUIRED DOUBLE" />
-    <alpha                    spec="REQUIRED DOUBLE" />
-    <R0                       spec="REQUIRED DOUBLE" />
-    <gamma                    spec="OPTIONAL DOUBLE" />
-    <scheme                   spec="OPTIONAL STRING 'forward_euler, backward_euler, crank_nicolson'" />
-    <refine_threshold         spec="OPTIONAL DOUBLE" />
-    <node_centered            spec="OPTIONAL BOOLEAN"/>
-    <dimension                spec="OPTIONAL INTEGER '2,3'"/>
-    <verbosity                spec="OPTIONAL INTEGER '0,4'"/>
-  </FDHeat>
-
   <PhaseField spec="OPTIONAL NO_DATA"
-        attribute1="type REQUIRED STRING 'pure_metal'">
+        attribute1="type REQUIRED STRING 'pure_metal, heat'">
     <delt                     spec="REQUIRED DOUBLE" />
     <dim                      spec="OPTIONAL INTEGER '1,3'"/>
     <var                      spec="OPTIONAL STRING 'cc, nc'"/>
