diff --git a/doc/Components/PhaseField/Doxyfile b/doc/Components/PhaseField/Doxyfile
new file mode 100644
index 00000000..24423406
--- /dev/null
+++ b/doc/Components/PhaseField/Doxyfile
@@ -0,0 +1,17 @@
+PROJECT_NAME         = Uintah::PhaseField
+OUTPUT_DIRECTORY     = .
+EXTRACT_ALL          = YES
+ENABLE_PREPROCESSING = YES
+MACRO_EXPANSION      = YES
+SEARCH_INCLUDES      = YES
+FULL_PATH_NAMES      = NO
+INPUT                = ../../../src/CCA/Components/PhaseField
+FILE_PATTERNS        = *.cc *.h
+EXCLUDE_PATTERNS     = _* *-bld.cc
+INCLUDE_PATH         = ../../../src
+RECURSIVE            = YES
+IMAGE_PATH           = img
+PREDEFINED           = _DOXYBDY(x)={x} \
+                       _DOXYARG(x)=x   \
+                       _DOXYIGN(x)=
+EXTRA_PACKAGES       = amsfonts
diff --git a/doc/Components/PhaseField/img/fc0.eps b/doc/Components/PhaseField/img/fc0.eps
new file mode 100644
index 00000000..f3fcc38c
--- /dev/null
+++ b/doc/Components/PhaseField/img/fc0.eps
@@ -0,0 +1,371 @@
+%!PS-Adobe-3.0 EPSF-3.0
+%%Creator: cairo 1.14.8 (http://cairographics.org)
+%%CreationDate: Thu Nov  1 14:25:31 2018
+%%Pages: 1
+%%DocumentData: Clean7Bit
+%%LanguageLevel: 2
+%%BoundingBox: 0 -1 398 115
+%%EndComments
+%%BeginProlog
+save
+50 dict begin
+/q { gsave } bind def
+/Q { grestore } bind def
+/cm { 6 array astore concat } bind def
+/w { setlinewidth } bind def
+/J { setlinecap } bind def
+/j { setlinejoin } bind def
+/M { setmiterlimit } bind def
+/d { setdash } bind def
+/m { moveto } bind def
+/l { lineto } bind def
+/c { curveto } bind def
+/h { closepath } bind def
+/re { exch dup neg 3 1 roll 5 3 roll moveto 0 rlineto
+      0 exch rlineto 0 rlineto closepath } bind def
+/S { stroke } bind def
+/f { fill } bind def
+/f* { eofill } bind def
+/n { newpath } bind def
+/W { clip } bind def
+/W* { eoclip } bind def
+/BT { } bind def
+/ET { } bind def
+/pdfmark where { pop globaldict /?pdfmark /exec load put }
+    { globaldict begin /?pdfmark /pop load def /pdfmark
+    /cleartomark load def end } ifelse
+/BDC { mark 3 1 roll /BDC pdfmark } bind def
+/EMC { mark /EMC pdfmark } bind def
+/cairo_store_point { /cairo_point_y exch def /cairo_point_x exch def } def
+/Tj { show currentpoint cairo_store_point } bind def
+/TJ {
+  {
+    dup
+    type /stringtype eq
+    { show } { -0.001 mul 0 cairo_font_matrix dtransform rmoveto } ifelse
+  } forall
+  currentpoint cairo_store_point
+} bind def
+/cairo_selectfont { cairo_font_matrix aload pop pop pop 0 0 6 array astore
+    cairo_font exch selectfont cairo_point_x cairo_point_y moveto } bind def
+/Tf { pop /cairo_font exch def /cairo_font_matrix where
+      { pop cairo_selectfont } if } bind def
+/Td { matrix translate cairo_font_matrix matrix concatmatrix dup
+      /cairo_font_matrix exch def dup 4 get exch 5 get cairo_store_point
+      /cairo_font where { pop cairo_selectfont } if } bind def
+/Tm { 2 copy 8 2 roll 6 array astore /cairo_font_matrix exch def
+      cairo_store_point /cairo_font where { pop cairo_selectfont } if } bind def
+/g { setgray } bind def
+/rg { setrgbcolor } bind def
+/d1 { setcachedevice } bind def
+%%EndProlog
+%%BeginSetup
+%%EndSetup
+%%Page: 1 1
+%%BeginPageSetup
+%%PageBoundingBox: 0 -1 398 115
+%%EndPageSetup
+q 0 -1 398 116 rectclip q
+0 0 0.964706 rg
+1 w
+0 J
+0 j
+[] 0.0 d
+4 M q 1 0 0 -1 0 114.136993 cm
+71.242 71.242 m 85.414 85.414 l S Q
+0 0.101961 1 rg
+81.414 32.723 8 -8 re f*
+0 0 0.964706 rg
+0.754248 w
+q 1 -0.999997 -0.999997 -1 0 114.136993 cm
+85.414 -4 m 81.414 0 l 85.414 4 l 89.414 0 l h
+85.414 -4 m S Q
+0.968627 0 0 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+42.895 71.242 m 71.242 71.242 l S Q
+1 g
+42.895 48.551 m 37.238 42.895 l 42.895 37.239 l 48.551 42.895 l h
+42.895 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+42.895 65.586 m 37.238 71.242 l 42.895 76.898 l 48.551 71.242 l h
+42.895 65.586 m S Q
+1 g
+71.242 48.551 m 65.586 42.895 l 71.242 37.239 l 76.898 42.895 l h
+71.242 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.136993 cm
+71.242 65.586 m 65.586 71.242 l 71.242 76.898 l 76.898 71.242 l h
+71.242 65.586 m S Q
+0 g
+0.75 w
+1 J
+1 j
+q 1 0 0 -1 0 114.136993 cm
+0.375 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 85.414 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 57.066 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 28.723 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 28.723 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 0.375 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+57.066 0.375 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.136993 cm
+57.066 57.066 56.695 56.695 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 28.723 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 28.723 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 57.066 56.691 56.695 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+312.188 85.414 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+312.188 57.066 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+340.531 0.375 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.136993 cm
+340.531 57.066 56.695 56.695 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 28.723 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+227.148 28.723 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+227.148 0.375 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 0.375 56.691 56.691 re S Q
+1 w
+0 J
+0 j
+q 1 0 0 -1 0 114.136993 cm
+14.547 71.242 m 42.895 71.242 l S Q
+1 g
+14.547 48.551 m 8.891 42.895 l 14.547 37.239 l 20.203 42.895 l h
+14.547 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+14.547 65.586 m 8.891 71.242 l 14.547 76.898 l 20.203 71.242 l h
+14.547 65.586 m S Q
+1 g
+42.895 48.551 m 37.238 42.895 l 42.895 37.239 l 48.551 42.895 l h
+42.895 48.551 m f*
+0 g
+q 1 0 0 -1 0 114.136993 cm
+42.895 65.586 m 37.238 71.242 l 42.895 76.898 l 48.551 71.242 l h
+42.895 65.586 m S Q
+1 w
+q 1 0 0 -1 0 114.136993 cm
+42.895 42.895 m 42.895 99.586 l S Q
+1 g
+48.551 71.242 m 42.895 76.899 l 37.238 71.242 l 42.895 65.586 l h
+48.551 71.242 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -48.551 m 37.238 -42.895 l 42.895 -37.238 l 48.551 -42.895 l h
+42.895 -48.551 m S Q
+1 g
+48.551 42.895 m 42.895 48.551 l 37.238 42.895 l 42.895 37.239 l h
+48.551 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -48.551 m 65.586 -42.895 l 71.242 -37.238 l 76.898 -42.895 l h
+71.242 -48.551 m S Q
+1 g
+48.551 14.551 m 42.895 20.207 l 37.238 14.551 l 42.895 8.891 l h
+48.551 14.551 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.586 -48.551 m 93.93 -42.895 l 99.586 -37.238 l 105.246 -42.895 l h
+99.586 -48.551 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+212.973 71.242 m 227.148 85.414 l S Q
+0 0.101961 1 rg
+223.148 32.723 8 -8 re f*
+0 0 0.964706 rg
+0.754248 w
+q 1 -0.999997 -0.999997 -1 0 114.136993 cm
+156.282 -74.867 m 152.282 -70.867 l 156.282 -66.867 l 160.282 -70.867 l
+ h
+156.282 -74.867 m S Q
+0.968627 0 0 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 71.242 m 212.973 71.242 l S Q
+1 g
+184.629 48.551 m 178.969 42.895 l 184.629 37.239 l 190.285 42.895 l h
+184.629 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 65.586 m 178.969 71.242 l 184.629 76.898 l 190.285 71.242 l h
+184.629 65.586 m S Q
+1 g
+212.973 48.551 m 207.316 42.895 l 212.973 37.239 l 218.629 42.895 l h
+212.973 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.136993 cm
+212.973 65.586 m 207.316 71.242 l 212.973 76.898 l 218.629 71.242 l h
+212.973 65.586 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+156.281 71.242 m 184.629 71.242 l S Q
+1 g
+156.281 48.551 m 150.625 42.895 l 156.281 37.239 l 161.938 42.895 l h
+156.281 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+156.281 65.586 m 150.625 71.242 l 156.281 76.898 l 161.938 71.242 l h
+156.281 65.586 m S Q
+1 g
+184.629 48.551 m 178.969 42.895 l 184.629 37.239 l 190.285 42.895 l h
+184.629 48.551 m f*
+0 g
+q 1 0 0 -1 0 114.136993 cm
+184.629 65.586 m 178.969 71.242 l 184.629 76.898 l 190.285 71.242 l h
+184.629 65.586 m S Q
+1 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 42.895 m 184.629 99.586 l S Q
+1 g
+190.285 71.242 m 184.629 76.899 l 178.969 71.242 l 184.629 65.586 l h
+190.285 71.242 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -190.285 m 37.238 -184.629 l 42.895 -178.969 l 48.551 -184.629 l
+ h
+42.895 -190.285 m S Q
+1 g
+190.285 42.895 m 184.629 48.551 l 178.969 42.895 l 184.629 37.239 l h
+190.285 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -190.285 m 65.586 -184.629 l 71.242 -178.969 l 76.898 -184.629 l
+ h
+71.242 -190.285 m S Q
+1 g
+190.285 14.551 m 184.629 20.207 l 178.969 14.551 l 184.629 8.891 l h
+190.285 14.551 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.586 -190.285 m 93.93 -184.629 l 99.586 -178.969 l 105.246 -184.629 l
+ h
+99.586 -190.285 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+354.707 71.242 m 368.879 85.414 l S Q
+0 0.101961 1 rg
+364.879 32.723 8 -8 re f*
+0 0 0.964706 rg
+0.754249 w
+q 1 -0.999996 -0.999996 -1 0 114.136993 cm
+227.147 -145.732 m 223.147 -141.732 l 227.147 -137.732 l 231.147 -141.732
+ l h
+227.147 -145.732 m S Q
+0.968627 0 0 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 71.242 m 354.707 71.242 l S Q
+1 g
+326.359 48.551 m 320.703 42.895 l 326.359 37.239 l 332.016 42.895 l h
+326.359 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 65.586 m 320.703 71.242 l 326.359 76.898 l 332.016 71.242 l h
+326.359 65.586 m S Q
+1 g
+354.707 48.551 m 349.047 42.895 l 354.707 37.239 l 360.363 42.895 l h
+354.707 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.136993 cm
+354.707 65.586 m 349.047 71.242 l 354.707 76.898 l 360.363 71.242 l h
+354.707 65.586 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+298.012 71.242 m 326.359 71.242 l S Q
+1 g
+298.012 48.551 m 292.355 42.895 l 298.012 37.239 l 303.668 42.895 l h
+298.012 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+298.012 65.586 m 292.355 71.242 l 298.012 76.898 l 303.668 71.242 l h
+298.012 65.586 m S Q
+1 g
+326.359 48.551 m 320.703 42.895 l 326.359 37.239 l 332.016 42.895 l h
+326.359 48.551 m f*
+0 g
+q 1 0 0 -1 0 114.136993 cm
+326.359 65.586 m 320.703 71.242 l 326.359 76.898 l 332.016 71.242 l h
+326.359 65.586 m S Q
+1 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 42.895 m 326.359 99.586 l S Q
+1 g
+332.016 71.242 m 326.359 76.899 l 320.703 71.242 l 326.359 65.586 l h
+332.016 71.242 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -332.016 m 37.238 -326.359 l 42.895 -320.703 l 48.551 -326.359 l
+ h
+42.895 -332.016 m S Q
+1 g
+332.016 42.895 m 326.359 48.551 l 320.703 42.895 l 326.359 37.239 l h
+332.016 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -332.016 m 65.586 -326.359 l 71.242 -320.703 l 76.898 -326.359 l
+ h
+71.242 -332.016 m S Q
+1 g
+332.016 14.551 m 326.359 20.207 l 320.703 14.551 l 326.359 8.891 l h
+332.016 14.551 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.586 -332.016 m 93.93 -326.359 l 99.586 -320.703 l 105.246 -326.359 l
+ h
+99.586 -332.016 m S Q
+Q Q
+showpage
+%%Trailer
+end restore
+%%EOF
diff --git a/doc/Components/PhaseField/img/fc0.png b/doc/Components/PhaseField/img/fc0.png
new file mode 100644
index 0000000000000000000000000000000000000000..388c696fca91570413ab7bbd1beab56d7ec5308d
GIT binary patch
literal 7699
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
G-Twj`!)$c`

literal 0
HcmV?d00001

diff --git a/doc/Components/PhaseField/img/fc1.eps b/doc/Components/PhaseField/img/fc1.eps
new file mode 100644
index 00000000..b3a850d0
--- /dev/null
+++ b/doc/Components/PhaseField/img/fc1.eps
@@ -0,0 +1,458 @@
+%!PS-Adobe-3.0 EPSF-3.0
+%%Creator: cairo 1.14.8 (http://cairographics.org)
+%%CreationDate: Thu Nov  1 14:24:57 2018
+%%Pages: 1
+%%DocumentData: Clean7Bit
+%%LanguageLevel: 2
+%%BoundingBox: 0 -1 398 115
+%%EndComments
+%%BeginProlog
+save
+50 dict begin
+/q { gsave } bind def
+/Q { grestore } bind def
+/cm { 6 array astore concat } bind def
+/w { setlinewidth } bind def
+/J { setlinecap } bind def
+/j { setlinejoin } bind def
+/M { setmiterlimit } bind def
+/d { setdash } bind def
+/m { moveto } bind def
+/l { lineto } bind def
+/c { curveto } bind def
+/h { closepath } bind def
+/re { exch dup neg 3 1 roll 5 3 roll moveto 0 rlineto
+      0 exch rlineto 0 rlineto closepath } bind def
+/S { stroke } bind def
+/f { fill } bind def
+/f* { eofill } bind def
+/n { newpath } bind def
+/W { clip } bind def
+/W* { eoclip } bind def
+/BT { } bind def
+/ET { } bind def
+/pdfmark where { pop globaldict /?pdfmark /exec load put }
+    { globaldict begin /?pdfmark /pop load def /pdfmark
+    /cleartomark load def end } ifelse
+/BDC { mark 3 1 roll /BDC pdfmark } bind def
+/EMC { mark /EMC pdfmark } bind def
+/cairo_store_point { /cairo_point_y exch def /cairo_point_x exch def } def
+/Tj { show currentpoint cairo_store_point } bind def
+/TJ {
+  {
+    dup
+    type /stringtype eq
+    { show } { -0.001 mul 0 cairo_font_matrix dtransform rmoveto } ifelse
+  } forall
+  currentpoint cairo_store_point
+} bind def
+/cairo_selectfont { cairo_font_matrix aload pop pop pop 0 0 6 array astore
+    cairo_font exch selectfont cairo_point_x cairo_point_y moveto } bind def
+/Tf { pop /cairo_font exch def /cairo_font_matrix where
+      { pop cairo_selectfont } if } bind def
+/Td { matrix translate cairo_font_matrix matrix concatmatrix dup
+      /cairo_font_matrix exch def dup 4 get exch 5 get cairo_store_point
+      /cairo_font where { pop cairo_selectfont } if } bind def
+/Tm { 2 copy 8 2 roll 6 array astore /cairo_font_matrix exch def
+      cairo_store_point /cairo_font where { pop cairo_selectfont } if } bind def
+/g { setgray } bind def
+/rg { setrgbcolor } bind def
+/d1 { setcachedevice } bind def
+%%EndProlog
+%%BeginSetup
+%%EndSetup
+%%Page: 1 1
+%%BeginPageSetup
+%%PageBoundingBox: 0 -1 398 115
+%%EndPageSetup
+q 0 -1 398 116 rectclip q
+0 0 0.964706 rg
+1 w
+0 J
+0 j
+[] 0.0 d
+4 M q 1 0 0 -1 0 114.132996 cm
+71.242 71.238 m 85.414 85.414 l S Q
+0 0 1 rg
+81.414 32.719 8 -8 re f*
+0 0 0.964706 rg
+0.754248 w
+q 1 -0.999997 -0.999997 -1 0 114.132996 cm
+85.414 -4 m 81.414 0 l 85.414 4 l 89.414 0 l h
+85.414 -4 m S Q
+0 g
+0.75 w
+1 J
+1 j
+q 1 0 0 -1 0 114.132996 cm
+0.375 85.414 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+28.723 85.414 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+0.375 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+28.723 57.066 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+0.375 28.719 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+28.723 28.719 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+0.375 0.375 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+28.723 0.375 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+57.066 0.375 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+57.066 57.066 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+142.105 85.414 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+170.453 85.414 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+142.105 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+170.453 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+142.105 28.719 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+170.453 28.719 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+142.105 0.375 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+170.453 0.375 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+198.801 57.066 56.691 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+283.84 85.414 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+312.188 85.414 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+283.84 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+312.188 57.066 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+340.531 0.375 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+340.531 57.066 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+198.801 28.719 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+227.148 28.719 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+198.801 0.375 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+227.148 0.375 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+283.84 0.375 56.691 56.691 re S Q
+1 w
+0 J
+0 j
+q 1 0 0 -1 0 114.132996 cm
+42.895 42.895 m 42.895 99.586 l S Q
+1 g
+48.551 71.238 m 42.895 76.899 l 37.238 71.238 l 42.895 65.582 l h
+48.551 71.238 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.132996 cm
+42.895 -48.551 m 37.234 -42.895 l 42.895 -37.238 l 48.551 -42.895 l h
+42.895 -48.551 m S Q
+1 g
+48.551 42.895 m 42.895 48.551 l 37.238 42.895 l 42.895 37.238 l h
+48.551 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+71.238 -48.551 m 65.582 -42.895 l 71.238 -37.238 l 76.895 -42.895 l h
+71.238 -48.551 m S Q
+1 g
+48.551 14.547 m 42.895 20.203 l 37.238 14.547 l 42.895 8.891 l h
+48.551 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+99.586 -48.551 m 93.93 -42.895 l 99.586 -37.238 l 105.242 -42.895 l h
+99.586 -48.551 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+212.973 71.238 m 227.148 85.414 l S Q
+0 0 1 rg
+223.148 32.719 8 -8 re f*
+0 0 0.964706 rg
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.132996 cm
+156.281 -74.867 m 152.281 -70.867 l 156.281 -66.867 l 160.281 -70.867 l
+ h
+156.281 -74.867 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+184.629 42.895 m 184.629 99.586 l S Q
+1 g
+190.285 71.238 m 184.629 76.899 l 178.969 71.238 l 184.629 65.582 l h
+190.285 71.238 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.132996 cm
+42.895 -190.285 m 37.234 -184.629 l 42.895 -178.969 l 48.551 -184.629 l
+ h
+42.895 -190.285 m S Q
+1 g
+190.285 42.895 m 184.629 48.551 l 178.969 42.895 l 184.629 37.238 l h
+190.285 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+71.238 -190.285 m 65.582 -184.629 l 71.238 -178.969 l 76.895 -184.629 l
+ h
+71.238 -190.285 m S Q
+1 g
+190.285 14.547 m 184.629 20.203 l 178.969 14.547 l 184.629 8.891 l h
+190.285 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+99.586 -190.285 m 93.93 -184.629 l 99.586 -178.969 l 105.242 -184.629 l
+ h
+99.586 -190.285 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+354.707 71.238 m 368.879 85.414 l S Q
+0 0 1 rg
+364.879 32.719 8 -8 re f*
+0 0 0.964706 rg
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.132996 cm
+227.147 -145.732 m 223.147 -141.732 l 227.147 -137.732 l 231.147 -141.732
+ l h
+227.147 -145.732 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+326.359 42.895 m 326.359 99.586 l S Q
+1 g
+332.016 71.238 m 326.359 76.899 l 320.703 71.238 l 326.359 65.582 l h
+332.016 71.238 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.132996 cm
+42.895 -332.016 m 37.234 -326.359 l 42.895 -320.703 l 48.551 -326.359 l
+ h
+42.895 -332.016 m S Q
+1 g
+332.016 42.895 m 326.359 48.551 l 320.703 42.895 l 326.359 37.238 l h
+332.016 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+71.238 -332.016 m 65.582 -326.359 l 71.238 -320.703 l 76.895 -326.359 l
+ h
+71.238 -332.016 m S Q
+1 g
+332.016 14.547 m 326.359 20.203 l 320.703 14.547 l 326.359 8.891 l h
+332.016 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+99.586 -332.016 m 93.93 -326.359 l 99.586 -320.703 l 105.242 -326.359 l
+ h
+99.586 -332.016 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+71.242 71.238 m 85.414 28.719 l S Q
+q 1 0 0 -1 0 114.132996 cm
+71.242 71.238 m 28.723 85.414 l S Q
+q 1 0 0 -1 0 114.132996 cm
+71.242 71.238 m 28.723 28.719 l S Q
+0 0 1 rg
+24.723 89.414 8 -8 re f*
+0 0 0.964706 rg
+0.754247 w
+q -1 1 1 1 0 114.132996 cm
+-28.721 -3.998 m -32.721 0.002 l -28.721 4.002 l -24.721 0.002 l h
+-28.721 -3.998 m S Q
+0.968627 0 0 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+42.895 71.238 m 71.242 71.238 l S Q
+1 g
+42.895 48.551 m 37.238 42.895 l 42.895 37.238 l 48.551 42.895 l h
+42.895 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+42.895 65.582 m 37.238 71.238 l 42.895 76.895 l 48.551 71.238 l h
+42.895 65.582 m S Q
+1 g
+71.242 48.551 m 65.586 42.895 l 71.242 37.238 l 76.898 42.895 l h
+71.242 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.132996 cm
+71.242 65.582 m 65.586 71.238 l 71.242 76.895 l 76.898 71.238 l h
+71.242 65.582 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+14.547 71.238 m 42.895 71.238 l S Q
+1 g
+14.547 48.551 m 8.891 42.895 l 14.547 37.238 l 20.203 42.895 l h
+14.547 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+14.547 65.582 m 8.891 71.238 l 14.547 76.895 l 20.203 71.238 l h
+14.547 65.582 m S Q
+1 g
+42.895 48.551 m 37.238 42.895 l 42.895 37.238 l 48.551 42.895 l h
+42.895 48.551 m f*
+0 g
+q 1 0 0 -1 0 114.132996 cm
+42.895 65.582 m 37.238 71.238 l 42.895 76.895 l 48.551 71.238 l h
+42.895 65.582 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+212.973 71.238 m 227.148 28.719 l S Q
+q 1 0 0 -1 0 114.132996 cm
+212.973 71.238 m 170.453 85.414 l S Q
+q 1 0 0 -1 0 114.132996 cm
+212.973 71.238 m 170.453 28.719 l S Q
+0 0 1 rg
+166.453 89.414 8 -8 re f*
+0 0 0.964706 rg
+0.754247 w
+q -1 1 1 1 0 114.132996 cm
+-99.586 66.867 m -103.586 70.867 l -99.586 74.867 l -95.586 70.867 l h
+-99.586 66.867 m S Q
+1 w
+q 1 0 0 -1 0 114.132996 cm
+354.707 71.238 m 368.879 28.719 l S Q
+q 1 0 0 -1 0 114.132996 cm
+354.707 71.238 m 312.188 85.414 l S Q
+q 1 0 0 -1 0 114.132996 cm
+354.707 71.238 m 312.188 28.719 l S Q
+0 0 1 rg
+308.188 89.414 8 -8 re f*
+0 0 0.964706 rg
+0.754247 w
+q -1 1 1 1 0 114.132996 cm
+-170.453 137.734 m -174.453 141.734 l -170.453 145.734 l -166.453 141.734
+ l h
+-170.453 137.734 m S Q
+0.968627 0 0 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+184.629 71.238 m 212.973 71.238 l S Q
+1 g
+184.629 48.551 m 178.969 42.895 l 184.629 37.238 l 190.285 42.895 l h
+184.629 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+184.629 65.582 m 178.969 71.238 l 184.629 76.895 l 190.285 71.238 l h
+184.629 65.582 m S Q
+1 g
+212.973 48.551 m 207.316 42.895 l 212.973 37.238 l 218.629 42.895 l h
+212.973 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.132996 cm
+212.973 65.582 m 207.316 71.238 l 212.973 76.895 l 218.629 71.238 l h
+212.973 65.582 m S Q
+1 w
+q 1 0 0 -1 0 114.132996 cm
+326.359 71.238 m 354.707 71.238 l S Q
+1 g
+326.359 48.551 m 320.703 42.895 l 326.359 37.238 l 332.016 42.895 l h
+326.359 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+326.359 65.582 m 320.703 71.238 l 326.359 76.895 l 332.016 71.238 l h
+326.359 65.582 m S Q
+1 g
+354.707 48.551 m 349.051 42.895 l 354.707 37.238 l 360.363 42.895 l h
+354.707 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.132996 cm
+354.707 65.582 m 349.051 71.238 l 354.707 76.895 l 360.363 71.238 l h
+354.707 65.582 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+156.281 71.238 m 184.629 71.238 l S Q
+1 g
+156.281 48.551 m 150.625 42.895 l 156.281 37.238 l 161.938 42.895 l h
+156.281 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+156.281 65.582 m 150.625 71.238 l 156.281 76.895 l 161.938 71.238 l h
+156.281 65.582 m S Q
+1 g
+184.629 48.551 m 178.969 42.895 l 184.629 37.238 l 190.285 42.895 l h
+184.629 48.551 m f*
+0 g
+q 1 0 0 -1 0 114.132996 cm
+184.629 65.582 m 178.969 71.238 l 184.629 76.895 l 190.285 71.238 l h
+184.629 65.582 m S Q
+1 w
+q 1 0 0 -1 0 114.132996 cm
+298.012 71.238 m 326.359 71.238 l S Q
+1 g
+298.012 48.551 m 292.355 42.895 l 298.012 37.238 l 303.668 42.895 l h
+298.012 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+298.012 65.582 m 292.355 71.238 l 298.012 76.895 l 303.668 71.238 l h
+298.012 65.582 m S Q
+1 g
+326.359 48.551 m 320.703 42.895 l 326.359 37.238 l 332.016 42.895 l h
+326.359 48.551 m f*
+0 g
+q 1 0 0 -1 0 114.132996 cm
+326.359 65.582 m 320.703 71.238 l 326.359 76.895 l 332.016 71.238 l h
+326.359 65.582 m S Q
+0 0 1 rg
+24.723 32.719 8 -8 re f*
+0 0 0.964706 rg
+0.754248 w
+q 1 -0.999997 -0.999997 -1 0 114.132996 cm
+57.068 24.346 m 53.068 28.346 l 57.068 32.346 l 61.068 28.346 l h
+57.068 24.346 m S Q
+0 0 1 rg
+81.414 89.414 8 -8 re f*
+0 0 0.964706 rg
+q 1 -0.999997 -0.999997 -1 0 114.132996 cm
+57.067 -32.348 m 53.067 -28.348 l 57.067 -24.348 l 61.067 -28.348 l h
+57.067 -32.348 m S Q
+0 0 1 rg
+166.453 32.719 8 -8 re f*
+0 0 0.964706 rg
+q 1 -0.999997 -0.999997 -1 0 114.132996 cm
+127.934 -46.519 m 123.934 -42.519 l 127.934 -38.519 l 131.934 -42.519 l
+ h
+127.934 -46.519 m S Q
+0 0 1 rg
+223.148 89.414 8 -8 re f*
+0 0 0.964706 rg
+q 1 -0.999997 -0.999997 -1 0 114.132996 cm
+127.934 -103.215 m 123.934 -99.215 l 127.934 -95.215 l 131.934 -99.215
+l h
+127.934 -103.215 m S Q
+0 0 1 rg
+308.188 32.719 8 -8 re f*
+0 0 0.964706 rg
+q 1 -0.999997 -0.999997 -1 0 114.132996 cm
+198.801 -117.387 m 194.801 -113.387 l 198.801 -109.387 l 202.801 -113.387
+ l h
+198.801 -117.387 m S Q
+0 0 1 rg
+364.879 89.414 8 -8 re f*
+0 0 0.964706 rg
+q 1 -0.999997 -0.999997 -1 0 114.132996 cm
+198.799 -174.08 m 194.799 -170.08 l 198.799 -166.08 l 202.799 -170.08 l
+ h
+198.799 -174.08 m S Q
+Q Q
+showpage
+%%Trailer
+end restore
+%%EOF
diff --git a/doc/Components/PhaseField/img/fc1.png b/doc/Components/PhaseField/img/fc1.png
new file mode 100644
index 0000000000000000000000000000000000000000..31e76996a2a578bedeb360b7e7e9facef13e7994
GIT binary patch
literal 11265
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

literal 0
HcmV?d00001

diff --git a/doc/Components/PhaseField/img/fcbilinear.eps b/doc/Components/PhaseField/img/fcbilinear.eps
new file mode 100644
index 00000000..c43c5b62
--- /dev/null
+++ b/doc/Components/PhaseField/img/fcbilinear.eps
@@ -0,0 +1,444 @@
+%!PS-Adobe-3.0 EPSF-3.0
+%%Creator: cairo 1.14.8 (http://cairographics.org)
+%%CreationDate: Thu Nov  1 14:21:55 2018
+%%Pages: 1
+%%DocumentData: Clean7Bit
+%%LanguageLevel: 2
+%%BoundingBox: 0 -1 398 115
+%%EndComments
+%%BeginProlog
+save
+50 dict begin
+/q { gsave } bind def
+/Q { grestore } bind def
+/cm { 6 array astore concat } bind def
+/w { setlinewidth } bind def
+/J { setlinecap } bind def
+/j { setlinejoin } bind def
+/M { setmiterlimit } bind def
+/d { setdash } bind def
+/m { moveto } bind def
+/l { lineto } bind def
+/c { curveto } bind def
+/h { closepath } bind def
+/re { exch dup neg 3 1 roll 5 3 roll moveto 0 rlineto
+      0 exch rlineto 0 rlineto closepath } bind def
+/S { stroke } bind def
+/f { fill } bind def
+/f* { eofill } bind def
+/n { newpath } bind def
+/W { clip } bind def
+/W* { eoclip } bind def
+/BT { } bind def
+/ET { } bind def
+/pdfmark where { pop globaldict /?pdfmark /exec load put }
+    { globaldict begin /?pdfmark /pop load def /pdfmark
+    /cleartomark load def end } ifelse
+/BDC { mark 3 1 roll /BDC pdfmark } bind def
+/EMC { mark /EMC pdfmark } bind def
+/cairo_store_point { /cairo_point_y exch def /cairo_point_x exch def } def
+/Tj { show currentpoint cairo_store_point } bind def
+/TJ {
+  {
+    dup
+    type /stringtype eq
+    { show } { -0.001 mul 0 cairo_font_matrix dtransform rmoveto } ifelse
+  } forall
+  currentpoint cairo_store_point
+} bind def
+/cairo_selectfont { cairo_font_matrix aload pop pop pop 0 0 6 array astore
+    cairo_font exch selectfont cairo_point_x cairo_point_y moveto } bind def
+/Tf { pop /cairo_font exch def /cairo_font_matrix where
+      { pop cairo_selectfont } if } bind def
+/Td { matrix translate cairo_font_matrix matrix concatmatrix dup
+      /cairo_font_matrix exch def dup 4 get exch 5 get cairo_store_point
+      /cairo_font where { pop cairo_selectfont } if } bind def
+/Tm { 2 copy 8 2 roll 6 array astore /cairo_font_matrix exch def
+      cairo_store_point /cairo_font where { pop cairo_selectfont } if } bind def
+/g { setgray } bind def
+/rg { setrgbcolor } bind def
+/d1 { setcachedevice } bind def
+%%EndProlog
+%%BeginSetup
+%%EndSetup
+%%Page: 1 1
+%%BeginPageSetup
+%%PageBoundingBox: 0 -1 398 115
+%%EndPageSetup
+q 0 -1 398 116 rectclip q
+0 0 0.964706 rg
+1 w
+0 J
+0 j
+[] 0.0 d
+4 M q 1 0 0 -1 0 114.136993 cm
+71.242 71.242 m 85.414 85.414 l S Q
+0 0 1 rg
+81.414 32.723 8 -8 re f*
+0.754248 w
+q 1 -0.999997 -0.999997 -1 0 114.136993 cm
+85.414 -4 m 81.414 0 l 85.414 4 l 89.414 0 l h
+85.414 -4 m S Q
+0 g
+0.75 w
+1 J
+1 j
+q 1 0 0 -1 0 114.136993 cm
+0.375 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 85.414 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 57.07 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 57.07 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 28.723 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 28.723 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 0.375 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+57.066 0.375 56.695 56.695 re S Q
+q 1 0 0 -1 0 114.136993 cm
+57.066 57.07 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 57.07 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 57.07 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 28.723 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 28.723 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 57.07 56.691 56.691 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+312.188 85.414 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 57.07 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+312.188 57.07 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+340.531 0.375 56.695 56.695 re S Q
+q 1 0 0 -1 0 114.136993 cm
+340.531 57.07 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 28.723 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+227.148 28.723 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+227.148 0.375 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 0.375 56.691 56.695 re S Q
+1 w
+0 J
+0 j
+q 1 0 0 -1 0 114.136993 cm
+42.895 42.895 m 42.895 99.59 l S Q
+0 0 1 rg
+48.551 71.242 m 42.895 76.899 l 37.238 71.242 l 42.895 65.586 l h
+48.551 71.242 m f*
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -48.551 m 37.238 -42.895 l 42.895 -37.238 l 48.551 -42.895 l h
+42.895 -48.551 m S Q
+1 g
+48.551 42.895 m 42.895 48.551 l 37.238 42.895 l 42.895 37.239 l h
+48.551 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -48.551 m 65.586 -42.895 l 71.242 -37.238 l 76.898 -42.895 l h
+71.242 -48.551 m S Q
+1 g
+48.551 14.547 m 42.895 20.207 l 37.238 14.547 l 42.895 8.891 l h
+48.551 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.59 -48.551 m 93.93 -42.895 l 99.59 -37.238 l 105.246 -42.895 l h
+99.59 -48.551 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+212.973 71.242 m 227.148 85.414 l S Q
+0 0 1 rg
+223.148 32.723 8 -8 re f*
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.136993 cm
+156.281 -74.867 m 152.281 -70.867 l 156.281 -66.867 l 160.281 -70.867 l
+ h
+156.281 -74.867 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 42.895 m 184.629 99.59 l S Q
+0 0 1 rg
+190.285 71.242 m 184.629 76.899 l 178.969 71.242 l 184.629 65.586 l h
+190.285 71.242 m f*
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -190.285 m 37.238 -184.629 l 42.895 -178.969 l 48.551 -184.629 l
+ h
+42.895 -190.285 m S Q
+1 g
+190.285 42.895 m 184.629 48.551 l 178.969 42.895 l 184.629 37.239 l h
+190.285 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -190.285 m 65.586 -184.629 l 71.242 -178.969 l 76.898 -184.629 l
+ h
+71.242 -190.285 m S Q
+1 g
+190.285 14.547 m 184.629 20.207 l 178.969 14.547 l 184.629 8.891 l h
+190.285 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.59 -190.285 m 93.93 -184.629 l 99.59 -178.969 l 105.246 -184.629 l h
+99.59 -190.285 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+354.707 71.242 m 368.879 85.414 l S Q
+0 0 1 rg
+364.879 32.723 8 -8 re f*
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.136993 cm
+227.147 -145.732 m 223.147 -141.732 l 227.147 -137.732 l 231.147 -141.732
+ l h
+227.147 -145.732 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 42.895 m 326.359 99.59 l S Q
+1 g
+332.016 71.242 m 326.359 76.899 l 320.703 71.242 l 326.359 65.586 l h
+332.016 71.242 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -332.016 m 37.238 -326.359 l 42.895 -320.703 l 48.551 -326.359 l
+ h
+42.895 -332.016 m S Q
+1 g
+332.016 42.895 m 326.359 48.551 l 320.703 42.895 l 326.359 37.239 l h
+332.016 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -332.016 m 65.586 -326.359 l 71.242 -320.703 l 76.898 -326.359 l
+ h
+71.242 -332.016 m S Q
+1 g
+332.016 14.547 m 326.359 20.207 l 320.703 14.547 l 326.359 8.891 l h
+332.016 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.59 -332.016 m 93.93 -326.359 l 99.59 -320.703 l 105.246 -326.359 l h
+99.59 -332.016 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+71.242 71.242 m 85.414 28.723 l S Q
+q 1 0 0 -1 0 114.136993 cm
+71.242 71.242 m 42.895 42.895 l S Q
+q 1 0 0 -1 0 114.136993 cm
+71.242 71.242 m 42.895 71.242 l S Q
+1 g
+42.895 37.239 m 48.551 42.895 l 42.895 48.551 l 37.238 42.895 l h
+42.895 37.239 m f*
+0 0 0.964706 rg
+1.066667 w
+q -1 0.0000003 0.0000003 1 0 114.136993 cm
+-42.895 -76.898 m -48.551 -71.242 l -42.895 -65.586 l -37.238 -71.242 l
+ h
+-42.895 -76.898 m S Q
+0 0 1 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+42.895 71.242 m 71.242 71.242 l S Q
+1 g
+42.895 48.551 m 37.238 42.895 l 42.895 37.239 l 48.551 42.895 l h
+42.895 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+42.895 65.586 m 37.238 71.242 l 42.895 76.898 l 48.551 71.242 l h
+42.895 65.586 m S Q
+1 g
+71.242 48.551 m 65.586 42.895 l 71.242 37.239 l 76.898 42.895 l h
+71.242 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.136993 cm
+71.242 65.586 m 65.586 71.242 l 71.242 76.898 l 76.898 71.242 l h
+71.242 65.586 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+14.547 71.242 m 42.895 71.242 l S Q
+1 g
+14.547 48.551 m 8.891 42.895 l 14.547 37.239 l 20.203 42.895 l h
+14.547 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+14.547 65.586 m 8.891 71.242 l 14.547 76.898 l 20.203 71.242 l h
+14.547 65.586 m S Q
+0 0 1 rg
+42.895 48.551 m 37.238 42.895 l 42.895 37.239 l 48.551 42.895 l h
+42.895 48.551 m f*
+q 1 0 0 -1 0 114.136993 cm
+42.895 65.586 m 37.238 71.242 l 42.895 76.898 l 48.551 71.242 l h
+42.895 65.586 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+212.973 71.242 m 212.973 42.895 l S Q
+0 0 1 rg
+207.316 71.242 m 212.973 65.586 l 218.629 71.242 l 212.973 76.899 l h
+207.316 71.242 m f*
+1.066667 w
+q -0.000000699998 1 1 0.000000699998 0 114.136993 cm
+-42.895 207.316 m -48.551 212.973 l -42.895 218.629 l -37.238 212.973 l
+ h
+-42.895 207.316 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+212.973 71.242 m 184.629 71.242 l S Q
+1 g
+184.629 37.239 m 190.285 42.895 l 184.629 48.551 l 178.969 42.895 l h
+184.629 37.239 m f*
+0 0 0.964706 rg
+1.066667 w
+q -1 0.0000008 0.0000008 1 0 114.136993 cm
+-184.629 -76.898 m -190.285 -71.242 l -184.629 -65.586 l -178.969 -71.242
+ l h
+-184.629 -76.898 m S Q
+1 w
+q 1 0 0 -1 0 114.136993 cm
+212.973 71.242 m 184.629 42.895 l S Q
+q 1 0 0 -1 0 114.136993 cm
+354.707 71.242 m 368.879 28.723 l S Q
+q 1 0 0 -1 0 114.136993 cm
+354.707 71.242 m 326.359 71.242 l S Q
+1 g
+326.359 37.239 m 332.016 42.895 l 326.359 48.551 l 320.703 42.895 l h
+326.359 37.239 m f*
+0 0 0.964706 rg
+1.066667 w
+q -1 -0.000000999999 -0.000000999999 1 0 114.136993 cm
+-326.359 -76.899 m -332.016 -71.243 l -326.359 -65.586 l -320.703 -71.243
+ l h
+-326.359 -76.899 m S Q
+1 w
+q 1 0 0 -1 0 114.136993 cm
+354.707 71.242 m 312.188 28.723 l S Q
+0 0 1 rg
+308.188 89.414 8 -8 re f*
+0.754247 w
+q -1 1 1 1 0 114.136993 cm
+-170.455 137.732 m -174.455 141.732 l -170.455 145.732 l -166.455 141.732
+ l h
+-170.455 137.732 m S Q
+1 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 71.242 m 212.973 71.242 l S Q
+1 g
+184.629 48.551 m 178.969 42.895 l 184.629 37.239 l 190.285 42.895 l h
+184.629 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 65.586 m 178.969 71.242 l 184.629 76.898 l 190.285 71.242 l h
+184.629 65.586 m S Q
+1 g
+212.973 48.551 m 207.316 42.895 l 212.973 37.239 l 218.629 42.895 l h
+212.973 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.136993 cm
+212.973 65.586 m 207.316 71.242 l 212.973 76.898 l 218.629 71.242 l h
+212.973 65.586 m S Q
+0 0 1 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 71.242 m 354.707 71.242 l S Q
+1 g
+326.359 48.551 m 320.703 42.895 l 326.359 37.239 l 332.016 42.895 l h
+326.359 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 65.586 m 320.703 71.242 l 326.359 76.898 l 332.016 71.242 l h
+326.359 65.586 m S Q
+1 g
+354.707 48.551 m 349.051 42.895 l 354.707 37.239 l 360.363 42.895 l h
+354.707 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.136993 cm
+354.707 65.586 m 349.051 71.242 l 354.707 76.898 l 360.363 71.242 l h
+354.707 65.586 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+156.281 71.242 m 184.629 71.242 l S Q
+1 g
+156.281 48.551 m 150.625 42.895 l 156.281 37.239 l 161.938 42.895 l h
+156.281 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+156.281 65.586 m 150.625 71.242 l 156.281 76.898 l 161.938 71.242 l h
+156.281 65.586 m S Q
+0 0 1 rg
+184.629 48.551 m 178.969 42.895 l 184.629 37.239 l 190.285 42.895 l h
+184.629 48.551 m f*
+q 1 0 0 -1 0 114.136993 cm
+184.629 65.586 m 178.969 71.242 l 184.629 76.898 l 190.285 71.242 l h
+184.629 65.586 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+298.012 71.242 m 326.359 71.242 l S Q
+1 g
+298.012 48.551 m 292.355 42.895 l 298.012 37.239 l 303.668 42.895 l h
+298.012 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+298.012 65.586 m 292.355 71.242 l 298.012 76.898 l 303.668 71.242 l h
+298.012 65.586 m S Q
+0 0 1 rg
+326.359 48.551 m 320.703 42.895 l 326.359 37.239 l 332.016 42.895 l h
+326.359 48.551 m f*
+q 1 0 0 -1 0 114.136993 cm
+326.359 65.586 m 320.703 71.242 l 326.359 76.898 l 332.016 71.242 l h
+326.359 65.586 m S Q
+81.414 89.414 8 -8 re f*
+0 0 0.964706 rg
+0.754247 w
+q -1 1 1 1 0 114.136993 cm
+-57.068 24.346 m -61.068 28.346 l -57.068 32.346 l -53.068 28.346 l h
+-57.068 24.346 m S Q
+0 0 1 rg
+364.879 89.414 8 -8 re f*
+0 0 0.964706 rg
+q -1 1 1 1 0 114.136993 cm
+-198.801 166.078 m -202.801 170.078 l -198.801 174.078 l -194.801 170.078
+ l h
+-198.801 166.078 m S Q
+Q Q
+showpage
+%%Trailer
+end restore
+%%EOF
diff --git a/doc/Components/PhaseField/img/fcbilinear.png b/doc/Components/PhaseField/img/fcbilinear.png
new file mode 100644
index 0000000000000000000000000000000000000000..91ef97ada2bd991314ba93ca113123624021257d
GIT binary patch
literal 9232
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

literal 0
HcmV?d00001

diff --git a/doc/Components/PhaseField/img/fclinear.eps b/doc/Components/PhaseField/img/fclinear.eps
new file mode 100644
index 00000000..81b01727
--- /dev/null
+++ b/doc/Components/PhaseField/img/fclinear.eps
@@ -0,0 +1,383 @@
+%!PS-Adobe-3.0 EPSF-3.0
+%%Creator: cairo 1.14.8 (http://cairographics.org)
+%%CreationDate: Thu Nov  1 14:23:15 2018
+%%Pages: 1
+%%DocumentData: Clean7Bit
+%%LanguageLevel: 2
+%%BoundingBox: 0 -1 398 115
+%%EndComments
+%%BeginProlog
+save
+50 dict begin
+/q { gsave } bind def
+/Q { grestore } bind def
+/cm { 6 array astore concat } bind def
+/w { setlinewidth } bind def
+/J { setlinecap } bind def
+/j { setlinejoin } bind def
+/M { setmiterlimit } bind def
+/d { setdash } bind def
+/m { moveto } bind def
+/l { lineto } bind def
+/c { curveto } bind def
+/h { closepath } bind def
+/re { exch dup neg 3 1 roll 5 3 roll moveto 0 rlineto
+      0 exch rlineto 0 rlineto closepath } bind def
+/S { stroke } bind def
+/f { fill } bind def
+/f* { eofill } bind def
+/n { newpath } bind def
+/W { clip } bind def
+/W* { eoclip } bind def
+/BT { } bind def
+/ET { } bind def
+/pdfmark where { pop globaldict /?pdfmark /exec load put }
+    { globaldict begin /?pdfmark /pop load def /pdfmark
+    /cleartomark load def end } ifelse
+/BDC { mark 3 1 roll /BDC pdfmark } bind def
+/EMC { mark /EMC pdfmark } bind def
+/cairo_store_point { /cairo_point_y exch def /cairo_point_x exch def } def
+/Tj { show currentpoint cairo_store_point } bind def
+/TJ {
+  {
+    dup
+    type /stringtype eq
+    { show } { -0.001 mul 0 cairo_font_matrix dtransform rmoveto } ifelse
+  } forall
+  currentpoint cairo_store_point
+} bind def
+/cairo_selectfont { cairo_font_matrix aload pop pop pop 0 0 6 array astore
+    cairo_font exch selectfont cairo_point_x cairo_point_y moveto } bind def
+/Tf { pop /cairo_font exch def /cairo_font_matrix where
+      { pop cairo_selectfont } if } bind def
+/Td { matrix translate cairo_font_matrix matrix concatmatrix dup
+      /cairo_font_matrix exch def dup 4 get exch 5 get cairo_store_point
+      /cairo_font where { pop cairo_selectfont } if } bind def
+/Tm { 2 copy 8 2 roll 6 array astore /cairo_font_matrix exch def
+      cairo_store_point /cairo_font where { pop cairo_selectfont } if } bind def
+/g { setgray } bind def
+/rg { setrgbcolor } bind def
+/d1 { setcachedevice } bind def
+%%EndProlog
+%%BeginSetup
+%%EndSetup
+%%Page: 1 1
+%%BeginPageSetup
+%%PageBoundingBox: 0 -1 398 115
+%%EndPageSetup
+q 0 -1 398 116 rectclip q
+0 0 0.964706 rg
+1 w
+0 J
+0 j
+[] 0.0 d
+4 M q 1 0 0 -1 0 114.132996 cm
+354.707 71.238 m 326.359 99.586 l S Q
+q 1 0 0 -1 0 114.132996 cm
+212.973 71.238 m 184.629 99.586 l S Q
+q 1 0 0 -1 0 114.132996 cm
+71.242 71.238 m 85.414 85.414 l S Q
+0 0 1 rg
+81.414 32.719 8 -8 re f*
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.132996 cm
+85.414 -4 m 81.414 0 l 85.414 4 l 89.414 0 l h
+85.414 -4 m S Q
+0 g
+0.75 w
+1 J
+1 j
+q 1 0 0 -1 0 114.132996 cm
+0.375 85.414 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+28.723 85.414 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+0.375 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+28.723 57.066 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+0.375 28.719 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+28.723 28.719 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+0.375 0.375 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+28.723 0.375 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+57.066 0.375 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+57.066 57.066 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+142.105 85.414 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+170.453 85.414 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+142.105 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+170.453 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+142.105 28.719 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+170.453 28.719 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+142.105 0.375 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+170.453 0.375 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+198.801 57.066 56.691 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+283.84 85.414 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+312.188 85.414 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+283.84 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+312.188 57.066 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+340.531 0.375 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+340.531 57.066 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.132996 cm
+198.801 28.719 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+227.148 28.719 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.132996 cm
+198.801 0.375 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+227.148 0.375 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.132996 cm
+283.84 0.375 56.691 56.691 re S Q
+1 w
+0 J
+0 j
+q 1 0 0 -1 0 114.132996 cm
+42.895 42.895 m 42.895 99.586 l S Q
+1 g
+48.551 71.238 m 42.895 76.895 l 37.238 71.238 l 42.895 65.582 l h
+48.551 71.238 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.132996 cm
+42.895 -48.551 m 37.238 -42.895 l 42.895 -37.238 l 48.551 -42.895 l h
+42.895 -48.551 m S Q
+1 g
+48.551 42.895 m 42.895 48.551 l 37.238 42.895 l 42.895 37.235 l h
+48.551 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+71.238 -48.551 m 65.582 -42.895 l 71.238 -37.238 l 76.898 -42.895 l h
+71.238 -48.551 m S Q
+0 0 1 rg
+48.551 14.547 m 42.895 20.203 l 37.238 14.547 l 42.895 8.891 l h
+48.551 14.547 m f*
+q 0 -1 -1 0 0 114.132996 cm
+99.586 -48.551 m 93.93 -42.895 l 99.586 -37.238 l 105.242 -42.895 l h
+99.586 -48.551 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+212.973 71.238 m 227.148 85.414 l S Q
+0 0 1 rg
+223.148 32.719 8 -8 re f*
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.132996 cm
+156.281 -74.867 m 152.281 -70.867 l 156.281 -66.867 l 160.281 -70.867 l
+ h
+156.281 -74.867 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+184.629 42.895 m 184.629 99.586 l S Q
+1 g
+190.285 71.238 m 184.629 76.895 l 178.969 71.238 l 184.629 65.582 l h
+190.285 71.238 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.132996 cm
+42.895 -190.285 m 37.238 -184.629 l 42.895 -178.969 l 48.551 -184.629 l
+ h
+42.895 -190.285 m S Q
+1 g
+190.285 42.895 m 184.629 48.551 l 178.969 42.895 l 184.629 37.235 l h
+190.285 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+71.238 -190.285 m 65.582 -184.629 l 71.238 -178.969 l 76.898 -184.629 l
+ h
+71.238 -190.285 m S Q
+0 0 1 rg
+190.285 14.547 m 184.629 20.203 l 178.969 14.547 l 184.629 8.891 l h
+190.285 14.547 m f*
+q 0 -1 -1 0 0 114.132996 cm
+99.586 -190.285 m 93.93 -184.629 l 99.586 -178.969 l 105.242 -184.629 l
+ h
+99.586 -190.285 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+354.707 71.238 m 368.879 85.414 l S Q
+0 0 1 rg
+364.879 32.719 8 -8 re f*
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.132996 cm
+227.147 -145.732 m 223.147 -141.732 l 227.147 -137.732 l 231.147 -141.732
+ l h
+227.147 -145.732 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+326.359 42.895 m 326.359 99.586 l S Q
+1 g
+332.016 71.238 m 326.359 76.895 l 320.703 71.238 l 326.359 65.582 l h
+332.016 71.238 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.132996 cm
+42.895 -332.016 m 37.238 -326.359 l 42.895 -320.703 l 48.551 -326.359 l
+ h
+42.895 -332.016 m S Q
+1 g
+332.016 42.895 m 326.359 48.551 l 320.703 42.895 l 326.359 37.235 l h
+332.016 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.132996 cm
+71.238 -332.016 m 65.582 -326.359 l 71.238 -320.703 l 76.898 -326.359 l
+ h
+71.238 -332.016 m S Q
+0 0 1 rg
+332.016 14.547 m 326.359 20.203 l 320.703 14.547 l 326.359 8.891 l h
+332.016 14.547 m f*
+q 0 -1 -1 0 0 114.132996 cm
+99.586 -332.016 m 93.93 -326.359 l 99.586 -320.703 l 105.242 -326.359 l
+ h
+99.586 -332.016 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+71.242 71.238 m 42.895 99.586 l S Q
+q 1 0 0 -1 0 114.132996 cm
+71.242 71.238 m 42.895 71.238 l S Q
+1 g
+42.895 37.235 m 48.551 42.895 l 42.895 48.551 l 37.238 42.895 l h
+42.895 37.235 m f*
+0 0 0.964706 rg
+1.066667 w
+q -1 0 0 1 0 114.132996 cm
+-42.895 -76.898 m -48.551 -71.238 l -42.895 -65.582 l -37.238 -71.238 l
+ h
+-42.895 -76.898 m S Q
+0 0 1 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+42.895 71.238 m 71.242 71.238 l S Q
+1 g
+42.895 48.551 m 37.238 42.895 l 42.895 37.235 l 48.551 42.895 l h
+42.895 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+42.895 65.582 m 37.238 71.238 l 42.895 76.898 l 48.551 71.238 l h
+42.895 65.582 m S Q
+1 g
+71.242 48.551 m 65.586 42.895 l 71.242 37.235 l 76.898 42.895 l h
+71.242 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.132996 cm
+71.242 65.582 m 65.586 71.238 l 71.242 76.898 l 76.898 71.238 l h
+71.242 65.582 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+14.547 71.238 m 42.895 71.238 l S Q
+1 g
+14.547 48.551 m 8.891 42.895 l 14.547 37.235 l 20.203 42.895 l h
+14.547 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+14.547 65.582 m 8.891 71.238 l 14.547 76.898 l 20.203 71.238 l h
+14.547 65.582 m S Q
+0 0 1 rg
+42.895 48.551 m 37.238 42.895 l 42.895 37.235 l 48.551 42.895 l h
+42.895 48.551 m f*
+q 1 0 0 -1 0 114.132996 cm
+42.895 65.582 m 37.238 71.238 l 42.895 76.898 l 48.551 71.238 l h
+42.895 65.582 m S Q
+1 w
+q 1 0 0 -1 0 114.132996 cm
+184.629 71.238 m 212.973 71.238 l S Q
+1 g
+184.629 48.551 m 178.969 42.895 l 184.629 37.235 l 190.285 42.895 l h
+184.629 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+184.629 65.582 m 178.969 71.238 l 184.629 76.898 l 190.285 71.238 l h
+184.629 65.582 m S Q
+1 g
+212.973 48.551 m 207.316 42.895 l 212.973 37.235 l 218.629 42.895 l h
+212.973 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.132996 cm
+212.973 65.582 m 207.316 71.238 l 212.973 76.898 l 218.629 71.238 l h
+212.973 65.582 m S Q
+0 0 1 rg
+1 w
+q 1 0 0 -1 0 114.132996 cm
+326.359 71.238 m 354.707 71.238 l S Q
+1 g
+326.359 48.551 m 320.703 42.895 l 326.359 37.235 l 332.016 42.895 l h
+326.359 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+326.359 65.582 m 320.703 71.238 l 326.359 76.898 l 332.016 71.238 l h
+326.359 65.582 m S Q
+1 g
+354.707 48.551 m 349.051 42.895 l 354.707 37.235 l 360.363 42.895 l h
+354.707 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.132996 cm
+354.707 65.582 m 349.051 71.238 l 354.707 76.898 l 360.363 71.238 l h
+354.707 65.582 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+156.281 71.238 m 184.629 71.238 l S Q
+1 g
+156.281 48.551 m 150.625 42.895 l 156.281 37.235 l 161.938 42.895 l h
+156.281 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+156.281 65.582 m 150.625 71.238 l 156.281 76.898 l 161.938 71.238 l h
+156.281 65.582 m S Q
+0 0 1 rg
+184.629 48.551 m 178.969 42.895 l 184.629 37.235 l 190.285 42.895 l h
+184.629 48.551 m f*
+q 1 0 0 -1 0 114.132996 cm
+184.629 65.582 m 178.969 71.238 l 184.629 76.898 l 190.285 71.238 l h
+184.629 65.582 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.132996 cm
+298.012 71.238 m 326.359 71.238 l S Q
+1 g
+298.012 48.551 m 292.355 42.895 l 298.012 37.235 l 303.668 42.895 l h
+298.012 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.132996 cm
+298.012 65.582 m 292.355 71.238 l 298.012 76.898 l 303.668 71.238 l h
+298.012 65.582 m S Q
+0 0 1 rg
+326.359 48.551 m 320.703 42.895 l 326.359 37.235 l 332.016 42.895 l h
+326.359 48.551 m f*
+q 1 0 0 -1 0 114.132996 cm
+326.359 65.582 m 320.703 71.238 l 326.359 76.898 l 332.016 71.238 l h
+326.359 65.582 m S Q
+Q Q
+showpage
+%%Trailer
+end restore
+%%EOF
diff --git a/doc/Components/PhaseField/img/fclinear.png b/doc/Components/PhaseField/img/fclinear.png
new file mode 100644
index 0000000000000000000000000000000000000000..806651edecb60af7b780e79dfa9c26ebc4fea0cc
GIT binary patch
literal 7746
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

literal 0
HcmV?d00001

diff --git a/doc/Components/PhaseField/img/fcsimple.eps b/doc/Components/PhaseField/img/fcsimple.eps
new file mode 100644
index 00000000..20c09762
--- /dev/null
+++ b/doc/Components/PhaseField/img/fcsimple.eps
@@ -0,0 +1,388 @@
+%!PS-Adobe-3.0 EPSF-3.0
+%%Creator: cairo 1.14.8 (http://cairographics.org)
+%%CreationDate: Thu Nov  1 14:24:13 2018
+%%Pages: 1
+%%DocumentData: Clean7Bit
+%%LanguageLevel: 2
+%%BoundingBox: 0 -1 398 115
+%%EndComments
+%%BeginProlog
+save
+50 dict begin
+/q { gsave } bind def
+/Q { grestore } bind def
+/cm { 6 array astore concat } bind def
+/w { setlinewidth } bind def
+/J { setlinecap } bind def
+/j { setlinejoin } bind def
+/M { setmiterlimit } bind def
+/d { setdash } bind def
+/m { moveto } bind def
+/l { lineto } bind def
+/c { curveto } bind def
+/h { closepath } bind def
+/re { exch dup neg 3 1 roll 5 3 roll moveto 0 rlineto
+      0 exch rlineto 0 rlineto closepath } bind def
+/S { stroke } bind def
+/f { fill } bind def
+/f* { eofill } bind def
+/n { newpath } bind def
+/W { clip } bind def
+/W* { eoclip } bind def
+/BT { } bind def
+/ET { } bind def
+/pdfmark where { pop globaldict /?pdfmark /exec load put }
+    { globaldict begin /?pdfmark /pop load def /pdfmark
+    /cleartomark load def end } ifelse
+/BDC { mark 3 1 roll /BDC pdfmark } bind def
+/EMC { mark /EMC pdfmark } bind def
+/cairo_store_point { /cairo_point_y exch def /cairo_point_x exch def } def
+/Tj { show currentpoint cairo_store_point } bind def
+/TJ {
+  {
+    dup
+    type /stringtype eq
+    { show } { -0.001 mul 0 cairo_font_matrix dtransform rmoveto } ifelse
+  } forall
+  currentpoint cairo_store_point
+} bind def
+/cairo_selectfont { cairo_font_matrix aload pop pop pop 0 0 6 array astore
+    cairo_font exch selectfont cairo_point_x cairo_point_y moveto } bind def
+/Tf { pop /cairo_font exch def /cairo_font_matrix where
+      { pop cairo_selectfont } if } bind def
+/Td { matrix translate cairo_font_matrix matrix concatmatrix dup
+      /cairo_font_matrix exch def dup 4 get exch 5 get cairo_store_point
+      /cairo_font where { pop cairo_selectfont } if } bind def
+/Tm { 2 copy 8 2 roll 6 array astore /cairo_font_matrix exch def
+      cairo_store_point /cairo_font where { pop cairo_selectfont } if } bind def
+/g { setgray } bind def
+/rg { setrgbcolor } bind def
+/d1 { setcachedevice } bind def
+%%EndProlog
+%%BeginSetup
+%%EndSetup
+%%Page: 1 1
+%%BeginPageSetup
+%%PageBoundingBox: 0 -1 398 115
+%%EndPageSetup
+q 0 -1 398 116 rectclip q
+0 0 1 rg
+212.973 42.895 m 184.629 71.242 l f
+0 0 0.964706 rg
+1 w
+0 J
+0 j
+[] 0.0 d
+4 M q 1 0 0 -1 0 114.136993 cm
+212.973 71.242 m 184.629 42.895 l S Q
+1.00063 w
+q 1 0 0 -1 0 114.136993 cm
+71.242 71.242 m 42.895 42.895 l S Q
+1 w
+q 1 0 0 -1 0 114.136993 cm
+71.242 71.242 m 85.414 85.414 l S Q
+0 0 1 rg
+81.414 32.723 8 -8 re f*
+0.754248 w
+q 1 -0.999997 -0.999997 -1 0 114.136993 cm
+85.414 -4 m 81.414 0 l 85.414 4 l 89.414 0 l h
+85.414 -4 m S Q
+0 g
+0.75 w
+1 J
+1 j
+q 1 0 0 -1 0 114.136993 cm
+0.375 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 85.414 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 57.066 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 28.723 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 28.723 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+0.375 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+28.723 0.375 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+57.066 0.375 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.136993 cm
+57.066 57.066 56.695 56.695 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 28.723 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 28.723 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+142.105 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+170.453 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 57.066 56.691 56.695 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 85.414 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+312.188 85.414 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 57.066 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+312.188 57.066 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+340.531 0.375 56.695 56.691 re S Q
+q 1 0 0 -1 0 114.136993 cm
+340.531 57.066 56.695 56.695 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 28.723 28.348 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+227.148 28.723 28.344 28.344 re S Q
+q 1 0 0 -1 0 114.136993 cm
+198.801 0.375 28.348 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+227.148 0.375 28.344 28.348 re S Q
+q 1 0 0 -1 0 114.136993 cm
+283.84 0.375 56.691 56.691 re S Q
+1 w
+0 J
+0 j
+q 1 0 0 -1 0 114.136993 cm
+42.895 42.895 m 42.895 99.59 l S Q
+0 0 1 rg
+48.551 71.242 m 42.895 76.899 l 37.238 71.242 l 42.895 65.586 l h
+48.551 71.242 m f*
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -48.551 m 37.238 -42.895 l 42.895 -37.238 l 48.551 -42.895 l h
+42.895 -48.551 m S Q
+1 g
+48.551 42.895 m 42.895 48.551 l 37.238 42.895 l 42.895 37.239 l h
+48.551 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -48.551 m 65.586 -42.895 l 71.242 -37.238 l 76.898 -42.895 l h
+71.242 -48.551 m S Q
+1 g
+48.551 14.547 m 42.895 20.207 l 37.238 14.547 l 42.895 8.891 l h
+48.551 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.59 -48.551 m 93.93 -42.895 l 99.59 -37.238 l 105.246 -42.895 l h
+99.59 -48.551 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+212.973 71.242 m 227.148 85.414 l S Q
+0 0 1 rg
+223.148 32.723 8 -8 re f*
+0 0 0.964706 rg
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.136993 cm
+156.281 -74.867 m 152.281 -70.867 l 156.281 -66.867 l 160.281 -70.867 l
+ h
+156.281 -74.867 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 42.895 m 184.629 99.59 l S Q
+0 0 1 rg
+190.285 71.242 m 184.629 76.899 l 178.969 71.242 l 184.629 65.586 l h
+190.285 71.242 m f*
+0 0 0.964706 rg
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -190.285 m 37.238 -184.629 l 42.895 -178.969 l 48.551 -184.629 l
+ h
+42.895 -190.285 m S Q
+1 g
+190.285 42.895 m 184.629 48.551 l 178.969 42.895 l 184.629 37.239 l h
+190.285 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -190.285 m 65.586 -184.629 l 71.242 -178.969 l 76.898 -184.629 l
+ h
+71.242 -190.285 m S Q
+1 g
+190.285 14.547 m 184.629 20.207 l 178.969 14.547 l 184.629 8.891 l h
+190.285 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.59 -190.285 m 93.93 -184.629 l 99.59 -178.969 l 105.246 -184.629 l h
+99.59 -190.285 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+354.707 71.242 m 368.879 85.414 l S Q
+0 0 1 rg
+364.879 32.723 8 -8 re f*
+0 0 0.964706 rg
+0.754248 w
+q 1 -0.999998 -0.999998 -1 0 114.136993 cm
+227.147 -145.732 m 223.147 -141.732 l 227.147 -137.732 l 231.147 -141.732
+ l h
+227.147 -145.732 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 42.895 m 326.359 99.59 l S Q
+1 g
+332.016 71.242 m 326.359 76.899 l 320.703 71.242 l 326.359 65.586 l h
+332.016 71.242 m f*
+0 g
+1.066667 w
+q 0 -1 -1 0 0 114.136993 cm
+42.895 -332.016 m 37.238 -326.359 l 42.895 -320.703 l 48.551 -326.359 l
+ h
+42.895 -332.016 m S Q
+1 g
+332.016 42.895 m 326.359 48.551 l 320.703 42.895 l 326.359 37.239 l h
+332.016 42.895 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+71.242 -332.016 m 65.586 -326.359 l 71.242 -320.703 l 76.898 -326.359 l
+ h
+71.242 -332.016 m S Q
+1 g
+332.016 14.547 m 326.359 20.207 l 320.703 14.547 l 326.359 8.891 l h
+332.016 14.547 m f*
+0 g
+q 0 -1 -1 0 0 114.136993 cm
+99.59 -332.016 m 93.93 -326.359 l 99.59 -320.703 l 105.246 -326.359 l h
+99.59 -332.016 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+42.895 71.242 m 71.242 71.242 l S Q
+1 g
+42.895 48.551 m 37.238 42.895 l 42.895 37.239 l 48.551 42.895 l h
+42.895 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+42.895 65.586 m 37.238 71.242 l 42.895 76.898 l 48.551 71.242 l h
+42.895 65.586 m S Q
+1 g
+71.242 48.551 m 65.586 42.895 l 71.242 37.239 l 76.898 42.895 l h
+71.242 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.136993 cm
+71.242 65.586 m 65.586 71.242 l 71.242 76.898 l 76.898 71.242 l h
+71.242 65.586 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+14.547 71.242 m 42.895 71.242 l S Q
+1 g
+14.547 48.551 m 8.891 42.895 l 14.547 37.239 l 20.203 42.895 l h
+14.547 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+14.547 65.586 m 8.891 71.242 l 14.547 76.898 l 20.203 71.242 l h
+14.547 65.586 m S Q
+0 0 1 rg
+42.895 48.551 m 37.238 42.895 l 42.895 37.239 l 48.551 42.895 l h
+42.895 48.551 m f*
+q 1 0 0 -1 0 114.136993 cm
+42.895 65.586 m 37.238 71.242 l 42.895 76.898 l 48.551 71.242 l h
+42.895 65.586 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+354.707 71.242 m 312.188 28.723 l S Q
+0 0 1 rg
+308.188 89.414 8 -8 re f*
+0 0 0.964706 rg
+0.754247 w
+q -1 1 1 1 0 114.136993 cm
+-170.455 137.732 m -174.455 141.732 l -170.455 145.732 l -166.455 141.732
+ l h
+-170.455 137.732 m S Q
+1 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 71.242 m 212.973 71.242 l S Q
+1 g
+184.629 48.551 m 178.969 42.895 l 184.629 37.239 l 190.285 42.895 l h
+184.629 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+184.629 65.586 m 178.969 71.242 l 184.629 76.898 l 190.285 71.242 l h
+184.629 65.586 m S Q
+1 g
+212.973 48.551 m 207.316 42.895 l 212.973 37.239 l 218.629 42.895 l h
+212.973 48.551 m f*
+0.968627 0 0 rg
+q 1 0 0 -1 0 114.136993 cm
+212.973 65.586 m 207.316 71.242 l 212.973 76.898 l 218.629 71.242 l h
+212.973 65.586 m S Q
+0 0 0.964706 rg
+1 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 71.242 m 354.707 71.242 l S Q
+1 g
+326.359 48.551 m 320.703 42.895 l 326.359 37.239 l 332.016 42.895 l h
+326.359 48.551 m f*
+0.968627 0 0 rg
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+326.359 65.586 m 320.703 71.242 l 326.359 76.898 l 332.016 71.242 l h
+326.359 65.586 m S Q
+1 g
+354.707 48.551 m 349.051 42.895 l 354.707 37.239 l 360.363 42.895 l h
+354.707 48.551 m f*
+1 0 0.109804 rg
+q 1 0 0 -1 0 114.136993 cm
+354.707 65.586 m 349.051 71.242 l 354.707 76.898 l 360.363 71.242 l h
+354.707 65.586 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+156.281 71.242 m 184.629 71.242 l S Q
+1 g
+156.281 48.551 m 150.625 42.895 l 156.281 37.239 l 161.938 42.895 l h
+156.281 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+156.281 65.586 m 150.625 71.242 l 156.281 76.898 l 161.938 71.242 l h
+156.281 65.586 m S Q
+0 0 1 rg
+184.629 48.551 m 178.969 42.895 l 184.629 37.239 l 190.285 42.895 l h
+184.629 48.551 m f*
+0 0 0.964706 rg
+q 1 0 0 -1 0 114.136993 cm
+184.629 65.586 m 178.969 71.242 l 184.629 76.898 l 190.285 71.242 l h
+184.629 65.586 m S Q
+0 g
+1 w
+q 1 0 0 -1 0 114.136993 cm
+298.012 71.242 m 326.359 71.242 l S Q
+1 g
+298.012 48.551 m 292.355 42.895 l 298.012 37.239 l 303.668 42.895 l h
+298.012 48.551 m f*
+0 g
+1.066667 w
+q 1 0 0 -1 0 114.136993 cm
+298.012 65.586 m 292.355 71.242 l 298.012 76.898 l 303.668 71.242 l h
+298.012 65.586 m S Q
+0 0 1 rg
+326.359 48.551 m 320.703 42.895 l 326.359 37.239 l 332.016 42.895 l h
+326.359 48.551 m f*
+0 0 0.964706 rg
+q 1 0 0 -1 0 114.136993 cm
+326.359 65.586 m 320.703 71.242 l 326.359 76.898 l 332.016 71.242 l h
+326.359 65.586 m S Q
+Q Q
+showpage
+%%Trailer
+end restore
+%%EOF
diff --git a/doc/Components/PhaseField/img/fcsimple.png b/doc/Components/PhaseField/img/fcsimple.png
new file mode 100644
index 0000000000000000000000000000000000000000..86bfcffa64d409c977e9ad20d316f66524d2a82e
GIT binary patch
literal 8406
zcmd6NcUaR+vuFrKnqm^9*AN3LEui!oA_NUZQR&h_q<56A2nih(2?!#nprZ65JzxYB
z1Ocg`ihxQN>5!aXeBbZfbMEup|8Jgb%1+stoyqQ$5KN5?j<O4|gFv98hFHvH5C{wf
zJ`-74fY)*YND6pk3P2lPVFe!Htj>7gJDV@oG5`cRMy3yjj5Egsfl2<r^A>?-KCXcw
z4*o8nkdP2rcW;jXCkI~_Ss#D5$155FAdncy5Tkn~G-r9@R*q0mE^XahI9D|QmXhX-
z#)73<Pjs?(ivMPnWrga-UgiC6;mf;K^fa24RrbsszS8q+I^3dr7Upx?0k$qDnDoK=
zJa-uSbWB$i@85N<4@+6uqf%e4IP?VCY7UwmMrw&XI6zGd<~iSVy>4rJD8n%V?tZ$?
zN4gNkN^k*Lur@yYEu<F&7L2K>I+Bh%4GxG7AG^zm;tgf#e4!EVJaBC-%0W3>G5SeW
zJl}gSQhilC5u*gU*e~K3J4*6!=R(DuSz|2f3pCdf_^dxYK%X!oy#bIN*r?kDOqIuW
z{KoWf@OI-cFa!e0YUGB(;c#dc8jZnV;AU7n9*=cqX9GY4oVYjuN<W1FAP9wfu>c5D
zn06cjN$>psh^Wq;OAHRTG(R{=v}K$eVcfrRW5RSe9f6`N@k+5$+alnmD3fyZk%wcF
z_ELs;x}wNv#_u=B+Zp$e_B@97d(!`hPL`W5k`v8x9joR@+yXu&FQPNHjzg`_B-i=~
zvjlz#4Ui#6&D8hJ|02<}J*w)g21In63+i^X5weD1X%MS*I~*{p7Lz$3f_C(a2^R2~
zx_QLvMq^!}In}$WZY)|a=5Rp7IacZ50RtvGE|JC=7Cd%0$(Lnq_3WfgEkjtLW-R$K
zScy^ng=QzKIfw>c%GnZ=2sEcg8YCztxk&gju9doTDYPM<=4>5@!weVxm%$c+Z=Fmi
zl(t+lmTtVw`Q0MP4DjT*>M;xRj#~)bfA(b2xy<U$#E?4d9eYBrE@k_dY6e1&jvq8s
zqef1SI=WlbTF;yyg%rr6@0I|r!zJyADGmpwle_CA5Iz>Lq1&oJ9HiR{%Z3<a+|Ss_
z+^5S~Rgw@w(X2wJ;LQ%Q=Rt;pU3OWYvuXQqy1Wd@BxWjRRBqWF^Q$)yy>4zF$<btW
z@2bMnS%3NAJ9W$nMah15M@tqbA9T%KV+@eIt@bex%c)Q9+ZpEgaSey9$ugFrLPG^D
z)bECf{*g5fJDtAMo=l)q3=9p`^#1udz$=C9Pwz{UH(M)B^gBy!>0>Aa7q<$f%{#+4
z9n_wNs{0<VQlZ9I!$ONs!0sP?@AxgyK5nr-q^7#M>1Rp9ivMa0Eiz=jJB!1=Zajjt
z;%-90DeysE+1H|CocO4##n(62y+6b{C;p87Mgzs~FgVQGC6<1;3JBK-fz?Dz*4Nb3
z9In(a%DV0To|Cq%e>hld-k|8#lVhi<kWVCv@pBOTBnmE|#Q7DkVXmA)A`;cESq>Qq
zYOdCoaL9#^ST=|6PP=i#es-E-zb4^N18b2};B<m4g@K@n1~v84?0|OuQoqf?hJeMl
z?@Px@h{RBSHa11(ov5!VbOM~e?mq<bbb{A%ZsYzJc{8v7@}JK-Odzm)!Dm{lGyY%;
zHXC4{&$Rz!kLyfjkhexRKAu$y6wi|Xzs`~9<W}#Sh3J`DQz>0lGIfPt>X^>V+;LQ&
z?e2}Uf-xpVnq)pDhD!R;b8=@Y@xiF)aFA%Ol9!eH@>sR&%PzT9<r-W0sYCCNNmY@D
zx9M9EV<WrGd#B~GlknQC8r8a@-FXI2_MA4taKMicSsGRQ2$)~5ea!94qn@|2`)PBO
zdD%-!$-V8m0pCPT@eQ1dqK5Ox+NdnS%<Xb#&GH2HJIRf=HY}=cq}$47hA{FNjlcWs
zc3(6dB+o(8FjH+i{)a!?Tr~kT1eTobgAjZJG4OZC4G^H)+jrWEsSp;qX{{;qxHiyt
z6IPVDvKkx`mxBG;Yi&C`QSUig5z|85EPa-um87B2H!$FIO#5K%{;Wz9NnKAPB?TMn
z#6r6vFRlkBb#p;rm*8M-sKY759S(jdsOjR}4$N~r=pM#`ov?Sic(LAkdm>~?xSg!r
zoSrHGd78$0=At-*xMLgR1{Y-hGB);E8mlZCt5Zh&p=c^)fM+$u#=b~<+0rt431{PP
zIH{9bzC3UwT0+9pP8?#4>`CWqyDg%^848g~_G6rl`onlWmsgzsOFhHVdy;2dbN`P8
z=0lN(nj{vF)w4)$!;$*Sul}TTh(>8deNQ)dbUkc2d4YL1{K+|wlvCD2uPYWNe(3n=
zCIl!YC*5OO5<{MbwEmpVJ!->r&%=z*6yY%Y0do%CO(1o|c;x#UCfrRxxLm<~-?){c
zxi#|paC^#5VgAzzl3ToVkxbCTzAn6V?_E_Pi=&eoWu9f6z5*87Yd&U7-L+5cbsHkz
zeL@V^Gwh{A|86qPSzg_^0xy_tIizrduIcvOQ956R3tqhNqW{w3aB0har$lPb*y!lT
zyIfi-rm~r|V>?F!#~E*h&O*P}7OH#Kxcm?zq<4cyDyn~9-{(r9hOgsj)w69u49YJ9
z5N&;`(AM)B29D1so9vw!YQoaAz5gt5@S<CF)*mn^k0ke`v+6BiagB^Z9X~^aia3R|
z_6Bx~^QU#G<I$7>Rp<;cNhJMc#gn_W6Py>RBF(hBeR)0&E}iLYfzD`T%aG)BnP_W|
z&s|ES*51al-5<TS@bcf%Mg~ad3TtcG%vBQCyD)>O`dRi)!7}gPsiuM9PInf%8k6Fg
zNQ|ZL8P!$l^NDG1ESs1|)Tj%TmhY>J32YyeKC4p$JBkkRrns+quvpCT1U7f2zk_i5
z5|;Ba4qJH%82mgip1^R;WkQ9HI0{FRF+FSV4V;q!rgT^mLGX+Lk{gCPh0u53H=gT^
zbwp>=N3tW_kez@!g?v6L^>^GaNaGtWBbGfq{8l9ieI@rH_N?Fs43rzHe)d-<W{i>W
zb(9X3S&qT{dNVta5rlk=O5f6Xkb*8K%t!f=@*KQS%fN5e;|6YN{jA2J%@~aE)x0Ca
zM<{D&Bynv{a^T4gg;#Op>?=ilUgifyXv6Mmb$Q9jnz3lxytuZ@z86hzR?$lJ&vD%_
z48ub_?FEu+d*w)WS#pHB`si2dHG{{xBY3V)G5R;W*Lijr^%+Eks34bh^@;kkww&e6
zw6OBN<~W&*R4+D94-|E^l8@GYY<iD(rgG!y_Qcwz{yy!d#bDaV{a@VAjNTsPl5Hwu
z{13dEDwwT;<4&15tlCbOcfg1;iy8tOR<d#Jl!XvvUEOPOkpOEsub5K}I@V{Tvzbi}
zPR5Mh|INCl_9YLvjzitK<XP@&n?GCL@M({_Kb%Xd*~5O{Unr0%i{P~wWKk??TL?TW
z`&9oxH}A{&1`y2=Yl5hHOR?Xo%;1QK(8~96&5|8EVT0yf22Wo^Y%f&`)>Ccjz6`%$
z^HS^z>?@h}W_n_L!+MIb{ap<Xu{a&4eNFbyrU@O2dnSD6F_V%P!=m)`EZ`Q$dYeHu
zpm_nnaPb>7rumy?&4t95Mv~V0{aX{C*oadljgR$wj%Flz(ER6^y5+7;3hdR<O<mdw
zlW)0pOS!|y-Q?>_ZfN?^L^h5wxeH<N^u2$aj43}2|6;kp^apeE-y19~$qaC=pYJLv
zdSV?Nh1dxrV^Ke7_P_;L$p?62mF<Hq419CYFCzt)WFnr<3W)T$mH1M&=q-^>nq(lJ
z&iB{9fO!X$gKkGMurez*l<?m^4fyS817x-q^1h8hfv}2l>+(rQpDoIQy>XVhU+M@|
zZ(5JUZ2B&;(fY*9n#Pj0Ux1-7uES2_ZT?bM%)SWOFU)vcq9%&}-SO@g-F36siPyX-
zKkqdmy=7nB&5hwI)Ffl0-cvG#I}?<R#wCJnnCI=zpw@e5CqBuqV&0E4!<5Z$-?td8
znDEPKI76|@AZ<Y{M}J4;__f(AS~{62t<L;bhY=T*>}|^)^BCVlyT2hywauLGIJKqL
zvv^BIET&H2>Lc@-oR#{OyF2>_b8Mb+=@~L6-;*lcHgfz%U5%%o(b7pa6HM3J-mRgc
z&XM|1eH<MpyuzOTs25ZefmvQ3^<S`&trdx?Ti$?<T!){rF8RK6rttS`cb7`bkJ?eH
zF?B->+Q)(i4z6aLkT>`c>o9pF>0FDaKS!S8(ohD;CixR56{6QLs}fRMRrRn}ZBg26
zbduM}TQL~B16j{mP_UP7eC`OxU`ZCJOR*9ODP~LRJJXk^BKI?H+lE-jIl+s?Q4>KE
zN7U8SE)?YkTLtB%3c||uz9D)v+?0Cxhkv1JuD&6YJ0kf4O1#mw9OAU}bh;9}fD%3*
z68u*S&c7&F^j^B#<kU0xvO)l=zTjWi;nqz=`F=W8bft6xqKtHm2W}IgGd`Z|8AO%U
zV$=dV1S)?G2ZVcJJ!{?GM>w4|=s0vO0OH@hQPcpZBvkRWx38)8hnJI<+t~>))kDoe
zJjjW}*-rMe@iR%PL&q^)adZT++ex+M0~Yxs9Pazklj7PaV~v}l?q?>XRK5j82|AVN
zXM9K_(hcP0<ux~TFt6Os=Oo*5@cWk*?I#~4`2=)z?!DUzxw8F5N3<J>kMip+nanI6
zDV5T1^ds@~T<_a<jGT~J)iSj?q^a05;rwjVLB-DrkJ6Ze#pa;}yQ)(j6?}h{-UQ+u
zp-|wuO<K4$-?-6J+)i#Gk9faHv-oJ4X*_#k)?&9cVlv;}YQ)ia`aos%B`Xj(+`IT1
z<uG!1*q&{tu&O?+$jI2PvC)Xyc*MmQGLslrqUqQ@_|own`6d441u-N%p8Q1uGKj~@
zBjK@3Ix}Bu1Kivn52%?Y<6kFrV203+S1?yj9*3pteZ%yqggIlbXhZP?Z@6tPDr%)+
z=T&Cy#N~5vmhD~h>mU7b&N2uViEn)dq7kzmL>vxtj8G0Q*h|;JVOZIs+fEj(!Fnrs
z9v+b>I88x8R1xjT_*h5yW$cm^9GXDDieHM=3(GkbaqsS=cbq;3M#elsJFd+oo%0w<
zs_X4Y0x-&-;jvQ4dctvNlP_*E_~M6Wv>wi6JQ7ckzDFiP((Q2=c7pJE3>pPFh2Y#U
zIc078WV<<)=m1GSB;vWD=Oi3+h-GLE{U2$pPzW0t^COLK*S|efK>%jSM#zSs^l>))
zzftITOd6h#AGSJkhl1`IH0u0|^=?00$q9Z&y!<_$??B*KDuD+37ZodpM90TEP*1(T
z-ow{hMzkoC`fihaIuOg0f`5%iK~5vuFqm#4>j|i?gyY&{|1O?^5E8?Sf?3aAEY4XR
z0XD!4o-nt8oJ6AUVTgD<KWrkFmGBgTde_?mfjw4$!Yo+{IuO*(xjz~K)ZGOG0>M<g
z{C=hE+b0(Mfq5Zsu=F+PToii+6=^<|+_3gGS`6=Z-UIFqzepF$AxQ01WJ9&%hXhip
z|8n)P|IZhh;6|{9=(MalgDq*yO1Zn-S8cqZifqGaJe>uS=H!XfdpEneuL372k3C4t
zZ(*K1=&-7_X)RTc^31C+@A_Rk^0uWJrl!vL*;&b_khb=|OM@EPd_`8YkN;;*Qd~Jh
zsPdXKz3w0w3XT#jelg&e69%M3)a~(r)QB&-N0=ki66KnSi={0h)6COzppYz%CGbJ>
z&{69Vw<3j>v1i@VoXfGQBW~6aBZYa4@1h16h1RbuhrKCnY;er$@R<1R9I0@qzGZna
z=UGaX6>Z<`OF#4ma-;v^A5nkoXyaO&Yq5>i^Al8|A1TT1Fsj_jXCUn*L#KI3{h-?1
z<@%Mw<>lqX)rM6qx6ulh7!eZRd)0-U_n(!gIM<|G3*K==$viUfm?%qT3|U;@-Ox}&
zRY7j%6?Jmo9*qwwJ$P~#d_diuee7^SRQgq&=#%%Ut`p9-bwxq_C=2aIhMee@yVT#(
zLKPL=g`edvZ5^u#o%vuN;)z9ee|mH{=f4|5QWpuGX1EhaCXql~8f%~$udpWzhjLV|
zb*o1V8?0-%PS=2aPLZhqiH7)MR#J_I+UH>QP%cKU!RC&;1NridlQsb*nIqK!4d;St
zPnl?Her{a5<FzcjG~qq}vuI{_p|vJ&<I|j2-^tAfa+zHon!W12Kvu<clz`4B>2YZ~
zpWZ(Z0Bjwi&POzij+k^9NP49aw1srFYRx+W;`20fL_Qu(*$0^_;%8!P4_mfhsSYQ0
z=VsNah2-s#<CHdj71vaYji_nNf0RU(HnTt4T;QR7jC;Ni)Vm?_^XE^?y?E_|n5W|9
zUKFLFx7Kb#9j7w7=JumA!Q)=cU(iqUHcFS&k{7i9sD)W0m$Xtlgghjyjk+S3)W8*m
z9BMVB``H0aB-wzyrJ)IH5sLhWv8oTQ3u3({(VHf1kKXdEN%|@?H<&qbgr$%Nqj$UA
zw9GbGjiaJkEbIJVxLID~-`PK&3i<US`GM-Kp_n1Lea}xZc4NM8?`O5T2EZ4>HOMyk
z*T;Uu*e2AC!<s7HxI$AkuWitZ57yonhV1<TPGhQrb(vdtvMh(3mj&tQBbThw$j#z&
zEpfZylR`mXFS$@^_SaL}nN9#}n5hQML=H_bDrv^)>^HgD6nAvbxNlrH)|MgLOvHw|
zKV#)cEZGlVU1{J7HPO5pmS@*A#!VT!aDLd<$^IrDxb=CikNJ91sLfuK$?fLtrfj?S
zZ>?*y=eja8Jt?xF`1sHqQ#r33(#NhxRy6D2wxtbE<&8I+lNYo?arioPb5%J-t9^N|
z*wTL_`qt0EY?|HtRzq@Dg~6x_$BMkP=TVgTvxLBklT3I5l^Pk)#wPht0>gw+8CAgH
zRQljxc#fwkAFR@KSswWs()YN_<s@88P@I9m37*&cIHY+a7syTl9DWTX+<;EzFOQt>
znQ*{4%l`*YAEOidKnBQKzvH8^lGZFqgr)OLWLCBjT^u=y6~D99D~7t1jNkU}VTQ~n
z{MqWYLS2g7aTrjHsJZnimp1H0m8*Z#c>$}FOvLj;j;}B0RXf42VRXo~Q9St`2B=Hd
zo5ucB1!W)Y5$Sc2f{Uq(Gw3;f8?yEhR)z!V7sH)Aoj-9{AKDvXSUDhT%VDKHZafnB
zWsD9Se2CoN;{>GPWaE=SLh-Ela<RdWIT{{yn_ZLTj&N6u&UfZl?Wu%c>G;e5bxq|&
zUY4h6<mw9o=O3ZL?F0f79PB8K4LV&U8=e?6%!h)g!^M8zxiZ^<*~F3udJbA}F3*m9
z=z{kQ;VZbI^2RvCamaBe-Ph|*@Zi6^<H+Q1dhs2YIV_oFf9>d7&vmi9zx<cdqA%cV
zf(EY|0^-@g!`=|FVsJ5iEa?Z4Z{5G$Q!3}OrLp=MRC;w<v^Z)#qcr^FD||HZqI2G-
zR~rCBID`R(2J3fVb|=FO8gtUMiz;%0p}bliOqLvMd=MDhKWqbW2q@&Z1Omhvur0y^
zdv?7?%Esm&##k)KhLPB`JxQtbYGBIY4hSok8w*m9>{TVzSN0Zq3Vkxf(049cqg!U)
zKWb&dy(nhVec(b<-T1Tjc0HX}aLy<MDV6Y8x=SH!xjNI05-dmM|KW%5?JMDuwsH;1
z6si%77pYV<$=de6J$_Lu1O~`)+o2Z-cfP8Jtmu?iS6>O7*gwj7OFOX85uPZ{5Q#hZ
zQsd>b{_Vru1&okTz+<{Z@FHnD$G0--fB51>6sPtc)ZXV35e_J^5NEI_)^@AdKE@5}
zo}3NNNFLbKj{BfD$(8$xh?PcwO3I}@qIVz+Y_|I2sRZ>4iX#s(7#%R(d)k6TZ$)&A
zs$~%fZ{nDM8r=DB226-R{`Chtq=JaIVU4kHFqD-oR064QfVt}G2!ytD+2Xw@6ha81
z;B<Z$J};aET@?3e-Xt0Vc8j4K33VF&S^)+l#4(YY*}Npv(?G;eUwdU7^PW#Wegf?F
zcZb??iGtT_R8Anm(E}e4u{Y1PW6)rGo=P9f&TnFi)l7XxfPB;j)pj6$!2QJ{iPv2u
zNkXBZhO$Mu`M%8tM9q2hU)7zL@Gn1MaIsctr|})o$?Kk!(d#2Ud&2`yoSvs-7Yo<W
zSlL0^Ycy}J{cBfWY3n^bpNkxFRcdO^GD@zhfP=iw@y`F+L4IdwK6d`;^3*TwjMytI
zH%t80`mWDq7$Nqbt3Y_<zFG{{9&S*3Ll&nFBU)xXU?}tc`^VS}9|9!-qYh<ppJ*ST
z9H5G$5>2sZHRyR;iqF*)9583dnM}CDysZ3O^AaCB!7yI{HpKO`l%p_Qb6R+xWM$j?
z5%bH*0w>L~xZk?6Fqa=;q$vq|m3kAmc2#PLc`J&!!R{7E;MYcyi{>c=GI>i>cM47P
z7jB*6-#A_7ap($tRg~hht8MzZqcullNo#19q!lE5@wxYyHrG8D((ZJwC@|SXf^6oz
z=28EAB(tn=9P<0v-rgsK+hH3mjQxw%?0bgg4TasqZd&oZj}^U(_*gs+%u_8VEc~ax
zAO1i$EutCq{JH|r$xyiUZ!3d03X*CBgcIm9UyKz3s%KhA+2k6vS9NI*&#Lf7&9&-N
z7AWg>+(wQi!3R-pP)at-8xwo=`%jGRAwYE^1gv^LtC*2S@B<*nJPqyDjoyEVg3Q-f
z9pRtRu|N5-JBYhX+cyGC**k*lO1!4<1WFBiBjA;1#~_4O2oUCy2Hm$9nYXdG22;}i
ze2@7|;_U}o0<iT=im_v!HnaBAmItI7Ef!BBfb+B46>|&pc7$TIlc8$~kG%t$a$B&>
z4ImBN><`@!=UC&ppXH%^u)2(>3GxI}(gOJp?2?jedgYjc#k1<RK4|w7$u(Nhv{*fG
zzv}<&^$e&%;R<X_s{KoY5$x#%#pBaT$>qIg5XemMTG$;?!`m-XD)BgwkGe%my#JSo
z=609I=LK?`m>ZApH)iZLyyk{JNT_C@2}{9^3TDNtdM}!}AD(;QnK%5uR{6K1^w~Fs
z{DdTQaN?BFCxC102hu@R{P8TE#29{euD&-Fk(h5cC^gzl-Avw?F6)b1xz3cWhM0*M
zkA4w-XK)S>1Gkd2NRs^`h5Rn6h?E+yeK!Lkzu3)ta^VbJ6<UszEh8x;qG8gFvK1u~
zGVW({Yc2znSwKwlRPU;I<C7aa<{tj%nJ6<Y`$7VN`|P(FD$qgW+qQF{1h3}Di&#xI
zM>L??i9V4VkJ~GxohVzMF<dVx(Lt#Bn@WPwCxI?no9A>jz2$a-)Xul9{jp}bzq~_a
zadT@+z$vK?sQPnKw?lF`hJwts5JaP$;qV)Xi)$^sf}fK~1E`g#LKn-)pGA2q8C@<w
zDw}ukU9x!ppvciP1gL}aZTl#>uBEcTBoQeh{E(|`<XALZ=pM$`??3t5gcPF96wAab
ziO@ffxe7+*r?E-~h@-qQ2yPfV!Iv8-a~=hH3-Em64}Eb+92)-a<^O>yoPgei0Of1N
z`JN0N9Kh)k!09C7ralIY>Ptq$If0cfp$l9wh~so-3NUDl1l;vMh)VRtr2D`5mWe}D
z;EwHpfH}BW@{>m{o54Xrw|2v|zVuuTnz_e&Eu<omQR~q^@;jivy?x}8@kqvcesg;}
zer!SeV1~<ld$*EN>zXn<K^~C%9veX-=C?z<u<IRt%;0*5sNKZEl;B!9H+04s4xIi>
z-7cB7JfRC#m9EJ@mzJdG{OjV`n$rmXS)dKv3?^PJzQ#Pcu-dp`JkZ~NIoNhvStpFt
z@$28MkQaAgthIVH7qL&7I@Z`r`!1=CDp|apGJC))e{$OC6r$}T4!A_Y#6;Qpm-9WF
zU-Y=L+y@FXfOJP9cE8a4pW6H<Rp>ByKHH<@RbB6tUx)A@{+;L#&UL>3m}cw6QNf)O
z7t8r}K_5<TNXqO(nXWzNFVJs(bX86x#B^|1B-(-|f?{cL|FZnmpj5)#?WVmydK<$8
z*yS={mpSJy9TY?Yt|Jb)Hjf6MMy(S}!r?#v?IcWpdn2)~3PdzS2m?EzjBfXc{e@#r
zKnN6#hQGnZG3`j297`ljQMYOfpFNW>rcX=LJ;}UA=md=Izn5{-eT{O0$NXiRb(D<{
zN{=-D6+szckHsOl={<^z;t-qhlNIqFFzCMvDhNZTX}(HzHa%T){vL#=EX#Ws6?Ve(
zeV{-fcWHFNc6b@N)1cTs@UL6>(eKBd6c@`Uvns$-o7o>#`znpK<DI*Sshc_D!wWBF
zlTl})hs~ZCJfD;W0fiDDnar+L7It?o#AO2!>Iog0-i<;*r%5i(=bBe4Ki&rH<dw9m
z@g;Lh3=aF==3l45{KF*dcskqkttTPK>8E(?dBs>JDfshUU}S}6a2e`8yy%_?bgn`F
z^t5&9ZO;E!Pdk&@`T_8V0R#Gf0RXK3G{pmA-kzP`RN_ol<vqJ%lk5uW1R7tg5j(?q
zH@=qU&u5P(oSg)R-m(`@-aqF_uA4*yl`nh^H7Y<r{e~y;LN~w?WO&{fQ-Zd?^Iz1X
BbV2|C

literal 0
HcmV?d00001

diff --git a/src/CCA/Components/Parent/ApplicationFactory.cc b/src/CCA/Components/Parent/ApplicationFactory.cc
index 9bb50953..f7958fa3 100644
--- a/src/CCA/Components/Parent/ApplicationFactory.cc
+++ b/src/CCA/Components/Parent/ApplicationFactory.cc
@@ -106,8 +106,7 @@
 #endif
 
 #ifndef NO_PHASEFIELD
-#  include <CCA/Components/PhaseField/PhaseField.h>
-#  include <CCA/Components/PhaseField/AMRPhaseField.h>
+#  include <CCA/Components/PhaseField/Applications/ApplicationFactory.h>
 #endif 
 
 #ifndef NO_WASATCH
@@ -346,52 +345,8 @@ ApplicationFactory::create( ProblemSpecP& prob_spec,
   //----------------------------
 
 #ifndef NO_PHASEFIELD
-  if ( sim_comp == "phasefield" || sim_comp == "PHASEFIELD" ) {
-    bool doNC, doTest;
-    int verbosity;
-    int dimension;
-    prob_spec->findBlock ( "PhaseField" )->getWithDefault ( "node_centered", doNC, false );
-    prob_spec->findBlock ( "PhaseField" )->getWithDefault ( "ws_test", doTest, false );
-    prob_spec->findBlock ( "PhaseField" )->getWithDefault ( "verbosity", verbosity, 0 );
-    prob_spec->findBlock ( "PhaseField" )->getWithDefault ( "dimension", dimension, 2 );
-    if ( doAMR ) {
-      if ( doTest ) {
-        if ( doNC ) {
-          if ( dimension > 2 ) {
-            return scinew AMRNCPhaseField3DTest ( myworld, materialManager, verbosity );
-          } else {
-            return scinew AMRNCPhaseField2DTest ( myworld, materialManager, verbosity );
-        } } else { // CC
-          if ( dimension > 2 ) {
-            return scinew AMRCCPhaseField3DTest ( myworld, materialManager, verbosity );
-          } else {
-            return scinew AMRCCPhaseField2DTest ( myworld, materialManager, verbosity );
-      } } } else { // noTest
-        if ( doNC ) {
-          if ( dimension > 2 ) {
-            return scinew AMRNCPhaseField3D ( myworld, materialManager, verbosity );
-          } else {
-            return scinew AMRNCPhaseField2D ( myworld, materialManager, verbosity );
-        } } else { // CC
-          if ( dimension > 2 ) {
-            return scinew AMRCCPhaseField3D ( myworld, materialManager, verbosity );
-          } else {
-            return scinew AMRCCPhaseField2D ( myworld, materialManager, verbosity );
-    } } } } else { // noAMR
-      if ( doNC ) {
-        if ( dimension > 2 ) {
-          return scinew NCPhaseField3D ( myworld, materialManager, verbosity );
-       }  else {
-          return scinew NCPhaseField2D ( myworld, materialManager, verbosity );
-      } } else { // CC
-        if ( dimension > 2 ) {
-          return scinew CCPhaseField3D ( myworld, materialManager, verbosity );
-        } else {
-          return scinew CCPhaseField2D ( myworld, materialManager, verbosity );
-  } } } }
-  else
-    turned_on_options += "phasefield ";
-
+  if ( sim_comp == "phasefield" || sim_comp == "PHASEFIELD" )
+    return PhaseField::ApplicationFactory::create ( myworld, materialManager, prob_spec->findBlock ( "PhaseField" ), doAMR );
 #endif
 
   //----------------------------
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDView-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDView-bld.sh
new file mode 100755
index 00000000..edddd908
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDView-bld.sh
@@ -0,0 +1,424 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+VARs=(CC NC)
+STNs=(P5 P7)
+DIMs=(2 3)
+PPPs=(
+  "PureMetalProblem"
+  "PureMetalProblem"
+)
+NFFs=(
+  "4"
+  "4"
+)
+DIRs=(x y z)
+SIGNs=(minus plus)
+BCs=(Dirichlet Neumann)
+C2Fs=(FC0 FC1 FCSimple FCLinear FCBilinear)
+
+SS=""
+VV=""
+CC=""
+PP=""
+
+POSITIONAL=()
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    -v|--var)
+    VARs=("$2")
+    VV="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -s|--stn)
+    SS="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -p|--pb)
+    PP="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -c|--c2f)
+    C2Fs=("$2")
+    CC="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -B|--no-bc)
+    BCs=()
+    shift # past argument
+    ;;
+    *)    # unknown option
+    POSITIONAL+=("$1") # save it in an array for later
+    shift # past argument
+    ;;
+esac
+done
+set -- "${POSITIONAL[@]}" # restore positional parameters
+
+if [ -n "${SS}" ]; then
+  FOUND=0
+  for ((s=0; s<${#STNs[@]}; s++)); do
+    if [ "${SS}" == "${STNs[s]}" ]; then
+      STNs=("${STNs[s]}");
+      DIMs=("${DIMs[s]}");
+      PPPs=("${PPPs[s]}");
+      NFFs=("${NFFs[s]}");
+      FOUND=1
+    fi
+  done
+  if [[ $FOUND -eq 0 ]]; then
+    >&2 echo "cannot find the stencil"
+    exit
+  fi
+fi
+
+if [ -n "${PP}" ]; then
+  for ((pp=0; pp<${#PPPs[@]}; pp++)); do
+    FOUND=0
+    IFS=';' read -r -a PPs <<< "${PPPs[pp]}"
+    IFS=';' read -r -a NFs <<< "${NFFs[pp]}"
+    for ((p=0; p<${#PPs[@]}; p++)); do
+      if [ "${PP}" == "${PPs[p]}" ]; then
+        PPPs[pp]="${PPs[p]}";
+        NFFs[pp]="${NFs[p]}";
+        FOUND=1
+      fi
+    done
+    if [[ $FOUND -eq 0 ]]; then
+      PPPs[pp]="";
+      NFFs[pp]="";
+    fi
+  done
+fi
+
+PBS=()
+for ((pp=0; pp<${#PPPs[@]}; pp++)); do
+  IFS=';' read -r -a PPs <<< "${PPPs[pp]}"
+  for ((p=0; p<${#PPs[@]}; p++)); do
+    FOUND=0
+    for ((q=0; q<${#PBS[@]}; q++)); do
+      if [ "${PPs[p]}" == "${PBS[q]}" ]; then
+        FOUND=1
+      fi
+    done
+    if [[ $FOUND -eq 0 ]]; then
+      PBS+=("${PPs[p]}")
+    fi
+  done
+done
+
+SRC=${0%-bld.sh}${PP}${VV}${SS}${CC}-bld.cc
+
+echo "generating $SRC"
+
+echo '/*' > $SRC
+echo ' * The MIT License' >> $SRC
+echo ' *' >> $SRC
+echo ' * Copyright (c) 1997-2018 The University of Utah' >> $SRC
+echo ' *' >> $SRC
+echo ' * Permission is hereby granted, free of charge, to any person obtaining a copy' >> $SRC
+echo ' * of this software and associated documentation files (the "Software"), to' >> $SRC
+echo ' * deal in the Software without restriction, including without limitation the' >> $SRC
+echo ' * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or' >> $SRC
+echo ' * sell copies of the Software, and to permit persons to whom the Software is' >> $SRC
+echo ' * furnished to do so, subject to the following conditions:' >> $SRC
+echo ' *' >> $SRC
+echo ' * The above copyright notice and this permission notice shall be included in' >> $SRC
+echo ' * all copies or substantial portions of the Software.' >> $SRC
+echo ' *' >> $SRC
+echo ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' >> $SRC
+echo ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' >> $SRC
+echo ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' >> $SRC
+echo ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' >> $SRC
+echo ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING' >> $SRC
+echo ' * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS' >> $SRC
+echo ' * IN THE SOFTWARE.' >> $SRC
+echo ' */' >> $SRC
+echo '' >> $SRC
+for PB in ${PBS[@]}; do
+  echo '#include <CCA/Components/PhaseField/DataTypes/'$PB'.h>' >> $SRC
+done
+echo '#include <CCA/Components/PhaseField/BoundaryConditions/BCFDView.h>' >> $SRC
+echo '' >> $SRC
+echo 'namespace Uintah {' >> $SRC
+echo 'namespace PhaseField {' >> $SRC
+echo '' >> $SRC
+
+for VAR in ${VARs[@]}; do
+  for ((s=0; s<${#STNs[@]}; s++)); do
+    STN="${STNs[s]}"
+    DIM="${DIMs[s]}"
+    IFS=';' read -r -a PPs <<< "${PPPs[s]}"
+    IFS=';' read -r -a NFs <<< "${NFFs[s]}"
+    for ((n=0; n<${#PPs[@]}; n++)); do
+      PP="${PPs[n]}"
+      NF="${NFs[n]}"
+      PB="$PP<$VAR, $STN>"
+      for ((f=0; f<$NF; f++)); do
+        I=$f
+
+        for ((d0=0; d0<$DIM; d0++)); do
+          DIR0="${DIRs[d0]}"
+          for SIGN0 in "${SIGNs[@]}"; do
+            F0=$DIR0$SIGN0
+            for C2F in "${C2Fs[@]}"; do
+              P0="Patch::$F0 | BC::FineCoarseInterface | FC::$C2F"
+              echo "template<> const std::string BCFDView < $PB, $I, $P0 >::Name = \"$PP|$I|$VAR|$F0|$C2F|\";" >> $SRC
+
+              for ((d1=d0+1; d1<$DIM; d1++)); do
+                DIR1="${DIRs[d1]}"
+                for SIGN1 in "${SIGNs[@]}"; do
+                  F1=$DIR1$SIGN1
+                  P1="Patch::$F1 | BC::FineCoarseInterface | FC::$C2F"
+                  echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1 >::Name = \"$PP|$I|$VAR|$F0|$C2F|$F1|$C2F|\";" >> $SRC
+
+                  for ((d2=d1+1; d2<$DIM; d2++)); do
+                    DIR2="${DIRs[d2]}"
+                    for SIGN2 in "${SIGNs[@]}"; do
+                      F2=$DIR2$SIGN2
+                      P2="Patch::$F2 | BC::FineCoarseInterface | FC::$C2F"
+                      echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1, $P2 >::Name = \"$PP|$I|$VAR|$F0|$C2F|$F1|$C2F|$F2|$C2F|\";" >> $SRC
+
+                      for BC2 in "${BCs[@]}"; do
+                        P2="Patch::$F2 | BC::$BC2"
+                        echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1, $P2 >::Name = \"$PP|$I|$VAR|$F0|$C2F|$F1|$C2F|$F2|$BC2|\";" >> $SRC
+
+                      done
+                    done
+                  done
+
+                  for BC1 in "${BCs[@]}"; do
+                    P1="Patch::$F1 | BC::$BC1"
+                    echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1 >::Name = \"$PP|$I|$VAR|$F0|$C2F|$F1|$BC1|\";" >> $SRC
+
+                    for ((d2=d1+1; d2<$DIM; d2++)); do
+                      DIR2="${DIRs[d2]}"
+                      for SIGN2 in "${SIGNs[@]}"; do
+                        F2=$DIR2$SIGN2
+                        P2="Patch::$F2 | BC::FineCoarseInterface | FC::$C2F"
+                        echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1, $P2 >::Name = \"$PP|$I|$VAR|$F0|$C2F|$F1|$BC1|$F2|$C2F|\";" >> $SRC
+
+                        for BC2 in "${BCs[@]}"; do
+                          P2="Patch::$F2 | BC::$BC2"
+                          echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1, $P2 >::Name = \"$PP|$I|$VAR|$F0|$C2F|$F1|$BC1|$F2|$BC2|\";" >> $SRC
+
+                        done
+                      done
+                    done
+
+                  done
+                done
+              done
+
+            done
+            for BC0 in "${BCs[@]}"; do
+              P0="Patch::$F0 | BC::$BC0"
+
+              for ((d1=d0+1; d1<$DIM; d1++)); do
+                DIR1="${DIRs[d1]}"
+                for SIGN1 in "${SIGNs[@]}"; do
+                  F1=$DIR1$SIGN1
+                  for C2F in "${C2Fs[@]}"; do
+                    P1="Patch::$F1 | BC::FineCoarseInterface | FC::$C2F"
+                    echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1 >::Name = \"$PP|$I|$VAR|$F0|$BC0|$F1|$C2F|\";" >> $SRC
+
+                    for ((d2=d1+1; d2<$DIM; d2++)); do
+                      DIR2="${DIRs[d2]}"
+                      for SIGN2 in "${SIGNs[@]}"; do
+                        F2=$DIR2$SIGN2
+                        P2="Patch::$F2 | BC::FineCoarseInterface | FC::$C2F"
+                        echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1, $P2 >::Name = \"$PP|$I|$VAR|$F0|$BC0|$F1|$C2F|$F2|$C2F|\";" >> $SRC
+
+                        for BC2 in "${BCs[@]}"; do
+                          P2="Patch::$F2 | BC::$BC2"
+                          echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1, $P2 >::Name = \"$PP|$I|$VAR|$F0|$BC0|$F1|$C2F|$F2|$BC2|\";" >> $SRC
+
+                        done
+                      done
+                    done
+
+                  done
+                  for BC1 in "${BCs[@]}"; do
+                    P1="Patch::$F1 | BC::$BC1"
+
+                    for ((d2=d1+1; d2<$DIM; d2++)); do
+                      DIR2="${DIRs[d2]}"
+                      for SIGN2 in "${SIGNs[@]}"; do
+                        F2=$DIR2$SIGN2
+                        for C2F in "${C2Fs[@]}"; do
+                          P2="Patch::$F2 | BC::FineCoarseInterface | FC::$C2F"
+                          echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1, $P2 >::Name = \"$PP|$I|$VAR|$F0|$BC0|$F1|$BC1|$F2|$C2F|\";" >> $SRC
+
+                        done
+                      done
+                    done
+
+                  done
+                done
+              done
+
+            done
+          done
+        done
+
+      done
+    done
+  done
+done
+
+echo "" >> $SRC
+
+for VAR in ${VARs[@]}; do
+  for ((s=0; s<${#STNs[@]}; s++)); do
+    STN="${STNs[s]}"
+    DIM="${DIMs[s]}"
+    IFS=';' read -r -a PPs <<< "${PPPs[s]}"
+    IFS=';' read -r -a NFs <<< "${NFFs[s]}"
+    for ((n=0; n<${#PPs[@]}; n++)); do
+      PB="${PPs[n]}<$VAR, $STN>"
+      NF="${NFs[n]}"
+      for ((f=0; f<$NF; f++)); do
+        I=$f
+
+        for ((d0=0; d0<$DIM; d0++)); do
+          DIR0="${DIRs[d0]}"
+          for SIGN0 in "${SIGNs[@]}"; do
+            F0=$DIR0$SIGN0
+            for C2F in "${C2Fs[@]}"; do
+              P0="Patch::$F0 | BC::FineCoarseInterface | FC::$C2F"
+              echo "template class BCFDView < $PB, $I, $P0 >;" >> $SRC
+
+              for ((d1=d0+1; d1<$DIM; d1++)); do
+                DIR1="${DIRs[d1]}"
+                for SIGN1 in "${SIGNs[@]}"; do
+                  F1=$DIR1$SIGN1
+                  P1="Patch::$F1 | BC::FineCoarseInterface | FC::$C2F"
+                  echo "template class BCFDView < $PB, $I, $P0, $P1 >;" >> $SRC
+
+                  for ((d2=d1+1; d2<$DIM; d2++)); do
+                    DIR2="${DIRs[d2]}"
+                    for SIGN2 in "${SIGNs[@]}"; do
+                      F2=$DIR2$SIGN2
+                      P2="Patch::$F2 | BC::FineCoarseInterface | FC::$C2F"
+                      echo "template class BCFDView < $PB, $I, $P0, $P1, $P2 >;" >> $SRC
+
+                      for BC2 in "${BCs[@]}"; do
+                        P2="Patch::$F2 | BC::$BC2"
+                        echo "template class BCFDView < $PB, $I, $P0, $P1, $P2 >;" >> $SRC
+
+                      done
+                    done
+                  done
+
+                  for BC1 in "${BCs[@]}"; do
+                    P1="Patch::$F1 | BC::$BC1"
+                    echo "template class BCFDView < $PB, $I, $P0, $P1 >;" >> $SRC
+
+                    for ((d2=d1+1; d2<$DIM; d2++)); do
+                      DIR2="${DIRs[d2]}"
+                      for SIGN2 in "${SIGNs[@]}"; do
+                        F2=$DIR2$SIGN2
+                        P2="Patch::$F2 | BC::FineCoarseInterface | FC::$C2F"
+                        echo "template class BCFDView < $PB, $I, $P0, $P1, $P2 >;" >> $SRC
+
+                        for BC2 in "${BCs[@]}"; do
+                          P2="Patch::$F2 | BC::$BC2"
+                          echo "template class BCFDView < $PB, $I, $P0, $P1, $P2 >;" >> $SRC
+
+                        done
+                      done
+                    done
+
+                  done
+                done
+              done
+
+            done
+            for BC0 in "${BCs[@]}"; do
+              P0="Patch::$F0 | BC::$BC0"
+
+              for ((d1=d0+1; d1<$DIM; d1++)); do
+                DIR1="${DIRs[d1]}"
+                for SIGN1 in "${SIGNs[@]}"; do
+                  F1=$DIR1$SIGN1
+                  for C2F in "${C2Fs[@]}"; do
+                    P1="Patch::$F1 | BC::FineCoarseInterface | FC::$C2F"
+                    echo "template class BCFDView < $PB, $I, $P0, $P1 >;" >> $SRC
+
+                    for ((d2=d1+1; d2<$DIM; d2++)); do
+                      DIR2="${DIRs[d2]}"
+                      for SIGN2 in "${SIGNs[@]}"; do
+                        F2=$DIR2$SIGN2
+                        P2="Patch::$F2 | BC::FineCoarseInterface | FC::$C2F"
+                        echo "template class BCFDView < $PB, $I, $P0, $P1, $P2 >;" >> $SRC
+
+                        for BC2 in "${BCs[@]}"; do
+                          P2="Patch::$F2 | BC::$BC2"
+                          echo "template class BCFDView < $PB, $I, $P0, $P1, $P2 >;" >> $SRC
+
+                        done
+                      done
+                    done
+
+                  done
+                  for BC1 in "${BCs[@]}"; do
+                    P1="Patch::$F1 | BC::$BC1"
+
+                    for ((d2=d1+1; d2<$DIM; d2++)); do
+                      DIR2="${DIRs[d2]}"
+                      for SIGN2 in "${SIGNs[@]}"; do
+                        F2=$DIR2$SIGN2
+                        for C2F in "${C2Fs[@]}"; do
+                          P2="Patch::$F2 | BC::FineCoarseInterface | FC::$C2F"
+                          echo "template class BCFDView < $PB, $I, $P0, $P1, $P2 >;" >> $SRC
+
+                        done
+                      done
+                    done
+
+                  done
+                done
+              done
+
+            done
+          done
+        done
+
+      done
+    done
+  done
+done
+
+echo "" >> $SRC
+
+echo '} // namespace Uintah' >> $SRC
+echo '} // namespace PhaseField' >> $SRC
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC0-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC0-bld.sh
new file mode 100755
index 00000000..1db62fbe
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC0-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P5 -c FC0 -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC0New-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC0New-bld.sh
new file mode 100755
index 00000000..237c1b0b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC0New-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P5 -c FC0New -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC1-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC1-bld.sh
new file mode 100755
index 00000000..9a15a623
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC1-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P5 -c FC1 -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC1New-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC1New-bld.sh
new file mode 100755
index 00000000..c7bf58ce
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FC1New-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P5 -c FC1New -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCBilinear-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCBilinear-bld.sh
new file mode 100755
index 00000000..f92d4522
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCBilinear-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P5 -c FCBilinear -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCLinear-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCLinear-bld.sh
new file mode 100755
index 00000000..c552278a
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCLinear-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P5 -c FCLinear -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCSimple-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCSimple-bld.sh
new file mode 100755
index 00000000..498e315e
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP5FCSimple-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P5 -c FCSimple -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC0-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC0-bld.sh
new file mode 100755
index 00000000..2ad8ee4f
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC0-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P7 -c FC0 -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC0New-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC0New-bld.sh
new file mode 100755
index 00000000..599a2b27
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC0New-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P7 -c FC0New -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC1-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC1-bld.sh
new file mode 100755
index 00000000..7df21c9e
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC1-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P7 -c FC1 -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC1New-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC1New-bld.sh
new file mode 100755
index 00000000..6c9c819b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemCCP7FC1New-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v CC -s P7 -c FC1New -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FC0-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FC0-bld.sh
new file mode 100755
index 00000000..71cc460a
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FC0-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v NC -s P5 -c FC0 -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FC1-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FC1-bld.sh
new file mode 100755
index 00000000..6d8dad36
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FC1-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v NC -s P5 -c FC1 -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCBilinear-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCBilinear-bld.sh
new file mode 100755
index 00000000..c583a452
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCBilinear-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v NC -s P5 -c FCBilinear -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCLinear-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCLinear-bld.sh
new file mode 100755
index 00000000..a0d8f6fe
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCLinear-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v NC -s P5 -c FCLinear -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCSimple-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCSimple-bld.sh
new file mode 100755
index 00000000..4b3a2065
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP5FCSimple-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v NC -s P5 -c FCSimple -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP7FC0-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP7FC0-bld.sh
new file mode 100755
index 00000000..85c4297d
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP7FC0-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v NC -s P7 -c FC0 -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP7FC1-bld.sh b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP7FC1-bld.sh
new file mode 100755
index 00000000..23cfe2b8
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRFDViewPureMetalProblemNCP7FC1-bld.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SCRIPT="`dirname \"$0\"`"/AMRFDView-bld.sh
+${SCRIPT} -p PureMetalProblem -v NC -s P7 -c FC1 -B
diff --git a/src/CCA/Components/PhaseField/AMR/AMRInterface.h b/src/CCA/Components/PhaseField/AMR/AMRInterface.h
new file mode 100644
index 00000000..846e5791
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRInterface.h
@@ -0,0 +1,70 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/AMRInterface.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_AMRInterface_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_AMRInterface_h
+
+#include <CCA/Components/PhaseField/AMR/detail/amr_interface0.h>
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Interface for AMR
+ *
+ * groups together various methods to get info about amr patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ */
+template <VarType VAR, DimType DIM>
+struct AMRInterface
+{
+    template <VarType V = VAR> static inline IntVector get_coarser ( const Level * l, const IntVector & i )
+    {
+        return detail::amr_interface0<V>::get_coarser ( l, i );
+    }
+
+    template <VarType V = VAR> static inline IntVector get_finer ( const Level * l, const IntVector & i )
+    {
+        return detail::amr_interface0<V>::get_finer ( l, i );
+    }
+
+}; // struct AMRInterface
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_AMRInterface_h
diff --git a/src/CCA/Components/PhaseField/AMR/AMRInterpolator.h b/src/CCA/Components/PhaseField/AMR/AMRInterpolator.h
new file mode 100644
index 00000000..27363c37
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRInterpolator.h
@@ -0,0 +1,56 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/AMRInterpolator.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_AMRInterpolator_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_AMRInterpolator_h
+
+#include <CCA/Components/PhaseField/AMR/detail/amr_interpolator.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Wrapper of grid variables for interpolation from coarser to
+ *        finer levels.
+ *
+ * Adds to view the possibility to compute multi-grid interpolation
+ *
+ * @tparam Problem type of PhaseField problem
+ * @tparam I index of the variable within the Problem
+ * @tparam FCI problem dimension
+ */
+template<typename Problem, size_t I, FCIType FCI> using AMRInterpolator = detail::amr_interpolator < typename Problem::template get_field<I>::type, Problem, index_sequence<I>, FCI, Problem::Dim >;
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_AMRInterpolator_h
diff --git a/src/CCA/Components/PhaseField/AMR/AMRRestrictor.h b/src/CCA/Components/PhaseField/AMR/AMRRestrictor.h
new file mode 100644
index 00000000..7071b6d7
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/AMRRestrictor.h
@@ -0,0 +1,56 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/AMRRestrictor.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_AMRRestrictor_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_AMRRestrictor_h
+
+#include <CCA/Components/PhaseField/AMR/detail/amr_restrictor.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Wrapper of grid variables for interpolation from finer to
+ *        coarser levels.
+ *
+ * Adds to view the possibility to compute multi-grid interpolation
+ *
+ * @tparam Problem type of PhaseField problem
+ * @tparam I index of the variable within the Problem
+ * @tparam FCI problem dimension
+ */
+template<typename Problem, size_t I, FCIType FCI> using AMRRestrictor = detail::amr_restrictor < typename Problem::template get_field<I>::type, Problem, index_sequence<I>, FCI, Problem::Var >;
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_AMRRestrictor_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_coarser_view.h b/src/CCA/Components/PhaseField/AMR/detail/amr_coarser_view.h
new file mode 100644
index 00000000..6bdd975a
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_coarser_view.h
@@ -0,0 +1,378 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_coarser_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_coarser_view_h
+
+#include <CCA/Components/PhaseField/Views/detail/piecewise_view.h>
+#include <CCA/Components/PhaseField/DataTypes/SubProblems.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Composite view for accessing coarser grid variables
+ *
+ * @tparam Field type of Field (should be only ScalarField)
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ */
+template<typename Field, typename Problem, typename Index> class amr_coarser_view;
+
+/**
+ * @brief Composite view for accessing coarser grid variables
+ * (ScalarField implementation)
+ *
+ * @remark deletion of views instantiated in piecewise_view are performed here
+ *
+ * @tparam T type of the field value at each point
+ * @tparam Problem type of PhaseField problem
+ * @tparam I list of indices of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ */
+template<typename T, typename Problem, size_t... I>
+class amr_coarser_view < ScalarField<T>, Problem, index_sequence<I...> >
+    : virtual public view < ScalarField<T> >
+    , public piecewise_view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// Problem variable representation
+    static constexpr VarType VAR = Problem::Var;
+
+    /// Problem dimension
+    static constexpr DimType DIM = Problem::Dim;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+private: // STATIC ASSERTS
+
+    static_assert ( std::is_same< typename Problem::template get_field<I...>::type, ScalarField<T> >::value, "non consistent field types" );
+    static_assert ( std::is_const<T>::value, "amr_coarser_view with non const base" );
+
+private: // MEMBERS
+
+    /// Label of variable in the DataWarehouse
+    const VarLabel * m_label;
+
+    /// Label for subprombelms in the DataWarehouse
+    const VarLabel * m_subproblems_label;
+
+    /// Material index in the DataWarehouse
+    const int m_material;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Create subviews
+     *
+     * Instantiate subviews in piecewise_view base and retrieve corser grid
+     * data from dw under given fine region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level_fine grid level of the fine region above the level from which retrieve data
+     * @param low_fine lower bound of the region to retrieve
+     * @param high_fine higher bound of the region to retrieve
+     */
+    void
+    create_views (
+        DataWarehouse * dw,
+        const Level * level_fine,
+        const IntVector & low_fine,
+        const IntVector & high_fine
+    )
+    {
+        // Get coarser region under given fine region
+        const Level * level_coarse = level_fine->getCoarserLevel().get_rep();
+        IntVector l_coarse = AMRInterface<VAR, DIM>::get_coarser ( level_fine, low_fine );
+        IntVector h_coarse = AMRInterface<VAR, DIM>::get_coarser ( level_fine, high_fine - IntVector {1, 1, 1} ) + IntVector {1, 1, 1};
+
+        // we need to include lower patches if l_coarse lies on a minus face
+        if ( VAR == NC )
+            l_coarse -= 1;
+
+        // get list of coarse patches in region
+        std::vector<const Patch *> patches_coarse;
+        level_coarse->selectPatches ( l_coarse, h_coarse, patches_coarse );
+
+        for ( const auto & patch_coarse : patches_coarse )
+        {
+            // virtual coarse patches
+            IntVector offset ( 0, 0, 0 );
+            if ( patch_coarse->isVirtual() )
+                offset = patch_coarse->getVirtualOffset();
+
+            // need to check which BC applies on coarse level
+            Variable < PP, SubProblems<Problem> > subproblems_coarse;
+
+            // get coarse subproblems (all logic for handling correctly all possible coarse geometries is already there)
+            dw->getOtherDataWarehouse ( Task::NewDW )->get ( subproblems_coarse, m_subproblems_label, m_material, patch_coarse );
+            auto problems_coarse = subproblems_coarse.get().get_rep();
+
+            for ( const auto & p : *problems_coarse )
+            {
+                // check that the coarse problem is under fine region
+                IntVector low_coarse { Max ( p.get_low() + offset, l_coarse ) };
+                IntVector high_coarse { Min ( p.get_high() + offset, h_coarse ) };
+                if (
+                    low_coarse[X] < high_coarse[X] &&
+                    low_coarse[Y] < high_coarse[Y] &&
+                    low_coarse[Z] < high_coarse[Z]
+                )
+                {
+                    // get problem (virtual) view
+                    if ( patch_coarse->isVirtual() )
+                        this->m_views.push_back ( p.template get_view<I...> ().clone ( false, offset ) );
+                    else
+                        this->m_views.push_back ( p.template get_view<I...> ().clone ( false ) );
+
+                    // retrieve coarse data
+                    this->m_views.back()->set ( dw, level_coarse, low_coarse, high_coarse );
+
+                    // add problem view support to view support
+                    m_support.splice ( m_support.end(), this->m_views.back()->get_support() );
+                }
+            }
+        }
+
+        // after all subviews are fetched simplify view support
+        m_support.simplify();
+    };
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    amr_coarser_view (
+        const amr_coarser_view * copy,
+        bool deep
+    ) : piecewise_view<Field> ( copy, deep ),
+        m_label ( copy->m_label ),
+        m_subproblems_label ( copy->m_subproblems_label ),
+        m_material ( copy->m_material ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * construct coarser view without retrieving inner variable data from
+     * the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     */
+    amr_coarser_view (
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material
+    ) : piecewise_view<Field> (),
+        m_label ( label ),
+        m_subproblems_label ( subproblems_label ),
+        m_material ( material )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * construct coarser view and retrieve inner variable data from the
+     * DataWarehouse for the region lying under a given fine patch.
+     *
+     * @remark the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts must be false
+     */
+    amr_coarser_view (
+        DataWarehouse * dw,
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : piecewise_view<Field> (),
+        m_label ( label ),
+        m_subproblems_label ( subproblems_label ),
+        m_material ( material )
+
+    {
+        ASSERTMSG ( !use_ghosts, "amr_coarser_view doesn't support ghosts" );
+        create_views ( dw, patch->getLevel(), DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ) );
+    }
+
+    /// Destructor
+    virtual ~amr_coarser_view ()
+    {
+        for ( view<Field> * view : this->m_views ) delete view;
+    };
+
+    /// Prevent copy (and move) constructor
+    amr_coarser_view ( const amr_coarser_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_coarser_view & operator= ( const amr_coarser_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for accessing the coarser
+     * region below a given fine patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch fine grid patch to retrieve data for
+     * @param use_ghosts must be false
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_coarser_view doesn't support ghosts" );
+        m_support.clear();
+
+        // we need to recreate all subviews since we don't know if coarser level
+        // geometry is changed
+        for ( view<Field> * view : this->m_views ) delete view;
+        this->m_views.clear();
+        create_views ( dw, patch->getLevel(), DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ) );
+    }
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for accessing the coarser
+     * region below a given fine region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level fine grid level from which retrieve data
+     * @param low lower bound of the fine region to retrieve
+     * @param high higher bound of the fine region to retrieve
+     * @param use_ghosts must be false
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_coarser_view doesn't support ghosts" );
+        m_support.clear();
+
+        // we need to recreate all subviews since we don't know if coarser level
+        // geometry is changed
+        for ( view<Field> * view : this->m_views ) delete view;
+        this->m_views.clear();
+        create_views ( dw, level, low, high );
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    ) const override
+    {
+        return scinew amr_coarser_view ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<amr_coarser_view, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief Get the fine region corresponding to the coarser one for which
+     * the view has access to the DataWarehouse
+     *
+     * @return support of the view
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+}; // class amr_coarser_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_coarser_view_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_finer_view.h b/src/CCA/Components/PhaseField/AMR/detail/amr_finer_view.h
new file mode 100644
index 00000000..b1396baf
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_finer_view.h
@@ -0,0 +1,367 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_finer_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_finer_view_h
+//
+#include <CCA/Components/PhaseField/Views/detail/piecewise_view.h>
+#include <CCA/Components/PhaseField/DataTypes/SubProblems.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Composite view for accessing coarser grid variables
+ *
+ * @tparam Field type of Field (should be only ScalarField)
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ */
+template<typename Field, typename Problem, typename Index> class amr_finer_view;
+
+/**
+ * @brief Composite view for accessing finer grid variables
+ * (ScalarField implementation)
+ *
+ * @remark deletion of views instantiated in piecewise_view are performed here
+ *
+ * @tparam T type of the field value at each point
+ * @tparam Problem type of PhaseField problem
+ * @tparam I list of indices of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ */
+template<typename T, typename Problem, size_t... I>
+class amr_finer_view < ScalarField<T>, Problem, index_sequence<I...> >
+    : virtual public view < ScalarField<T> >
+    , public piecewise_view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// Problem variable representation
+    static constexpr VarType VAR = Problem::Var;
+
+    /// Problem dimension
+    static constexpr DimType DIM = Problem::Dim;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+private: // STATIC ASSERTS
+
+    static_assert ( std::is_same< typename Problem::template get_field<I...>::type, ScalarField<T> >::value, "non consistent field types" );
+    static_assert ( std::is_const<T>::value, "amr_finer_view with non const base" );
+
+private: // MEMBERS
+
+    /// Label of variable in the DataWarehouse
+    const VarLabel * m_label;
+
+    /// Label for subprombelms in the DataWarehouse
+    const VarLabel * m_subproblems_label;
+
+    /// Material index in the DataWarehouse
+    const int m_material;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Create subviews
+     *
+     * Instantiate subviews in piecewise_view base and retrieve finer grid
+     * data from dw over a given coarse region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level_coarse grid level of the coarse region below the level from which retrieve data
+     * @param low_coarse lower bound of the region to retrieve
+     * @param high_coarse higher bound of the region to retrieve
+     */
+    void
+    create_views (
+        DataWarehouse * dw,
+        const Level * level_coarse,
+        const IntVector & low_coarse,
+        const IntVector & high_coarse
+    )
+    {
+        // Get finer region aboce given coarse region
+        const Level * level_fine = level_coarse->getFinerLevel().get_rep();
+        IntVector l_fine = AMRInterface<VAR, DIM>::get_finer ( level_coarse, low_coarse );
+        IntVector h_fine = AMRInterface<VAR, DIM>::get_finer ( level_coarse, high_coarse -  IntVector {1, 1, 1} ) + level_fine->getRefinementRatio();
+
+        // get list of fine patches in region
+        std::vector<const Patch *> patches_fine;
+        level_fine->selectPatches ( l_fine, h_fine, patches_fine );
+
+        for ( const auto & patch_fine : patches_fine )
+        {
+            // virtual fine patches
+            IntVector offset ( 0, 0, 0 );
+            if ( patch_fine->isVirtual() )
+                offset = patch_fine->getVirtualOffset();
+
+            // need to check which BC applies on finer level
+            Variable < PP, SubProblems<Problem> > subproblems_fine;
+
+            // get fine subproblems (all logic for handling correctly all possible fine geometries is already there)
+            dw->getOtherDataWarehouse ( Task::NewDW )->get ( subproblems_fine, m_subproblems_label, m_material, patch_fine );
+            auto problems_fine = subproblems_fine.get().get_rep();
+
+            for ( const auto & p : *problems_fine )
+            {
+                // check that the fine problem is above coarse region
+                IntVector low_fine { Max ( p.get_low() + offset, l_fine ) };
+                IntVector high_fine { Min ( p.get_high() + offset, h_fine ) };
+                if (
+                    low_fine[X] < high_fine[X] &&
+                    low_fine[Y] < high_fine[Y] &&
+                    low_fine[Z] < high_fine[Z]
+                )
+                {
+                    // get problem (virtual) view
+                    if ( patch_fine->isVirtual() )
+                        this->m_views.push_back ( p.template get_view<I...> ().clone ( false, offset ) );
+                    else
+                        this->m_views.push_back ( p.template get_view<I...> ().clone ( false ) );
+
+                    // retrieve fine data
+                    this->m_views.back()->set ( dw, level_fine, low_fine, high_fine );
+
+                    // add problem view support to view support
+                    m_support.emplace_back ( low_fine, high_fine );
+                }
+            }
+        }
+
+        // after all subviews are fetched simplify view support
+        m_support.simplify();
+    };
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    amr_finer_view (
+        const amr_finer_view * copy,
+        bool deep
+    ) : piecewise_view<Field> ( copy, deep ),
+        m_label ( copy->m_label ),
+        m_subproblems_label ( copy->m_subproblems_label ),
+        m_material ( copy->m_material ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * construct finer view without retrieving inner variable data from
+     * the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     */
+    amr_finer_view (
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material
+    ) : piecewise_view<Field> (),
+        m_label ( label ),
+        m_subproblems_label ( subproblems_label ),
+        m_material ( material )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * construct finer view and retrieve inner variable data from the
+     * DataWarehouse for the region lying under a given fine patch.
+     *
+     * @remark the number of ghost cells/nodes and the corresponding region on the
+     * finer level is automatically computed to match the restriction type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts must be false
+     */
+    amr_finer_view (
+        DataWarehouse * dw,
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : piecewise_view<Field> (),
+        m_label ( label ),
+        m_subproblems_label ( subproblems_label ),
+        m_material ( material )
+    {
+        ASSERTMSG ( !use_ghosts, "amr_finer_view doesn't support ghosts" );
+        create_views ( dw, patch->getLevel(), DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ) );
+    }
+
+    /// Destructor
+    virtual ~amr_finer_view()
+    {
+        for ( view<Field> * view : this->m_views ) delete view;
+    }
+
+    /// Prevent copy (and move) constructor
+    amr_finer_view ( const amr_finer_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_finer_view & operator= ( const amr_finer_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for accessing the finer
+     * region over a given coarse patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch coarse grid patch to retrieve data for
+     * @param use_ghosts must be false
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_finer_view doesn't support ghosts" );
+        m_support.clear();
+        for ( view<Field> * view : this->m_views ) delete view;
+        this->m_views.clear();
+        create_views ( dw, patch->getLevel(), DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ) );
+    }
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for accessing the finer
+     * region over a given coarse region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level coarse grid level from which retrieve data
+     * @param low lower bound of the coarse region to retrieve
+     * @param high higher bound of the coarse region to retrieve
+     * @param use_ghosts must be false
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_finer_view doesn't support ghosts" );
+        m_support.clear();
+        for ( view<Field> * view : this->m_views ) delete view;
+        this->m_views.clear();
+        create_views ( dw, level, low, high );
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    ) const override
+    {
+        return scinew amr_finer_view ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<amr_finer_view, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief Get the coarse region corresponding to the finer one for which
+     * the view has access to the DataWarehouse
+     *
+     * @return support of the view
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+}; // class amr_finer_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_finer_view_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_interface0.h b/src/CCA/Components/PhaseField/AMR/detail/amr_interface0.h
new file mode 100644
index 00000000..25a3965c
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_interface0.h
@@ -0,0 +1,61 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_interface0.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for amr
+ *
+ * groups together various methods to get info about amr patches and levels which
+ * depend on the different types of variable representation allowing to choose
+ * the relevant implementation at compile time
+ *
+ * @tparam VAR type of variable representation
+ */
+template < VarType VAR > class amr_interface0;
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#include <CCA/Components/PhaseField/AMR/detail/amr_interface0_CC.h>
+#include <CCA/Components/PhaseField/AMR/detail/amr_interface0_NC.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_interface0_CC.h b/src/CCA/Components/PhaseField/AMR/detail/amr_interface0_CC.h
new file mode 100644
index 00000000..a9dfbfd8
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_interface0_CC.h
@@ -0,0 +1,97 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_interface0_CC.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_CC_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_CC_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for amr
+ * (CC implementation)
+ *
+ * groups together various methods to get info about amr patches and levels which
+ * depend on the different types of variable representation allowing to choose
+ * the relevant implementation at compile time
+ *
+ * @implements amr_interface0 < VAR >
+ */
+template<>
+class amr_interface0<CC>
+{
+protected: // CONSTRUCTORS/DESTRUCTOR
+
+    /// prevent coonstruction
+    amr_interface0() = delete;
+
+    /// Prevent copy (and move) constructor
+    amr_interface0 ( const amr_interface0 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_interface0 & operator= ( const amr_interface0 & ) = delete;
+
+public: // STATIC METHODS
+
+    /**
+     * @brief Get coarser grid index
+     *
+     * @param l fine grid level
+     * @param i fine grid index
+     * @return nearest coarser grid index to the given position
+     */
+    static inline IntVector get_coarser ( const Level * l, const IntVector & i )
+    {
+        return l->mapCellToCoarser ( i );
+    }
+
+    /**
+     * @brief Get finer grid index
+     *
+     * @param l coarse grid level
+     * @param i coarse grid index
+     * @return nearest finer grid index to the given position
+     */
+    static inline IntVector get_finer ( const Level * l, const IntVector & i )
+    {
+        return l->mapCellToFiner ( i );
+    }
+
+}; // class amr_interface0
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_CC_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_interface0_NC.h b/src/CCA/Components/PhaseField/AMR/detail/amr_interface0_NC.h
new file mode 100644
index 00000000..3388c403
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_interface0_NC.h
@@ -0,0 +1,96 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_interface0_CC.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_NC_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_NC_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for amr
+ * (NC implementation)
+ *
+ * groups together various methods to get info about amr patches and levels which
+ * depend on the different types of variable representation allowing to choose
+ * the relevant implementation at compile time
+ *
+ * @implements amr_interface0 < VAR >
+ */
+template<> class amr_interface0<NC>
+{
+protected: // CONSTRUCTORS/DESTRUCTOR
+
+    /// prevent coonstruction
+    amr_interface0() = delete;
+
+    /// Prevent copy (and move) constructor
+    amr_interface0 ( const amr_interface0 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_interface0 & operator= ( const amr_interface0 & ) = delete;
+
+public: // STATIC METHODS
+
+    /**
+     * @brief Get coarser grid index
+     *
+     * @param l fine grid level
+     * @param i fine grid index
+     * @return nearest coarser grid index to the given position
+     */
+    static inline IntVector get_coarser ( const Level * l, const IntVector & i )
+    {
+        return l->mapNodeToCoarser ( i );
+    }
+
+    /**
+     * @brief Get finer grid index
+     *
+     * @param l coarse grid level
+     * @param i coarse grid index
+     * @return nearest finer grid index to the given position
+     */
+    static inline IntVector get_finer ( const Level * l, const IntVector & i )
+    {
+        return l->mapNodeToFiner ( i );
+    }
+
+}; // class amr_interface0
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interface0_NC_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator.h b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator.h
new file mode 100644
index 00000000..bb461063
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator.h
@@ -0,0 +1,153 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_interpolator.h
+ * @author Jon Matteo Church
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/Util/Expressions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Abstract wrapper of grid variables for interpolation from coarser to
+ *        finer levels.
+ *
+ * Adds to view the possibility to compute multi-grid interpolation
+ *
+ * @remark All different interpolation strategies must specialize this class and
+ *         implement the view< T > class
+ *
+ * @tparam Field type of Field (should be only ScalarField)
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ */
+template<typename Field, typename Problem, typename Index, FCIType FCI, DimType DIM> class amr_interpolator;
+
+/**
+ * @brief Abstract wrapper of grid variables for interpolation from coarser to
+ * finer levels. (VectorField implementation)
+ *
+ * Adds to view the possibility to compute multi-grid interpolation
+ *
+ * @tparam T type of each component of the field at each point
+ * @tparam N number of components
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ */
+template<typename T, size_t N, typename Problem, typename Index, FCIType FCI, DimType DIM>
+class amr_interpolator < VectorField<T, N>, Problem, Index, FCI, DIM >
+    : public view_array < amr_interpolator < ScalarField<T>, Problem, Index, FCI, DIM >, ScalarField<T>, N >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = VectorField<T, N>;
+
+    /// Type of View of each component
+    using View = amr_interpolator < ScalarField<T>, Problem, Index, FCI, DIM >;
+
+public:
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate amr_interpolator components without gathering info from the DataWarehouse
+     *
+     * @param label list of variable labels for each component
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material material index
+     */
+    amr_interpolator (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+            this->m_view_ptr[i] = new View ( label[i], subproblems_label, material );
+    }
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate amr_interpolator components and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label list of variable labels for each component
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material material index
+     * @param patch grid patch
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    amr_interpolator (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = View::use_ghosts_dflt
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+            this->m_view_ptr[i] = new View ( dw, label[i], material, subproblems_label, patch, use_ghosts );
+    }
+
+    /// Destructor
+    virtual ~amr_interpolator()
+    {
+        for ( auto view : this->m_view_ptr )
+            delete view;
+    }
+
+    /// Prevent copy (and move) constructor
+    amr_interpolator ( const amr_interpolator & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_interpolator & operator= ( const amr_interpolator & ) = delete;
+};
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#include <CCA/Components/PhaseField/AMR/detail/amr_interpolator_I0.h>
+#include <CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D1.h>
+#include <CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D2.h>
+#include <CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D3.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I0.h b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I0.h
new file mode 100644
index 00000000..929e36b5
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I0.h
@@ -0,0 +1,371 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_interpolator_I0.h
+ * @author Jon Matteo Church
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I0_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I0_h
+
+#include <CCA/Components/PhaseField/AMR/detail/amr_coarser_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of grid variables for interpolation from coarser to finer levels
+ * (piecewise implementation)
+ *
+ * implements piecewise constant interpolation of a variable from coarser
+ * to finer levels in 1D
+ *
+ * @tparam T variable data type (must be constant)
+ * @tparam Problem type of PhaseField problem
+ * @tparam I list of indices corresponding to the variable within the subproblems
+ * @tparam DIM problem dimension
+ *
+ * @implements amr_interpolator< Field, Problem, Index, FCI, DIM >
+ */
+template<typename T, typename Problem, size_t... I, DimType DIM >
+class amr_interpolator < ScalarField<T>, Problem, index_sequence<I...>, I0, DIM >
+    : virtual public view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// Problem variable representation
+    static constexpr VarType VAR = Problem::Var;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Field index
+    using Index = index_sequence<I...>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( Problem::Dim == DIM, "non consistent dimension" );
+    static_assert ( std::is_same< typename Problem::template get_field<I...>::type, ScalarField<T> >::value, "non consistent field types" );
+    static_assert ( std::is_const<T>::value, "amr_interpolator with non const base" );
+
+private: // MEMBERS
+
+    /// inner view to variable on coarser level
+    amr_coarser_view<Field, Problem, Index> * m_view_coarse;
+
+    /// finer level
+    const Level * m_level_fine;
+
+    /// coarser level
+    const Level * m_level_coarse;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get coarse value at position
+     *
+     * @param id coarse index
+     * @return coarse value at id
+     */
+    inline T
+    coarse_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & view_coarse = *m_view_coarse;
+        return view_coarse[id];
+    }
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    amr_interpolator (
+        const amr_interpolator * copy,
+        bool deep
+    ) : m_view_coarse ( dynamic_cast < amr_coarser_view<Field, Problem, Index> * > ( copy->m_view_coarse->clone ( deep ) ) ),
+        m_level_fine ( copy->m_level_fine ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * construct interpolator without retrieving inner variable data from
+     * the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     */
+    amr_interpolator (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material
+    ) : m_view_coarse ( scinew amr_coarser_view<Field, Problem, Index> ( label, subproblems_label, material ) ),
+        m_level_fine ( nullptr ),
+        m_level_coarse ( nullptr )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * construct interpolator and retrieve inner variable data from the
+     * DataWarehouse within a given fine patch.
+     *
+     * @remark the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts must be false
+     */
+    amr_interpolator (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : m_view_coarse ( scinew amr_coarser_view<Field, Problem, Index> ( dw, label, subproblems_label, material, patch ) ),
+        m_level_fine ( patch->getLevel() ),
+        m_level_coarse ( m_level_fine->getCoarserLevel().get_rep() )
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        m_support.emplace_back ( DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ) );
+    }
+
+    /// Destructor
+    virtual ~amr_interpolator()
+    {
+        delete m_view_coarse;
+    }
+
+    /// Prevent copy (and move) constructor
+    amr_interpolator ( const amr_interpolator & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_interpolator & operator= ( const amr_interpolator & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse within a given
+     *        patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        m_support.clear();
+        m_view_coarse->set ( dw, patch );
+        m_level_fine = patch->getLevel();
+        m_level_coarse = m_level_fine->getCoarserLevel().get_rep();
+        m_support.emplace_back ( DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ) );
+    }
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse within a given
+     *        region.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param level level of the fine region
+     * @param low start index for the fine region
+     * @param high past the end index for the fine region
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        m_support.clear();
+        m_view_coarse->set ( dw, level, low, high );
+        m_level_fine = level;
+        m_level_coarse = m_level_fine->getCoarserLevel().get_rep();
+        m_support.emplace_back ( low, high );
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual inline view<Field> *
+    clone (
+        bool deep
+    )
+    const override
+    {
+        return scinew amr_interpolator ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual inline view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<amr_interpolator, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief get interpolator's fine range
+     *
+     * @return fine range
+     */
+    virtual inline Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the fine position with index id
+     *
+     * @param id fine position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        const IntVector low
+        {
+            m_support.front().getLow()
+        };
+        const IntVector high
+        {
+            m_support.front().getHigh()
+        };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (virtual implementation)
+     *
+     * @remark interpolated value is computed at runtime thus doesn't exist in the
+     * DataWarehouse
+     *
+     * @param id unused
+     * @return nothing
+     */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief get interpolated value
+     *
+     * value at fine index is computed using the value at the nearset index
+     * on the coarser level
+     *
+     * @param id_fine fine index
+     * @return interpolated value at the given fine index
+     */
+    virtual inline V
+    operator[] (
+        const IntVector & id_fine
+    ) const override
+    {
+        IntVector id_coarse ( AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, id_fine ) );
+        return coarse_value ( id_coarse );
+    }
+
+}; // class amr_interpolator<I0>
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I0_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D1.h b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D1.h
new file mode 100644
index 00000000..39ae7b66
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D1.h
@@ -0,0 +1,438 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D1.h
+ * @author Jon Matteo Church
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I1_D1_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I1_D1_h
+
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+#include <CCA/Components/PhaseField/Views/View.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of grid variables for interpolation from coarser to finer levels
+ * (1D linear implementation)
+ *
+ * Implements linear interpolation of a variable from coarser to finer
+ * levels in 1D
+ *
+ * @tparam T variable data type (must be constant)
+ * @tparam Problem type of PhaseField problem
+ * @tparam I list of indices corresponding to the variable within the subproblems
+ *
+ * @todo generalize implementation to arbitrary dimension
+ *
+ * @implements amr_interpolator < Field, Problem, Index, FCI, DIM >
+ */
+template<typename T, typename Problem, size_t... I>
+class amr_interpolator < ScalarField<T>, Problem, index_sequence<I...>, I1,  D1>
+    : virtual public view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// interpolation type: linear-interpolation (I1)
+    static constexpr FCIType FCI = I1;
+
+    /// Problem variable representation
+    static constexpr DimType DIM = D1;
+
+    /// Problem variable representation
+    static constexpr VarType VAR = Problem::Var;
+
+    /// number of fine ghosts which corresponds to the coarse region required by interpolation
+    static constexpr int E = get_fci<FCI>::elems / 2;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Field index
+    using Index = index_sequence<I...>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( Problem::Dim == DIM, "non consistent dimension" );
+    static_assert ( std::is_same< typename Problem::template get_field<I...>::type, ScalarField<T> >::value, "non consistent field types" );
+    static_assert ( std::is_const<T>::value, "amr_interpolator with non const base" );
+
+private: // MEMBERS
+
+    /// inner view to variable on coarser level
+    amr_coarser_view<Field, Problem, Index> * m_view_coarse;
+
+    /// finer level
+    const Level * m_level_fine;
+
+    /// coarser level
+    const Level * m_level_coarse;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get coarse value at position
+     *
+     * @param id coarse index
+     * @return coarse value at id
+     */
+    const T
+    coarse_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & view_coarse = *m_view_coarse;
+        return view_coarse [id];
+    }
+
+    /**
+     * @brief Compute required fine region
+     *
+     * Compute fine region corresponding to the coarse one required to
+     * compute the interpolation at fine indices within the given bounds
+     *
+     * @param low lower bound of the region where to perform interpolation
+     * @param high higher bound of the region where to perform interpolation
+     * @return required region
+     */
+    Region
+    compute_fine_region (
+        const IntVector & low,
+        const IntVector & high
+    )
+    {
+        IntVector r = m_level_fine->getRefinementRatio();
+        IntVector l_ghosts {0, 0, 0}, h_ghosts {0, 0, 0};
+        for ( size_t d = 0; d < DIM; ++d )
+        {
+            int total = r[d] * ( E - 1 );
+            h_ghosts[d] = total / 2;
+            l_ghosts[d] = total - h_ghosts[d];
+            if ( Problem::VAR == NC )
+            {
+                if ( !low[d] % r[d] && l_ghosts[d] > 1 ) l_ghosts[d] -= 1;
+                if ( !high[d] % r[d] && h_ghosts[d] > 1 ) h_ghosts[d] -= 1;
+            }
+        }
+
+        Region fine_region;
+        fine_region.low() = low - l_ghosts;
+        fine_region.high() = high + h_ghosts;
+
+        return fine_region;
+    }
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    amr_interpolator (
+        const amr_interpolator * copy,
+        bool deep
+    ) : m_view_coarse ( dynamic_cast < amr_coarser_view<Field, Problem, Index> * > ( copy->m_view_coarse->clone ( deep ) ) ),
+        m_level_fine ( copy->m_level_fine ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief construct interpolator without retrieving inner variable data from
+     *        the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     */
+    amr_interpolator (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material
+    ) : m_view_coarse ( label, subproblems_label, material ),
+        m_level_fine ( nullptr ),
+        m_level_coarse ( nullptr )
+    {
+    }
+
+    /**
+     * @brief construct interpolator and retrieve inner variable data from the
+     *        DataWarehouse whitin a given fine patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    amr_interpolator (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : m_view_coarse ( dw, label, subproblems_label, material ),
+        m_level_fine ( patch->getLevel() ),
+        m_level_coarse ( m_level_fine->getCoarserLevel().get_rep() )
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        set ( dw, patch );
+    }
+
+    /// Destructor
+    virtual ~amr_interpolator()
+    {
+        delete m_view_coarse;
+    }
+
+    /// Prevent copy (and move) constructor
+    amr_interpolator ( const amr_interpolator & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_interpolator & operator= ( const amr_interpolator & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whitin a given
+     *        patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        set ( dw, patch->getLevel(), DWInterface<Problem::VAR, Problem::DIM>::get_low ( patch ), DWInterface<Problem::VAR, Problem::DIM>::get_high ( patch ) );
+    }
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whitin a given
+     *        region.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param level level of the fine region
+     * @param low start index for the fine region
+     * @param high past the end index for the fine region
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" )
+        m_support.clear();
+        m_level_fine = level;
+        m_level_coarse = m_level_fine->getCoarserLevel().get_rep();
+        Region fine_region = compute_fine_region ( low, high );
+        m_view_coarse.set ( dw, level, fine_region.low(), fine_region.high() );
+        m_support.emplace_back ( low, high );
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual inline view<Field> *
+    clone (
+        bool deep
+    )
+    const override
+    {
+        return scinew amr_interpolator ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual inline view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<amr_interpolator, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief get interpolator's fine range
+     *
+     * @return fine range
+     */
+    virtual inline Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the fine position with index id
+     *
+     * @param id fine position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        const IntVector low
+        {
+            m_support.front().getLow()
+        };
+        const IntVector high
+        {
+            m_support.front().getHigh()
+        };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (virtual implementation)
+     *
+     * @remark interpolated value is computed at runtime thus doesn't exist in the
+     * DataWarehouse
+     *
+     * @param id unused
+     * @return nothing
+     */
+    virtual T &
+    operator[]
+    (
+        const IntVector & _DOXYARG ( id )
+    ) override  VIRT;
+
+    /**
+     * @brief get interpolated value
+     *
+     * value at fine index is computed by linear interpolation over the
+     * nearest 2 indexes on the coarser level
+     *
+     * @param id_fine fine index
+     * @return interpolated value at the given fine index
+     */
+    virtual T
+    operator[] (
+        const IntVector & id_fine
+    ) const override
+    {
+        IntVector id_coarse ( m_level_fine->mapCellToCoarser ( id_fine ) );
+        Point p_fine ( DWInterface<Problem::VAR, Problem::DIM>::get_position ( m_level_fine, id_fine ) );
+        Point p_coarse ( DWInterface<Problem::VAR, Problem::DIM>::get_position ( m_level_coarse, id_coarse ) );
+        Vector dist = ( p_fine.asVector() - p_coarse.asVector() ) / m_level_coarse->dCell();
+        double w[2] = { 1., 1. };
+        IntVector n[2] = { id_coarse, id_coarse };
+        const double & dx = dist[X];
+        if ( dx < 0. )
+        {
+            n[0][X] -= 1;
+            w[0] *= -dx;
+            w[1] *= 1 + dx;
+        }
+        else if ( dx > 0. )
+        {
+            n[1][X] += 1;
+            w[0] *= 1 - dx;
+            w[1] *= dx;
+        }
+        else
+        {
+            w[1] = 0.;
+        }
+        return w[0] * coarse_value ( n[0] ) +
+               w[1] * coarse_value ( n[1] );
+    }
+
+}; // class amr_interpolator
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I0_D1_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D2.h b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D2.h
new file mode 100644
index 00000000..b5db37b0
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D2.h
@@ -0,0 +1,464 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D2.h
+ * @author Jon Matteo Church
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I1_D2_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I1_D2_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Implements linear interpolation of a variable from coarser to finer
+ *        levels in 2D
+ *
+ * @todo generalize implementation over DIM
+ *
+ * @tparam T variable data type (must be constant)
+ * @tparam Problem type of PhaseField problem
+ * @tparam I list of indices corresponding to the variable within the subproblems
+ *
+ * @todo generalize implementation to arbitrary dimension
+ *
+ * @implements amr_interpolator< Field, Problem, Index, FCI, DIM >
+ */
+template<typename T, typename Problem, size_t... I>
+class amr_interpolator < ScalarField<T>, Problem, index_sequence<I...>, I1, D2 >
+    : virtual public view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// Problem variable representation
+    static constexpr VarType VAR = Problem::Var;
+
+    /// interpolation type: piecewise constant (I0) or linear-interpolation (I1)
+    static constexpr FCIType FCI = I1;
+
+    /// problem dimension
+    static constexpr DimType DIM = D2;
+
+    /// number elements in the coarse region required by interpolation
+    static constexpr int E = get_fci<FCI>::elems;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Field index
+    using Index = index_sequence<I...>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( Problem::Dim == DIM, "non consistent dimension" );
+    static_assert ( std::is_same< typename Problem::template get_field<I...>::type, ScalarField<T> >::value, "non consistent field types" );
+    static_assert ( std::is_const<T>::value, "amr_interpolator with non const base" );
+
+private: // MEMBERS
+
+    /// inner view to variable on coarser level
+    amr_coarser_view<Field, Problem, Index> * m_view_coarse;
+
+    /// finer level
+    const Level * m_level_fine;
+
+    /// coarser level
+    const Level * m_level_coarse;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get coarse value at position
+     *
+     * @param id coarse index
+     * @return fine value at id
+     */
+    const T
+    coarse_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & view_coarse = *m_view_coarse;
+        return view_coarse[id];
+    }
+
+    /**
+     * @brief Compute required fine region
+     *
+     * Compute fine region corresponding to the coarse one required to
+     * compute the interpolation at fine indices within the given bounds
+     *
+     * @param low lower bound of the region where to perform interpolation
+     * @param high higher bound of the region where to perform interpolation
+     * @return required region
+     */
+    Region
+    compute_fine_region (
+        const IntVector & low,
+        const IntVector & high
+    )
+    {
+        IntVector r = m_level_fine->getRefinementRatio();
+        IntVector l_ghosts {0, 0, 0}, h_ghosts {0, 0, 0};
+        for ( size_t d = 0; d < DIM; ++d )
+        {
+            int total = r[d] * ( E - 1 );
+            h_ghosts[d] = total / 2;
+            l_ghosts[d] = total - h_ghosts[d];
+            if ( VAR == NC )
+            {
+                if ( ! ( low[d] % r[d] ) && l_ghosts[d] > 0 ) l_ghosts[d] -= 1;
+                if ( ! ( ( high[d] - 1 ) % r[d] ) && h_ghosts[d] > 0 ) h_ghosts[d] -= 1;
+            }
+        }
+
+        Region fine_region;
+        fine_region.low() = low - l_ghosts;
+        fine_region.high() = high + h_ghosts;
+
+        return fine_region;
+    }
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    amr_interpolator (
+        const amr_interpolator * copy,
+        bool deep
+    ) : m_view_coarse ( dynamic_cast < amr_coarser_view<Field, Problem, Index> * > ( copy->m_view_coarse->clone ( deep ) ) ),
+        m_level_fine ( copy->m_level_fine ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief construct interpolator without retrieving inner variable data from
+     *        the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     */
+    amr_interpolator (
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material
+    ) : m_view_coarse ( scinew amr_coarser_view<Field, Problem, Index> ( label, subproblems_label, material ) ),
+        m_level_fine ( nullptr ),
+        m_level_coarse ( nullptr )
+    {
+    }
+
+    /**
+     * @brief construct interpolator and retrieve inner variable data from the
+     *        DataWarehouse whithin a given fine patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    amr_interpolator (
+        DataWarehouse * dw,
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : m_view_coarse ( scinew amr_coarser_view<Field, Problem, Index> ( label, subproblems_label, material ) ),
+        m_level_fine ( patch->getLevel() ),
+        m_level_coarse ( m_level_fine->getCoarserLevel().get_rep() )
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        set ( dw, patch );
+    }
+
+    /// Destructor
+    virtual ~amr_interpolator()
+    {
+        delete m_view_coarse;
+    }
+
+    /// Prevent copy (and move) constructor
+    amr_interpolator ( const amr_interpolator & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_interpolator & operator= ( const amr_interpolator & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whithin a given
+     *        patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        set ( dw, patch->getLevel(), DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ) );
+    }
+
+    /**
+    * @brief retrieve inner variable data from the DataWarehouse whithin a given
+    *        region.
+    *
+    * the number of ghost cells/nodes and the corresponding region on the
+    * coarser level is automatically computed to match the interpolation type
+    *
+    * @param dw DataWarehouse which data is retrieved from
+    * @param level level of the fine region
+    * @param low start index for the fine region
+    * @param high past the end index for the fine region
+    * @param use_ghosts if ghosts value are to be retrieved (must be false)
+    */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" )
+        m_support.clear();
+        m_level_fine = level;
+        m_level_coarse = m_level_fine->getCoarserLevel().get_rep();
+        Region fine_region = compute_fine_region ( low, high );
+        m_view_coarse->set ( dw, level, fine_region.low(), fine_region.high() );
+        m_support.emplace_back ( low, high );
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    )
+    const override
+    {
+        return scinew amr_interpolator ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<amr_interpolator, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief get interpolator's fine range
+     *
+     * @return fine range
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the fine position with index id
+     *
+     * @param id fine position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        const IntVector low
+        {
+            m_support.front().getLow()
+        };
+        const IntVector high
+        {
+            m_support.front().getHigh()
+        };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (virtual implementation)
+     *
+     * @remark interpolated value is computed at runtime thus doesn't exist in the
+     * DataWarehouse
+     *
+     * @param id unused
+     * @return nothing
+     */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief get interpolated value
+     *
+     * value at fine index is computed by bi-linear interpolation over the
+     * nearest 4 indexes on the coarser level
+     *
+     * @param id_fine fine index
+     * @return interpolated value at the given fine index
+     */
+    virtual V
+    operator[] (
+        const IntVector & id_fine
+    ) const override
+    {
+        IntVector id_coarse ( m_level_fine->mapCellToCoarser ( id_fine ) );
+        Point p_fine ( DWInterface<VAR, DIM>::get_position ( m_level_fine, id_fine ) );
+        Point p_coarse ( DWInterface<VAR, DIM>::get_position ( m_level_coarse, id_coarse ) );
+        Vector dist = ( p_fine.asVector() - p_coarse.asVector() ) / m_level_coarse->dCell();
+        double w[2][2] = {{ 1., 1. }, { 1., 1. }};
+        IntVector n[2][2] = {{ id_coarse, id_coarse }, { id_coarse, id_coarse }};
+        const double & dx = dist[X];
+        const double & dy = dist[Y];
+        if ( dx < 0. )
+        {
+            n[0][0][X] = n[0][1][X] -= 1;
+            w[0][0] *= -dx;
+            w[0][1] *= -dx;
+            w[1][0] *= 1 + dx;
+            w[1][1] *= 1 + dx;
+        }
+        else if ( dx > 0. )
+        {
+            n[1][0][X] = n[1][1][X] += 1;
+            w[0][0] *= 1 - dx;
+            w[0][1] *= 1 - dx;
+            w[1][0] *= dx;
+            w[1][1] *= dx;
+        }
+        else
+        {
+            w[1][0] = 0.;
+            w[1][1] = 0.;
+        }
+
+        if ( dy < 0. )
+        {
+            n[0][0][Y] = n[1][0][Y] -= 1;
+            w[0][0] *= -dy;
+            w[1][0] *= -dy;
+            w[0][1] *= 1 + dy;
+            w[1][1] *= 1 + dy;
+        }
+        else if ( dy > 0. )
+        {
+            n[0][1][Y] = n[1][1][Y] += 1;
+            w[0][0] *= 1 - dy;
+            w[1][0] *= 1 - dy;
+            w[0][1] *= dy;
+            w[1][1] *= dy;
+        }
+        else
+        {
+            w[0][1] = 0.;
+            w[1][1] = 0.;
+        }
+
+        return w[0][0] * coarse_value ( n[0][0] ) +
+               w[0][1] * coarse_value ( n[0][1] ) +
+               w[1][0] * coarse_value ( n[1][0] ) +
+               w[1][1] * coarse_value ( n[1][1] );
+    }
+
+}; // class amr_interpolator
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I1_D2_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D3.h b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D3.h
new file mode 100644
index 00000000..34ea7c4d
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D3.h
@@ -0,0 +1,524 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, ILUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_interpolator_I1_D3.h
+ * @author Jon Matteo Church
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I1_D3_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I1_D3_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of grid variables for interpolation from coarser to finer levels
+ * (3D linear implementation)
+ *
+ * Implements linear interpolation of a variable from coarser to finer
+ * levels in 3D
+ *
+ * @bug this is actually broken since it could happen that interpolation is
+ * requiring values from coarse level that are not extrapolated by bcs!
+ * @todo implment as recursion over dimension to avoid this issue!
+ *
+ * @tparam T variable data type (must be constant)
+ * @tparam Problem type of PhaseField problem
+ * @tparam I list of indices corresponding to the variable within the subproblems
+ *
+ * @todo generalize implementation to arbitrary dimension
+ *
+ * @implements amr_interpolator< Field, Problem, Index, FCI, DIM >
+ */
+template<typename T, typename Problem, size_t... I>
+class amr_interpolator < ScalarField<T>, Problem, index_sequence<I...>, I1, D3 >
+    : virtual public view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// Problem variable representation
+    static constexpr VarType VAR = Problem::Var;
+
+    /// interpolation type: linear-interpolation (I1)
+    static constexpr FCIType FCI = I1;
+
+    /// problem dimension
+    static constexpr DimType DIM = D3;
+
+    /// number elements in the coarse region required by interpolation
+    static constexpr int E = get_fci<FCI>::elems;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Field index
+    using Index = index_sequence<I...>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( Problem::Dim == DIM, "non consistent dimension" );
+    static_assert ( std::is_same< typename Problem::template get_field<I...>::type, ScalarField<T> >::value, "non consistent field types" );
+    static_assert ( std::is_const<T>::value, "amr_interpolator with non const base" );
+
+private: // MEMBERS
+
+    /// inner view to variable on coarser level
+    amr_coarser_view<Field, Problem, Index> * m_view_coarse;
+
+    /// finer level
+    const Level * m_level_fine;
+
+    /// coarser level
+    const Level * m_level_coarse;
+
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get coarse value at position
+     *
+     * @param id coarse index
+     * @return fine value at id
+     */
+    const T
+    coarse_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & view_coarse = *m_view_coarse;
+        return view_coarse[id];
+    }
+
+    /**
+     * @brief Compute required fine region
+     *
+     * Compute fine region corresponding to the coarse one required to
+     * compute the interpolation at fine indices within the given bounds
+     *
+     * @param low lower bound of the region where to perform interpolation
+     * @param high higher bound of the region where to perform interpolation
+     * @return required region
+     */
+    Region
+    compute_fine_region (
+        const IntVector & low,
+        const IntVector & high
+    )
+    {
+        IntVector r = m_level_fine->getRefinementRatio();
+        IntVector l_ghosts {0, 0, 0}, h_ghosts {0, 0, 0};
+        for ( size_t d = 0; d < DIM; ++d )
+        {
+            int total = r[d] * ( E - 1 );
+            h_ghosts[d] = total / 2;
+            l_ghosts[d] = total - h_ghosts[d];
+            if ( VAR == NC )
+            {
+                if ( ! ( low[d] % r[d] ) && l_ghosts[d] > 0 ) l_ghosts[d] -= 1;
+                if ( ! ( ( high[d] - 1 ) % r[d] ) && h_ghosts[d] > 0 ) h_ghosts[d] -= 1;
+            }
+        }
+
+        Region fine_region;
+        fine_region.low() = low - l_ghosts;
+        fine_region.high() = high + h_ghosts;
+
+        return fine_region;
+    }
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    amr_interpolator (
+        const amr_interpolator * copy,
+        bool deep
+    ) : m_view_coarse ( dynamic_cast < amr_coarser_view<Field, Problem, Index> * > ( copy->m_view_coarse->clone ( deep ) ) ),
+        m_level_fine ( copy->m_level_fine ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief construct interpolator without retrieving inner variable data from
+     *        the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     */
+    amr_interpolator (
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material
+    ) : m_view_coarse ( scinew amr_coarser_view<Field, Problem, Index> ( label, subproblems_label, material ) ),
+        m_level_fine ( nullptr ),
+        m_level_coarse ( nullptr )
+    {
+    }
+
+    /**
+     * @brief construct interpolator and retrieve inner variable data from the
+     *        DataWarehouse whitin a given fine patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    amr_interpolator (
+        DataWarehouse * dw,
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : m_view_coarse ( scinew amr_coarser_view<Field, Problem, Index> ( label, subproblems_label, material ) ),
+        m_level_fine ( patch->getLevel() ),
+        m_level_coarse ( m_level_fine->getCoarserLevel().get_rep() )
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        set ( dw, patch );
+    }
+
+    /// Destructor
+    virtual ~amr_interpolator()
+    {
+        delete m_view_coarse;
+    }
+
+    /// Prevent copy (and move) constructor
+    amr_interpolator ( const amr_interpolator & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_interpolator & operator= ( const amr_interpolator & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whitin a given
+     *        patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        set ( dw, patch->getLevel(), DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ) );
+    }
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whitin a given
+     *        region.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param level level of the fine region
+     * @param low start index for the fine region
+     * @param high past the end index for the fine region
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" )
+        m_support.clear();
+        m_level_fine = level;
+        m_level_coarse = m_level_fine->getCoarserLevel().get_rep();
+        Region fine_region = compute_fine_region ( low, high );
+        m_view_coarse->set ( dw, level, fine_region.low(), fine_region.high() );
+        m_support.emplace_back ( low, high );
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    )
+    const override
+    {
+        return scinew amr_interpolator ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<amr_interpolator, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief get interpolator's fine range
+     *
+     * @return fine range
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the fine position with index id
+     *
+     * @param id fine position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        const IntVector low
+        {
+            m_support.front().getLow()
+        };
+        const IntVector high
+        {
+            m_support.front().getHigh()
+        };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (virtual implementation)
+     *
+     * @remark interpolated value is computed at runtime thus doesn't exist in the
+     * DataWarehouse
+     *
+     * @param id unused
+     * @return nothing
+     */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief get interpolated value
+     *
+     * value at fine index is computed by tri-linear interpolation over the
+     * nearest 8 indexes on the coarser level
+     *
+     * @param id_fine fine index
+     * @return interpolated value at the given fine index
+     */
+    virtual V
+    operator[] (
+        const IntVector & id_fine
+    ) const override
+    {
+        IntVector id_coarse ( m_level_fine->mapCellToCoarser ( id_fine ) );
+        Point p_fine ( DWInterface<VAR, DIM>::get_position ( m_level_fine, id_fine ) );
+        Point p_coarse ( DWInterface<VAR, DIM>::get_position ( m_level_coarse, id_coarse ) );
+        Vector dist = ( p_fine.asVector() - p_coarse.asVector() ) / m_level_coarse->dCell();
+        double w[2][2][2] = {{{ 1., 1. }, { 1., 1. }}, {{ 1., 1. }, { 1., 1. }}};
+        IntVector n[2][2][2] = {{{ id_coarse, id_coarse }, { id_coarse, id_coarse }}, {{ id_coarse, id_coarse }, { id_coarse, id_coarse }}};
+        const double & dx = dist[X];
+        const double & dy = dist[Y];
+        const double & dz = dist[Z];
+        if ( dx < 0. )
+        {
+            n[0][0][0][X] = n[0][1][0][X] = n[0][0][1][X] = n[0][1][1][X] -= 1;
+            w[0][0][0] *= -dx;
+            w[0][1][0] *= -dx;
+            w[0][0][1] *= -dx;
+            w[0][1][1] *= -dx;
+            w[1][0][0] *= 1 + dx;
+            w[1][1][0] *= 1 + dx;
+            w[1][0][1] *= 1 + dx;
+            w[1][1][1] *= 1 + dx;
+        }
+        else if ( dx > 0. )
+        {
+            n[1][0][0][X] = n[1][1][0][X] = n[1][0][1][X] = n[1][1][1][X] += 1;
+            w[0][0][0] *= 1 - dx;
+            w[0][1][0] *= 1 - dx;
+            w[0][0][1] *= 1 - dx;
+            w[0][1][1] *= 1 - dx;
+            w[1][0][1] *= dx;
+            w[1][1][1] *= dx;
+            w[1][0][1] *= dx;
+            w[1][1][1] *= dx;
+        }
+        else
+        {
+            w[1][0][0] = 0.;
+            w[1][1][0] = 0.;
+            w[1][0][1] = 0.;
+            w[1][1][1] = 0.;
+        }
+
+        if ( dy < 0. )
+        {
+            n[0][0][0][Y] = n[1][0][0][Y] = n[0][0][1][Y] = n[1][0][1][Y] -= 1;
+            w[0][0][0] *= -dy;
+            w[1][0][0] *= -dy;
+            w[0][0][1] *= -dy;
+            w[1][0][1] *= -dy;
+            w[0][1][0] *= 1 + dy;
+            w[1][1][0] *= 1 + dy;
+            w[0][1][1] *= 1 + dy;
+            w[1][1][1] *= 1 + dy;
+        }
+        else if ( dy > 0. )
+        {
+            n[0][1][0][Y] = n[1][1][0][Y] = n[0][1][1][Y] = n[1][1][1][Y] += 1;
+            w[0][0][0] *= 1 - dy;
+            w[1][0][0] *= 1 - dy;
+            w[0][0][1] *= 1 - dy;
+            w[1][0][1] *= 1 - dy;
+            w[0][1][0] *= dy;
+            w[1][1][0] *= dy;
+            w[0][1][1] *= dy;
+            w[1][1][1] *= dy;
+        }
+        else
+        {
+            w[0][1][0] = 0.;
+            w[1][1][0] = 0.;
+            w[0][1][1] = 0.;
+            w[1][1][1] = 0.;
+        }
+
+        if ( dz < 0. )
+        {
+            n[0][0][0][Z] = n[0][1][0][Z] = n[1][0][0][Z] = n[1][1][0][Z] -= 1;
+            w[0][0][0] *= -dz;
+            w[0][1][0] *= -dz;
+            w[1][0][0] *= -dz;
+            w[1][1][0] *= -dz;
+            w[0][0][1] *= 1 + dz;
+            w[0][1][1] *= 1 + dz;
+            w[1][0][1] *= 1 + dz;
+            w[1][1][1] *= 1 + dz;
+        }
+        else if ( dz > 0. )
+        {
+            n[0][0][1][Z] = n[0][1][1][Z] = n[1][0][1][Z] = n[1][1][1][Z] += 1;
+            w[0][0][0] *= 1 - dz;
+            w[0][1][0] *= 1 - dz;
+            w[1][0][0] *= 1 - dz;
+            w[1][1][0] *= 1 - dz;
+            w[0][0][1] *= dz;
+            w[0][1][1] *= dz;
+            w[1][0][1] *= dz;
+            w[1][1][1] *= dz;
+        }
+        else
+        {
+            w[0][0][1] = 0.;
+            w[0][1][1] = 0.;
+            w[1][0][1] = 0.;
+            w[1][1][1] = 0.;
+        }
+
+        return w[0][0][0] * coarse_value ( n[0][0][0] ) +
+               w[0][0][1] * coarse_value ( n[0][0][1] ) +
+               w[0][1][0] * coarse_value ( n[0][1][0] ) +
+               w[0][1][1] * coarse_value ( n[0][1][1] ) +
+               w[1][0][0] * coarse_value ( n[1][0][0] ) +
+               w[1][0][1] * coarse_value ( n[1][0][1] ) +
+               w[1][1][0] * coarse_value ( n[1][1][0] ) +
+               w[1][1][1] * coarse_value ( n[1][1][1] );
+    }
+
+}; // class amr_interpolator <I1, D3>
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_interpolator_I1_D3_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor.h b/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor.h
new file mode 100644
index 00000000..fe809957
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor.h
@@ -0,0 +1,150 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_restrictor.h
+ * @author Jon Matteo Church
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Abstract wrapper of grid variables for restriction from finer to
+ *        coarser levels.
+ *
+ * Adds to view the possibility to compute multi-grid restriction
+ *
+ * @remark All different restriction strategies must specialize this class and
+ *         implement the view< T > class
+ *
+ * @tparam Field type of Field (should be only ScalarField)
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ */
+template<typename Field, typename Problem, typename Index, FCIType FCI, VarType VAR> class amr_restrictor;
+
+/**
+ * @brief Abstract wrapper of grid variables for restriction from finer to
+ * coarser levels. (VectorField implementation)
+ *
+ * Adds to view the possibility to compute multi-grid interpolation
+ *
+ * @tparam T type of each component of the field at each point
+ * @tparam N number of components
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ */
+template<typename T, size_t N, typename Problem, typename Index, FCIType FCI, DimType DIM>
+class amr_restrictor < VectorField<T, N>, Problem, Index, FCI, DIM >
+    : public view_array < amr_restrictor < ScalarField<T>, Problem, Index, FCI, DIM >, ScalarField<T>, N >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = VectorField<T, N>;
+
+    /// Type of View of each component
+    using View = amr_restrictor < ScalarField<T>, Problem, Index, FCI, DIM >;
+
+public:
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate amr_restrictor components without gathering info from the DataWarehouse
+     *
+     * @param label list of variable labels for each component
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material material index
+     */
+    amr_restrictor (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+            this->m_view_ptr[i] = new View ( label[i], subproblems_label, material );
+    }
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate amr_restrictor components and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label list of variable labels for each component
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material material index
+     * @param patch grid patch
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    amr_restrictor (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = View::use_ghosts_dflt
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+            this->m_view_ptr[i] = new View ( dw, label[i], material, subproblems_label, patch, use_ghosts );
+    }
+
+    /// Destructor
+    virtual ~amr_restrictor()
+    {
+        for ( auto view : this->m_view_ptr )
+            delete view;
+    }
+
+    /// Prevent copy (and move) constructor
+    amr_restrictor ( const amr_restrictor & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_restrictor & operator= ( const amr_restrictor & ) = delete;
+};
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#include <CCA/Components/PhaseField/AMR/detail/amr_restrictor_I0_NC.h>
+#include <CCA/Components/PhaseField/AMR/detail/amr_restrictor_I1_CC.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor_I0_NC.h b/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor_I0_NC.h
new file mode 100644
index 00000000..ee8e3fe3
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor_I0_NC.h
@@ -0,0 +1,398 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_restrictor_I1_CC.h
+ * @author Jon Matteo Church
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_I0_NC_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_I0_NC_h
+
+#include <CCA/Components/PhaseField/AMR/AMRInterface.h>
+#include <CCA/Components/PhaseField/DataTypes/Variable.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_view.h>
+#include <CCA/Components/PhaseField/AMR/detail/amr_finer_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of grid variables for restriction from finer to coarser levels
+ * (node-centered piecewise constant implementation)
+ *
+ * @brief implements  piecewise constant restriction of a variable from finer to
+ *        coarser levels.
+ *
+ * @tparam T variable data type (must be constant)
+ * @tparam Problem type of PhaseField problem
+ * @tparam I list of indices corresponding to the variable within the subproblems
+ *
+ * @implements amr_restrictor< FCI, VAR, DIM, T, Problem, I >
+ */
+template<typename T, typename Problem, size_t... I>
+class amr_restrictor < ScalarField<T>, Problem, index_sequence<I...>, I0, NC >
+    : virtual public view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// restriction type: piecewise constant (I0) or linear-interpolation (I1)
+    static constexpr FCIType FCI = I0;
+
+    /// Problem dimension
+    static constexpr DimType DIM = Problem::Dim;
+
+    /// variable rapresentation type: cell-cenetered (CC) or node-centered (NC)
+    static constexpr VarType VAR = NC;
+
+    /// number of coarse ghosts which corresponds to the coarse region required by restriction
+    static constexpr int E = 0;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Field index
+    using Index = index_sequence<I...>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( Problem::Dim == DIM, "non consistent dimension" );
+    static_assert ( Problem::Var == VAR, "non consistent variable type" );
+    static_assert ( std::is_same< typename Problem::template get_field<I...>::type, ScalarField<T> >::value, "non consistent field types" );
+    static_assert ( std::is_const<T>::value, "amr_restrictor with non const base" );
+
+private: // MEMBERS
+
+    /// inner view to variable on finer level
+    amr_finer_view<Field, Problem, Index> * m_view_fine;
+
+    /// coarser level
+    const Level * m_level_coarse;
+
+    /// finer level
+    const Level * m_level_fine;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get fine value at position
+     *
+     * @param id fine index
+     * @return fine value at id
+     */
+    inline T
+    fine_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & view_fine = *m_view_fine;
+        return view_fine[id];
+    }
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    amr_restrictor (
+        const amr_restrictor * copy,
+        bool deep
+    ) : m_view_fine ( dynamic_cast < amr_finer_view<Field, Problem, Index> * > ( copy->m_view_fine->clone ( deep ) ) ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_level_fine ( copy->m_level_fine ),
+        m_support ( copy->m_support )
+    {}
+
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+
+    /**
+     * @brief construct restrictor without retrieving inner variable data from
+     *        the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     */
+    amr_restrictor (
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material
+    ) : m_view_fine ( scinew amr_finer_view<Field, Problem, Index> ( label, subproblems_label, material ) ),
+        m_level_coarse ( nullptr ),
+        m_level_fine ( nullptr )
+    {
+    }
+
+    /**
+     * @brief construct interpolator and retrieve inner variable data from the
+     *        DataWarehouse whitin a given fine patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    amr_restrictor (
+        DataWarehouse * dw,
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : m_view_fine ( scinew amr_finer_view<Field, Problem, Index> ( dw, label, subproblems_label, material, patch ) ),
+        m_level_coarse ( patch->getLevel() ),
+        m_level_fine ( m_level_coarse->getFinerLevel().get_rep() )
+    {
+        ASSERTMSG ( !use_ghosts, "amr_restrictor doesn't support ghosts" );
+        m_support.splice ( m_support.end(), m_view_fine->get_support() );
+        for ( auto & region : m_support )
+        {
+            region.low() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.low() );
+            region.high() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.high() );
+        }
+    }
+
+    /// Destructor
+    virtual ~amr_restrictor()
+    {
+        delete m_view_fine;
+    };
+
+    /// Prevent copy (and move) constructor
+    amr_restrictor ( const amr_restrictor & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_restrictor & operator= ( const amr_restrictor & ) = delete;
+
+
+public: // VIEW METHODS
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whitin a given
+     *        patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * finer level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        m_support.clear();
+        m_view_fine->set ( dw, patch, use_ghosts );
+        m_level_coarse = patch->getLevel();
+        m_level_fine = m_level_coarse->getFinerLevel().get_rep();
+        m_support.splice ( m_support.end(), m_view_fine->get_support() );
+        for ( auto & region : m_support )
+        {
+            region.low() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.low() );
+            region.high() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.high() );
+        }
+    };
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whitin a given
+     *        region.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * finer level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param level level of the coarse region
+     * @param low start index for the coarse region
+     * @param high past the end index for the coarse region
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        m_support.clear();
+        m_view_fine->set ( dw, level, low, high, use_ghosts );
+        m_level_coarse = level;
+        m_level_fine = m_level_coarse->getFinerLevel().get_rep();
+        m_support.splice ( m_support.end(), m_view_fine->get_support() );
+        for ( auto & region : m_support )
+        {
+            region.low() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.low() );
+            region.high() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.high() );
+        }
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    ) const override
+    {
+        return scinew amr_restrictor ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<amr_restrictor, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief get restrictor's coarse range
+     *
+     * @return coarse range
+     */
+    virtual Support
+    get_support ()
+    const override
+    {
+        Support support ( m_view_fine->get_support() );
+        for ( auto & region : support )
+        {
+            region.low() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.low() );
+            region.high() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.high() );
+        }
+        return support;
+    };
+
+    /**
+     * @brief Check if the view has access to the coarse position with index id
+     *
+     * @param id_coarse coarse position index
+     * @return check result
+     */
+    virtual
+    bool
+    is_defined_at (
+        const IntVector & id_coarse
+    ) const override
+    {
+        IntVector id_fine ( AMRInterface<VAR, DIM>::get_finer ( m_level_coarse, id_coarse ) );
+        return m_view_fine->is_defined_at ( id_fine );
+    };
+
+    /**
+      * @brief Get/Modify value at position with index id (virtual implementation)
+      *
+      * @remark restricted value is computed at runtime thus doesn't exist in the
+      * DataWarehouse
+      *
+      * @param id unused
+      * @return nothing
+      */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief get restricted value
+     *
+     * value at fine index is computed avareging over the corresponding cells the finer level
+     *
+     * @param id_coarse coarse index
+     * @return restricted value at the given fine index
+     */
+    virtual V
+    operator[] (
+        const IntVector & id_coarse
+    ) const override
+    {
+        IntVector id_fine ( AMRInterface<VAR, DIM>::get_finer ( m_level_coarse, id_coarse ) );
+
+        ASSERT ( ( m_level_coarse->getNodePosition ( id_coarse ).asVector() - m_level_coarse->getFinerLevel()->getNodePosition ( id_fine ).asVector() ).length() == 0 );
+
+        return fine_value ( id_fine );
+    }
+
+}; // class amr_restrictor
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_I0_NC_h
diff --git a/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor_I1_CC.h b/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor_I1_CC.h
new file mode 100644
index 00000000..cf508d44
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/detail/amr_restrictor_I1_CC.h
@@ -0,0 +1,395 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/AMR/detail/amr_restrictor_I1_CC.h
+ * @author Jon Matteo Church
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_I1_CC_h
+#define Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_I1_CC_h
+
+#include <CCA/Components/PhaseField/AMR/detail/amr_finer_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of grid variables for restriction from finer to coarser levels
+ * (cell-centered linear implementation)
+ *
+ * implements piecewise constant interpolation of a variable from coarser
+ * to finer levels in 1D
+ *
+ * @tparam T variable data type (must be constant)
+ * @tparam Problem type of PhaseField problem
+ * @tparam I list of indices corresponding to the variable within the subproblems
+ *
+ * @implements amr_restrictor< Field, Problem, Index, FCI, DIM >
+ */
+template<typename T, typename Problem, size_t... I>
+class amr_restrictor < ScalarField<T>, Problem, index_sequence<I...>, I1, CC >
+    : virtual public view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// interpolation type: linear-interpolation (I1)
+    static constexpr FCIType FCI = I1;
+
+    /// Problem variable representation
+    static constexpr DimType DIM = Problem::Dim;
+
+    /// Problem variable representation
+    static constexpr VarType VAR = CC;
+
+    /// number of fine ghosts which corresponds to the coarse region required by interpolation
+    static constexpr int E = 0;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Field index
+    using Index = index_sequence<I...>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( Problem::Var == VAR, "non consistent variable type" );
+    static_assert ( std::is_same< typename Problem::template get_field<I...>::type, ScalarField<T> >::value, "non consistent field types" );
+    static_assert ( std::is_const<T>::value, "amr_restrictor with non const base" );
+
+private: // MEMBERS
+
+    /// inner view to variable on finer level
+    amr_finer_view<Field, Problem, Index> * m_view_fine;
+
+    /// coarser level
+    const Level * m_level_coarse;
+
+    /// finer level
+    const Level * m_level_fine;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get fine value at position
+     *
+     * @param id fine index
+     * @return fine value at id
+     */
+    inline T
+    fine_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & view_fine = *m_view_fine;
+        return view_fine[id];
+    }
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    amr_restrictor (
+        const amr_restrictor * copy,
+        bool deep
+    ) : m_view_fine ( dynamic_cast < amr_finer_view<Field, Problem, Index> * > ( copy->m_view_fine->clone ( deep ) ) ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_level_fine ( copy->m_level_fine ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief construct restrictor without retrieving inner variable data from
+     *        the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     */
+    amr_restrictor (
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material
+    ) : m_view_fine ( scinew amr_finer_view<Field, Problem, Index> ( label, subproblems_label, material ) ),
+        m_level_coarse ( nullptr ),
+        m_level_fine ( nullptr )
+    {
+    }
+
+    /**
+     * @brief construct interpolator and retrieve inner variable data from the
+     *        DataWarehouse whitin a given fine patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * coarser level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    amr_restrictor (
+        DataWarehouse * dw,
+        const VarLabel * label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : m_view_fine ( scinew amr_finer_view<Field, Problem, Index> ( dw, label, subproblems_label, material, patch ) ),
+        m_level_coarse ( patch->getLevel() ),
+        m_level_fine ( m_level_coarse->getFinerLevel().get_rep() )
+    {
+        ASSERTMSG ( !use_ghosts, "amr_restrictor doesn't support ghosts" );
+        m_support.splice ( m_support.end(), m_view_fine->get_support() );
+        for ( auto & region : m_support )
+        {
+            region.low() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.low() );
+            region.high() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.high() );
+        }
+    }
+
+    /// Destructor
+    virtual ~amr_restrictor()
+    {
+        delete m_view_fine;
+    };
+
+    /// Prevent copy (and move) constructor
+    amr_restrictor ( const amr_restrictor & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    amr_restrictor & operator= ( const amr_restrictor & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whitin a given
+     *        patch.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * finer level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param patch patch on which data is retrieved
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        m_support.clear();
+        m_view_fine->set ( dw, patch, use_ghosts );
+        m_level_coarse = patch->getLevel();
+        m_level_fine = m_level_coarse->getFinerLevel().get_rep();
+        m_support.splice ( m_support.end(), m_view_fine->get_support() );
+        for ( auto & region : m_support )
+        {
+            region.low() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.low() );
+            region.high() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.high() );
+        }
+    };
+
+    /**
+     * @brief retrieve inner variable data from the DataWarehouse whitin a given
+     *        region.
+     *
+     * the number of ghost cells/nodes and the corresponding region on the
+     * finer level is automatically computed to match the interpolation type
+     *
+     * @param dw DataWarehouse which data is retrieved from
+     * @param level level of the coarse region
+     * @param low start index for the coarse region
+     * @param high past the end index for the coarse region
+     * @param use_ghosts if ghosts value are to be retrieved (must be false)
+     */
+    virtual void set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = use_ghosts_dflt
+    ) override
+    {
+        ASSERTMSG ( !use_ghosts, "amr_interpolator doesn't support ghosts" );
+        m_support.clear();
+        m_view_fine->set ( dw, level, low, high, use_ghosts );
+        m_level_coarse = level;
+        m_level_fine = m_level_coarse->getFinerLevel().get_rep();
+        m_support.splice ( m_support.end(), m_view_fine->get_support() );
+        for ( auto & region : m_support )
+        {
+            region.low() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.low() );
+            region.high() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.high() );
+        }
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    ) const override
+    {
+        return scinew amr_restrictor ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<amr_restrictor, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief get restrictor's coarse range
+     *
+     * @return coarse range
+     */
+    virtual inline Support
+    get_support ()
+    const override
+    {
+        Support support ( m_view_fine->get_support() );
+        for ( auto & region : support )
+        {
+            region.low() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.low() );
+            region.high() = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, region.high() );
+        }
+        return support;
+    };
+
+    /**
+     * @brief Check if the view has access to the coarse position with index id
+     *
+     * @param id_coarse coarse position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id_coarse
+    ) const override
+    {
+        IntVector id_fine ( AMRInterface<VAR, DIM>::get_finer ( m_level_coarse, id_coarse ) );
+        return m_view_fine->is_defined_at ( id_fine );
+    };
+
+    /**
+      * @brief Get/Modify value at position with index id (virtual implementation)
+      *
+      * @remark restricted value is computed at runtime thus doesn't exist in the
+      * DataWarehouse
+      *
+      * @param id unused
+      * @return nothing
+      */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief get restricted value
+     *
+     * value at fine index is computed avareging over the corresponding cells the finer level
+     *
+     * @param id_coarse coarse index
+     * @return restricted value at the given fine index
+     */
+    virtual V
+    operator[] (
+        const IntVector & id_coarse
+    ) const override
+    {
+        const IntVector l_fine ( AMRInterface<VAR, DIM>::get_finer ( m_level_coarse, id_coarse ) );
+        const IntVector h_fine = l_fine + m_level_coarse->getFinerLevel()->getRefinementRatio(); // TODO check this
+
+        typename std::remove_const<T>::type sum_u ( 0. );
+        double cnt ( 0. );
+        for ( CellIterator it ( l_fine, h_fine ); !it.done(); ++it )
+        {
+            sum_u += fine_value ( *it );
+            cnt += 1.;
+        }
+        return sum_u / cnt;
+    }
+
+}; // class amr_restrictor
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_AMR_detail_amr_restrictor_I1_CC_h
diff --git a/src/CCA/Components/PhaseField/AMR/sub.mk b/src/CCA/Components/PhaseField/AMR/sub.mk
new file mode 100644
index 00000000..2d3ac2b9
--- /dev/null
+++ b/src/CCA/Components/PhaseField/AMR/sub.mk
@@ -0,0 +1,64 @@
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+#
+#
+#
+#
+# Makefile fragment for this subdirectory
+
+SRCDIR := CCA/Components/PhaseField/AMR
+
+SRCS += \
+  $(SRCDIR)/AMRFDViewPureMetalProblemCCP5FC0-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemCCP5FC1-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemCCP5FCSimple-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemCCP5FCLinear-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemCCP7FC0-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemCCP7FC1-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemCCP5FCBilinear-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemNCP5FC0-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemNCP5FC1-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemNCP5FCSimple-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemNCP5FCLinear-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemNCP5FCBilinear-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemNCP7FC0-bld.cc \
+  $(SRCDIR)/AMRFDViewPureMetalProblemNCP7FC1-bld.cc \
+
+BLDDIR := $(SRCTOP)/$(SRCDIR)
+
+BLDSRCS += \
+  $(BLDDIR)/AMRFDViewPureMetalProblemCCP5FC0-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemCCP5FC1-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemCCP5FCSimple-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemCCP5FCLinear-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemCCP7FC0-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemCCP7FC1-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemCCP5FCBilinear-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemNCP5FC0-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemNCP5FC1-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemNCP5FCSimple-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemNCP5FCLinear-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemNCP5FCBilinear-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemNCP7FC0-bld.cc \
+  $(BLDDIR)/AMRFDViewPureMetalProblemNCP7FC1-bld.cc \
diff --git a/src/CCA/Components/PhaseField/AMRPhaseField.h b/src/CCA/Components/PhaseField/AMRPhaseField.h
deleted file mode 100644
index ee1664fb..00000000
--- a/src/CCA/Components/PhaseField/AMRPhaseField.h
+++ /dev/null
@@ -1,840 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_PhaseField_AMRPhaseField_h
-#define Packages_Uintah_CCA_Components_PhaseField_AMRPhaseField_h
-
-#include <Core/Grid/Variables/PerPatch.h>
-#include <CCA/Components/PhaseField/PhaseField.h>
-#include <Core/Grid/Variables/PerPatchVars.h>
-#include <CCA/Ports/Regridder.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-namespace Uintah
-{
-
-namespace PF
-{
-
-using FlagVariable = CCVariable<int>;
-
-#ifdef UINTAH_ENABLE_KOKKOS
-using FlagView = KokkosView3<int>;
-#else
-using FlagView = FlagVariable & ;
-#endif
-
-template<VariableType VariableType>
-IntVector map_to_coarser ( Level const * /*level*/, IntVector const & /*i*/ )
-{
-    static_assert ( static_false<VariableType>::value, "map_to_coarser<VariableType> not implemented" );
-    return { 0, 0, 0 };
-}
-
-template<>
-IntVector map_to_coarser<CellCentered> ( Level const * level, IntVector const & i )
-{
-    return level->mapCellToCoarser ( i );
-}
-
-template<>
-IntVector map_to_coarser<NodeCentered> ( Level const * level, IntVector const & i )
-{
-    return level->mapNodeToCoarser ( i );
-}
-
-template<VariableType VariableType>
-IntVector map_to_finer ( Level const * level, IntVector const & i )
-{
-    static_assert ( static_false<VariableType>::value, "map_to_finer<VariableType> not implemented" );
-    return { 0, 0, 0 };
-}
-
-template<>
-IntVector map_to_finer<CellCentered> ( Level const * level, IntVector const & i )
-{
-    return level->mapCellToFiner ( i );
-}
-
-template<>
-IntVector map_to_finer<NodeCentered> ( Level const * level, IntVector const & i )
-{
-    return level->mapNodeToFiner ( i );
-}
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-void refine ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstView<VariableType> psi_coarse, ConstView<VariableType> u_coarse, View<VariableType> psi_fine, View<VariableType> u_fine )
-{
-    static_assert ( static_false<VariableType>::value, "refine<VariableType, NumGhosts, Dimension> not implemented" );
-};
-
-template<>
-void refine<CellCentered, 1, 2> ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstView<CellCentered> psi_coarse, ConstView<CellCentered> u_coarse, View<CellCentered> psi_fine, View<CellCentered> u_fine )
-{
-    IntVector cell_fine ( i_fine, j_fine, k_fine );
-    IntVector cell_coarse ( level_fine->mapCellToCoarser ( cell_fine ) );
-
-    psi_fine[cell_fine] = psi_coarse[cell_coarse];
-    u_fine[cell_fine] = u_coarse[cell_coarse];
-};
-
-template<>
-void refine<CellCentered, 1, 3> ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstView<CellCentered> psi_coarse, ConstView<CellCentered> u_coarse, View<CellCentered> psi_fine, View<CellCentered> u_fine )
-{
-    IntVector cell_fine ( i_fine, j_fine, k_fine );
-    IntVector cell_coarse ( level_fine->mapCellToCoarser ( cell_fine ) );
-
-    psi_fine[cell_fine] = psi_coarse[cell_coarse];
-    u_fine[cell_fine] = u_coarse[cell_coarse];
-};
-
-template<>
-void refine<NodeCentered, 1, 2> ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstView<NodeCentered> psi_coarse, ConstView<NodeCentered> u_coarse, View<NodeCentered> psi_fine, View<NodeCentered> u_fine )
-{
-    IntVector node_fine ( i_fine, j_fine, k_fine );
-    IntVector node_coarse ( level_fine->mapNodeToCoarser ( node_fine ) );
-    Point point_fine ( level_fine->getNodePosition ( node_fine ) );
-    Point point_coarse ( level_coarse->getNodePosition ( node_coarse ) );
-    Vector dist = ( point_fine.asVector() - point_coarse.asVector() ) / level_coarse->dCell();
-    double w00 ( 1 ), w10 ( 1 ), w01 ( 1 ), w11 ( 1 );
-    IntVector n00 ( node_coarse ), n01 ( node_coarse ), n10 ( node_coarse ), n11 ( node_coarse );
-    if ( dist.x() < 0. ) {
-        n00[0] = n01[0] -= 1;
-        w00 *= -dist.x();
-        w01 *= -dist.x();
-        w10 *= ( 1 + dist.x() );
-        w11 *= ( 1 + dist.x() );
-    } else if ( dist.x() > 0. ) {
-        n10[0] = n11[0] += 1;
-        w00 *= ( 1 - dist.x() );
-        w01 *= ( 1 - dist.x() );
-        w10 *= dist.x();
-        w11 *= dist.x();
-    } else {
-        w10 *= 0.;
-        w11 *= 0.;
-    }
-
-    if ( dist.y() < 0. ) {
-        n00[1] = n10[1] -= 1;
-        w00 *= -dist.y();
-        w10 *= -dist.y();
-        w01 *= ( 1 + dist.y() );
-        w11 *= ( 1 + dist.y() );
-    } else if ( dist.y() > 0. ) {
-        n01[1] = n11[1] += 1;
-        w00 *= ( 1 - dist.y() );
-        w10 *= ( 1 - dist.y() );
-        w01 *= dist.y();
-        w11 *= dist.y();
-    } else {
-        w01 *= 0.;
-        w11 *= 0.;
-    }
-
-    psi_fine[node_fine] = w00 * psi_coarse[n00] +
-                          w01 * psi_coarse[n01] +
-                          w10 * psi_coarse[n10] +
-                          w11 * psi_coarse[n11];
-    u_fine[node_fine] = w00 * u_coarse[n00] +
-                        w01 * u_coarse[n01] +
-                        w10 * u_coarse[n10] +
-                        w11 * u_coarse[n11];
-};
-
-template<>
-void refine<NodeCentered, 1, 3> ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstView<NodeCentered> psi_coarse, ConstView<NodeCentered> u_coarse, View<NodeCentered> psi_fine, View<NodeCentered> u_fine )
-{
-    IntVector node_fine ( i_fine, j_fine, k_fine );
-    IntVector node_coarse ( level_fine->mapNodeToCoarser ( node_fine ) );
-    Point point_fine ( level_fine->getNodePosition ( node_fine ) );
-    Point point_coarse ( level_coarse->getNodePosition ( node_coarse ) );
-    Vector dist = ( point_fine.asVector() - point_coarse.asVector() ) / level_coarse->dCell();
-    double w000 ( 1 ), w100 ( 1 ), w010 ( 1 ), w110 ( 1 ), w001 ( 1 ), w101 ( 1 ), w011 ( 1 ), w111 ( 1 );
-    IntVector n000 ( node_coarse ), n010 ( node_coarse ), n100 ( node_coarse ), n110 ( node_coarse ), n001 ( node_coarse ), n011 ( node_coarse ), n101 ( node_coarse ), n111 ( node_coarse );
-    if ( dist.x() < 0. ) {
-        n000[0] = n001[0] = n010[0] = n011[0] -= 1;
-        w000 *= -dist.x();
-        w001 *= -dist.x();
-        w010 *= -dist.x();
-        w011 *= -dist.x();
-        w100 *= ( 1 + dist.x() );
-        w101 *= ( 1 + dist.x() );
-        w110 *= ( 1 + dist.x() );
-        w111 *= ( 1 + dist.x() );
-    } else if ( dist.x() > 0. ) {
-        n100[0] = n101[0] = n110[0] = n111[0] += 1;
-        w000 *= ( 1 - dist.x() );
-        w001 *= ( 1 - dist.x() );
-        w010 *= ( 1 - dist.x() );
-        w011 *= ( 1 - dist.x() );
-        w100 *= dist.x();
-        w101 *= dist.x();
-        w110 *= dist.x();
-        w111 *= dist.x();
-    } else {
-        w100 = 0.;
-        w101 = 0.;
-        w110 = 0.;
-        w111 = 0.;
-    }
-
-    if ( dist.y() < 0. ) {
-        n000[1] = n100[1] = n001[1] = n101[1] -= 1;
-        w000 *= -dist.y();
-        w001 *= -dist.y();
-        w100 *= -dist.y();
-        w101 *= -dist.y();
-        w010 *= ( 1 + dist.y() );
-        w011 *= ( 1 + dist.y() );
-        w110 *= ( 1 + dist.y() );
-        w111 *= ( 1 + dist.y() );
-    } else if ( dist.y() > 0. ) {
-        n010[1] = n110[1] = n011[1] = n111[1] += 1;
-        w000 *= ( 1 - dist.y() );
-        w001 *= ( 1 - dist.y() );
-        w100 *= ( 1 - dist.y() );
-        w101 *= ( 1 - dist.y() );
-        w010 *= dist.y();
-        w011 *= dist.y();
-        w110 *= dist.y();
-        w111 *= dist.y();
-    } else {
-        w010 = 0.;
-        w011 = 0.;
-        w110 = 0.;
-        w111 = 0.;
-    }
-
-    if ( dist.z() < 0. ) {
-        n000[2] = n010[2] = n100[2] = n110[2] -= 1;
-        w000 *= -dist.z();
-        w010 *= -dist.z();
-        w100 *= -dist.z();
-        w110 *= -dist.z();
-        w001 *= ( 1 + dist.z() );
-        w011 *= ( 1 + dist.z() );
-        w101 *= ( 1 + dist.z() );
-        w111 *= ( 1 + dist.z() );
-    } else if ( dist.z() > 0. ) {
-        n001[2] = n011[2] = n101[2] = n111[2] += 1;
-        w000 *= ( 1 - dist.z() );
-        w010 *= ( 1 - dist.z() );
-        w100 *= ( 1 - dist.z() );
-        w110 *= ( 1 - dist.z() );
-        w001 *= dist.z();
-        w011 *= dist.z();
-        w101 *= dist.z();
-        w111 *= dist.z();
-    } else {
-        w001 = 0.;
-        w011 = 0.;
-        w101 = 0.;
-        w111 = 0.;
-    }
-    psi_fine[node_fine] = w000 * psi_coarse[n000] +
-                          w001 * psi_coarse[n001] +
-                          w010 * psi_coarse[n010] +
-                          w011 * psi_coarse[n011] +
-                          w100 * psi_coarse[n100] +
-                          w101 * psi_coarse[n101] +
-                          w110 * psi_coarse[n110] +
-                          w111 * psi_coarse[n111];
-
-    u_fine[node_fine] = w000 * u_coarse[n000] +
-                        w001 * u_coarse[n001] +
-                        w010 * u_coarse[n010] +
-                        w011 * u_coarse[n011] +
-                        w100 * u_coarse[n100] +
-                        w101 * u_coarse[n101] +
-                        w110 * u_coarse[n110] +
-                        w111 * u_coarse[n111];
-};
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-void coarsen ( int i_fine, int j_fine, int k_fine, Level const * level_fine, Level const * level_coarse, ConstView<VariableType> psi_coarse, ConstView<VariableType> u_coarse, View<VariableType> psi_fine, View<VariableType> u_fine )
-{
-    static_assert ( static_false<VariableType>::value, "coarsen<VariableType, NumGhosts, Dimension> not implemented" );
-};
-
-template<>
-void coarsen<CellCentered, 1, 2> ( int i_coarse, int j_coarse, int k_coarse, Level const * level_coarse, Level const * level_fine, ConstView<CellCentered> psi_fine, ConstView<CellCentered> u_fine, View<CellCentered> psi_coarse, View<CellCentered> u_coarse )
-{
-    IntVector l_coarse ( i_coarse, j_coarse, k_coarse ); // bottom-left-lower corner
-    IntVector h_coarse = l_coarse + IntVector ( 1, 1, 1 );
-    IntVector l_fine ( level_coarse->mapNodeToFiner ( l_coarse ) );
-    IntVector h_fine = l_fine + level_fine->getRefinementRatio(); // TODO check this
-
-    double sum_psi ( 0. ), sum_u ( 0. ), cnt ( 0. );
-    for ( CellIterator it ( l_fine, h_fine ); !it.done(); ++it ) {
-        sum_psi += psi_fine[*it];
-        sum_u += u_fine[*it];
-        cnt += 1.;
-    }
-    psi_coarse ( i_coarse, j_coarse, k_coarse ) = sum_psi / cnt;
-    u_coarse ( i_coarse, j_coarse, k_coarse ) = sum_u / cnt;
-};
-
-template<>
-void coarsen<CellCentered, 1, 3> ( int i_coarse, int j_coarse, int k_coarse, Level const * level_coarse, Level const * level_fine, ConstView<CellCentered> psi_fine, ConstView<CellCentered> u_fine, View<CellCentered> psi_coarse, View<CellCentered> u_coarse )
-{
-    IntVector l_coarse ( i_coarse, j_coarse, k_coarse ); // bottom-left-lower corner
-    IntVector h_coarse = l_coarse + IntVector ( 1, 1, 1 );
-    IntVector l_fine ( level_coarse->mapNodeToFiner ( l_coarse ) );
-    IntVector h_fine = l_fine + level_fine->getRefinementRatio(); // TODO check this
-
-    double sum_psi ( 0. ), sum_u ( 0. ), cnt ( 0. );
-    for ( CellIterator it ( l_fine, h_fine ); !it.done(); ++it ) {
-        sum_psi += psi_fine[*it];
-        sum_u += u_fine[*it];
-        cnt += 1.;
-    }
-    psi_coarse ( i_coarse, j_coarse, k_coarse ) = sum_psi / cnt;
-    u_coarse ( i_coarse, j_coarse, k_coarse ) = sum_u / cnt;
-};
-
-template<>
-void coarsen<NodeCentered, 1, 2> ( int i_coarse, int j_coarse, int k_coarse, Level const * level_coarse, Level const * level_fine, ConstView<NodeCentered> psi_fine, ConstView<NodeCentered> u_fine, View<NodeCentered> psi_coarse, View<NodeCentered> u_coarse )
-{
-    IntVector node_coarse ( i_coarse, j_coarse, k_coarse );
-    IntVector node_fine ( level_coarse->mapNodeToFiner ( node_coarse ) );
-
-    Point point_coarse ( level_coarse->getNodePosition ( node_coarse ) );
-    Point point_fine ( level_fine->getNodePosition ( node_fine ) );
-
-    assert ( ( point_fine.asVector() - point_coarse.asVector() ).length() == 0 );
-
-    psi_coarse[node_coarse] = psi_fine[node_fine];
-    u_coarse[node_coarse] = u_fine[node_fine];
-};
-
-template<>
-void coarsen<NodeCentered, 1, 3> ( int i_coarse, int j_coarse, int k_coarse, Level const * level_coarse, Level const * level_fine, ConstView<NodeCentered> psi_fine, ConstView<NodeCentered> u_fine, View<NodeCentered> psi_coarse, View<NodeCentered> u_coarse )
-{
-    IntVector node_coarse ( i_coarse, j_coarse, k_coarse );
-    IntVector node_fine ( level_coarse->mapNodeToFiner ( node_coarse ) );
-
-    Point point_coarse ( level_coarse->getNodePosition ( node_coarse ) );
-    Point point_fine ( level_fine->getNodePosition ( node_fine ) );
-
-    assert ( ( point_fine.asVector() - point_coarse.asVector() ).length() == 0 );
-
-    psi_coarse[node_coarse] = psi_fine[node_fine];
-    u_coarse[node_coarse] = u_fine[node_fine];
-};
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-void error_estimate ( int i_fine, int j_fine, int k_fine, Patch const * patch, ConstView<VariableType> psi, FlagView flag_refine, bool & refine_patch, double const & refine_threshold )
-{
-    static_assert ( static_false<VariableType>::value, "error_estimate<VariableType, NumGhosts, Dimension> not implemented" );
-};
-
-template<>
-void error_estimate<CellCentered, 1, 2> ( int i, int j, int k, Patch const * patch, ConstView<CellCentered> psi, FlagView flag_refine, bool & refine_patch, double const & refine_threshold )
-{
-    IntVector l ( psi.getLowIndex() ), h ( psi.getHighIndex() );
-    Vector d ( patch->dCell() );
-
-    int im = ( i > l.x() ) ? i - 1 : i, ip = ( i < h.x() - 1 ) ? i + 1 : i;
-    int jm = ( j > l.y() ) ? j - 1 : j, jp = ( j < h.y() - 1 ) ? j + 1 : j;
-    double psi_x = ( psi ( ip, j, k ) - psi ( im, j, k ) ) / ( d.x() * ( ip - im ) );
-    double psi_y = ( psi ( i, jp, k ) - psi ( i, jm, k ) ) / ( d.y() * ( jp - jm ) );
-    double grad_psi_norm2 = psi_x * psi_x + psi_y * psi_y;
-
-    bool tmp = grad_psi_norm2 > refine_threshold;
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-template<>
-void error_estimate<CellCentered, 1, 3> ( int i, int j, int k, Patch const * patch, ConstView<CellCentered> psi, FlagView flag_refine, bool & refine_patch, double const & refine_threshold )
-{
-    IntVector l ( psi.getLowIndex() ), h ( psi.getHighIndex() );
-    Vector d ( patch->dCell() );
-
-    int im = ( i > l.x() ) ? i - 1 : i, ip = ( i < h.x() - 1 ) ? i + 1 : i;
-    int jm = ( j > l.y() ) ? j - 1 : j, jp = ( j < h.y() - 1 ) ? j + 1 : j;
-    int km = ( k > l.z() ) ? k - 1 : k, kp = ( k < h.z() - 1 ) ? k + 1 : k;
-    double psi_x = ( psi ( ip, j, k ) - psi ( im, j, k ) ) / ( d.x() * ( ip - im ) );
-    double psi_y = ( psi ( i, jp, k ) - psi ( i, jm, k ) ) / ( d.y() * ( jp - jm ) );
-    double psi_z = ( psi ( i, j, kp ) - psi ( i, j, km ) ) / ( d.z() * ( kp - km ) );
-    double grad_psi_norm2 = psi_x * psi_x + psi_y * psi_y + psi_z * psi_z;
-
-    bool tmp = grad_psi_norm2 > refine_threshold;
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-template<>
-void error_estimate<NodeCentered, 1, 2> ( int i, int j, int k, Patch const * patch, ConstView<NodeCentered> psi, FlagView flag_refine, bool & refine_patch, double const & refine_threshold )
-{
-    Vector d ( patch->dCell() );
-
-    double psi_x_0 = ( psi ( i + 1, j,     k ) - psi ( i,     j,     k ) ) / d.x();
-    double psi_y_0 = ( psi ( i,     j + 1, k ) - psi ( i,     j,     k ) ) / d.x();
-    double grad_psi_00 = psi_x_0 * psi_x_0 + psi_y_0 * psi_y_0;
-    double psi_x_1 = ( psi ( i + 1, j + 1, k ) - psi ( i,     j + 1, k ) ) / d.x();
-    double psi_y_1 = ( psi ( i + 1, j + 1, k ) - psi ( i + 1, j,     k + 1 ) ) / d.x();
-    double grad_psi_11 = psi_x_1 * psi_x_1 + psi_y_1 * psi_y_1;
-
-    bool tmp = grad_psi_00 > refine_threshold ||
-               grad_psi_11 > refine_threshold;
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-template<>
-void error_estimate<NodeCentered, 1, 3> ( int i, int j, int k, Patch const * patch, ConstView<NodeCentered> psi, FlagView flag_refine, bool & refine_patch, double const & refine_threshold )
-{
-    Vector d ( patch->dCell() );
-
-    double psi_x_00 = ( psi ( i + 1, j,   k ) - psi ( i,   j,   k ) ) / d.x();
-    double psi_y_00 = ( psi ( i,   j + 1, k ) - psi ( i,   j,   k ) ) / d.x();
-    double psi_z_00 = ( psi ( i,   j,   k + 1 ) - psi ( i,   j,   k ) ) / d.x();
-    double grad_psi_000 = psi_x_00 * psi_x_00 + psi_y_00 * psi_y_00 + psi_z_00 * psi_z_00;
-    double psi_x_10 = ( psi ( i + 1, j + 1, k ) - psi ( i,   j + 1, k ) ) / d.x();
-    double psi_y_10 = ( psi ( i + 1, j + 1, k ) - psi ( i + 1, j,   k ) ) / d.x();
-    double psi_z_11 = ( psi ( i + 1, j + 1, k + 1 ) - psi ( i + 1, j + 1, k ) ) / d.x();
-    double grad_psi_110 = psi_x_10 * psi_x_10 + psi_y_10 * psi_y_10 + psi_z_11 * psi_z_11;
-    double psi_x_01 = ( psi ( i + 1, j,   k + 1 ) - psi ( i,   j, k + 1 ) ) / d.x();
-    double psi_y_11 = ( psi ( i + 1, j + 1, k + 1 ) - psi ( i + 1, j, k + 1 ) ) / d.x();
-    double psi_z_10 = ( psi ( i + 1, j,   k + 1 ) - psi ( i + 1, j, k ) ) / d.x();
-    double grad_psi_101 = psi_x_01 * psi_x_01 + psi_y_11 * psi_y_11 + psi_z_10 * psi_z_10;
-    double psi_x_11 = ( psi ( i + 1, j + 1, k + 1 ) - psi ( i, j + 1, k + 1 ) ) / d.x();
-    double psi_y_01 = ( psi ( i,   j + 1, k + 1 ) - psi ( i, j  , k + 1 ) ) / d.x();
-    double psi_z_01 = ( psi ( i,   j + 1, k + 1 ) - psi ( i, j + 1, k ) ) / d.x();
-    double grad_psi_011 = psi_x_11 * psi_x_11 + psi_y_01 * psi_y_01 + psi_z_01 * psi_z_01;
-
-    bool tmp = grad_psi_000 > refine_threshold ||
-               grad_psi_110 > refine_threshold ||
-               grad_psi_101 > refine_threshold ||
-               grad_psi_011 > refine_threshold;
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-template<int Dimension>
-void error_estimate_test ( int i, int j, int k, Patch const * patch, FlagView flag_refine, bool & refine_patch )
-{
-    bool tmp = true;
-    IntVector l, h;
-    patch->getLevel()->findCellIndexRange ( l, h );
-    if ( Dimension == 2 )
-        tmp = ( h.x() + 3 * l.x() < 4 * i && 4 * i < l.x() + 3 * h.x() ) &&
-              ( h.y() + 3 * l.y() < 4 * j && 4 * j < l.y() + 3 * h.y() );
-    if ( Dimension == 3 )
-        tmp = ( h.x() + 3 * l.x() < 4 * i && 4 * i < l.x() + 3 * h.x() ) &&
-              ( h.y() + 3 * l.y() < 4 * j && 4 * j < l.y() + 3 * h.y() ) &&
-              ( h.z() + 3 * l.z() < 4 * k && 4 * k < l.z() + 3 * h.z() );
-    flag_refine ( i, j, k ) = tmp;
-    refine_patch |= tmp;
-}
-
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-class AMRPhaseField : public PhaseField<VariableType, NumGhosts, Dimension>
-{
-protected:
-    using Variable = PF::Variable<VariableType>;
-    using ConstVariable = PF::ConstVariable<VariableType>;
-    using FlagVariable = PF::FlagVariable;
-    using FlagView = PF::FlagView;
-
-    using PhaseField<VariableType, NumGhosts, Dimension>::get_view;
-
-    using PhaseField<VariableType, NumGhosts, Dimension>::get_low;
-    using PhaseField<VariableType, NumGhosts, Dimension>::get_high;
-
-    template <typename... Args>
-    static BlockRange get_flag_inner_range ( Args && ... args )
-    {
-        return PF::get_inner_range<PF::CellCentered, NumGhosts, Dimension> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static IntVector map_to_coarser ( Args && ... args )
-    {
-        return PF::map_to_coarser<VariableType> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static IntVector map_to_finer ( Args && ... args )
-    {
-        return PF::map_to_finer<VariableType> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static void refine ( Args && ... args )
-    {
-        return PF::refine<VariableType, NumGhosts, Dimension> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static void coarsen ( Args && ... args )
-    {
-        return PF::coarsen<VariableType, NumGhosts, Dimension> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    void error_estimate ( Args && ... args )
-    {
-        return PF::error_estimate<VariableType, NumGhosts, Dimension> ( std::forward<Args> ( args )... );
-    }
-
-    using PhaseField<VariableType, NumGhosts, Dimension>::psi_label;
-    using PhaseField<VariableType, NumGhosts, Dimension>::u_label;
-    using PhaseField<VariableType, NumGhosts, Dimension>::m_materialManager;
-    using PhaseField<VariableType, NumGhosts, Dimension>::m_regridder;
-    using PhaseField<VariableType, NumGhosts, Dimension>::dbg_out1;
-    using PhaseField<VariableType, NumGhosts, Dimension>::dbg_out2;
-    using PhaseField<VariableType, NumGhosts, Dimension>::dbg_out3;
-    using PhaseField<VariableType, NumGhosts, Dimension>::dbg_out4;
-    using PhaseField<VariableType, NumGhosts, Dimension>::GhostType;
-
-#ifdef UINTAH_ENABLE_KOKKOS
-    FlagView get_view ( FlagVariable & var )
-    {
-        return var.getKokkosView();
-    }
-#else
-    FlagView get_view ( FlagVariable & var )
-    {
-        return var;
-    }
-#endif
-
-protected:
-    double refine_threshold;
-
-public:
-    AMRPhaseField ( const ProcessorGroup * myworld,
-		    const MaterialManagerP materialManager,
-		    int verbosity = 0 );
-  
-    virtual ~AMRPhaseField ();
-
-protected:
-    AMRPhaseField ( AMRPhaseField const & ) = delete;
-    AMRPhaseField & operator= ( AMRPhaseField const & ) = delete;
-
-public:
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleRefine ( PatchSet const * patches, SchedulerP & sched ) override;
-    virtual void scheduleRefineInterface ( LevelP const & level_fine, SchedulerP & sched, bool need_old_coarse, bool need_new_coarse )
-    {
-        /*TODO*/
-    };
-    virtual void scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-    virtual void scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched ) override;
-
-protected:
-    void task_refine ( ProcessorGroup const * myworld, PatchSubset const * patches_fine, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_coarsen ( ProcessorGroup const * myworld, PatchSubset const * patches_coarse, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    virtual void task_error_estimate ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-};
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-class AMRPhaseFieldTest : public AMRPhaseField<VariableType, NumGhosts, Dimension>
-{
-    using Variable = PF::Variable<VariableType>;
-    using ConstVariable = PF::ConstVariable<VariableType>;
-    using FlagVariable = PF::FlagVariable;
-    using FlagView = PF::FlagView;
-    using PhaseField<VariableType, NumGhosts, Dimension>::psi_label;
-    using PhaseField<VariableType, NumGhosts, Dimension>::u_label;
-    using PhaseField<VariableType, NumGhosts, Dimension>::m_materialManager;
-    using PhaseField<VariableType, NumGhosts, Dimension>::m_regridder;
-    using PhaseField<VariableType, NumGhosts, Dimension>::dbg_out1;
-    using PhaseField<VariableType, NumGhosts, Dimension>::dbg_out2;
-    using PhaseField<VariableType, NumGhosts, Dimension>::dbg_out3;
-    using PhaseField<VariableType, NumGhosts, Dimension>::dbg_out4;
-    using PhaseField<VariableType, NumGhosts, Dimension>::get_view;
-    using AMRPhaseField<VariableType, NumGhosts, Dimension>::get_view;
-    using AMRPhaseField<VariableType, NumGhosts, Dimension>::get_flag_inner_range;
-    using AMRPhaseField<VariableType, NumGhosts, Dimension>::AMRPhaseField;
-    template <typename... Args>
-    void error_estimate_test ( Args && ... args )
-    {
-        return PF::error_estimate_test<Dimension> ( std::forward<Args> ( args )... );
-    }
-    virtual void task_error_estimate ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new ) override;
-};
-
-extern template class AMRPhaseField <PF::CellCentered, 1, 2>;
-extern template class AMRPhaseField <PF::NodeCentered, 1, 2>;
-extern template class AMRPhaseField <PF::CellCentered, 1, 3>;
-extern template class AMRPhaseField <PF::NodeCentered, 1, 3>;
-extern template class AMRPhaseFieldTest <PF::CellCentered, 1, 2>;
-extern template class AMRPhaseFieldTest <PF::NodeCentered, 1, 2>;
-extern template class AMRPhaseFieldTest <PF::CellCentered, 1, 3>;
-extern template class AMRPhaseFieldTest <PF::NodeCentered, 1, 3>;
-
-using AMRCCPhaseField2D = AMRPhaseField <PF::CellCentered, 1, 2>;
-using AMRNCPhaseField2D = AMRPhaseField <PF::NodeCentered, 1, 2>;
-using AMRCCPhaseField3D = AMRPhaseField <PF::CellCentered, 1, 3>;
-using AMRNCPhaseField3D = AMRPhaseField <PF::NodeCentered, 1, 3>;
-
-using AMRCCPhaseField2DTest = AMRPhaseFieldTest <PF::CellCentered, 1, 2>;
-using AMRNCPhaseField2DTest = AMRPhaseFieldTest <PF::NodeCentered, 1, 2>;
-using AMRCCPhaseField3DTest = AMRPhaseFieldTest <PF::CellCentered, 1, 3>;
-using AMRNCPhaseField3DTest = AMRPhaseFieldTest <PF::NodeCentered, 1, 3>;
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-AMRPhaseField<VariableType, NumGhosts, Dimension>::AMRPhaseField ( const ProcessorGroup * myworld, const MaterialManagerP materialManager, int verbosity )
-  : PhaseField<VariableType, NumGhosts, Dimension> ( myworld, materialManager, verbosity )
-{}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-AMRPhaseField<VariableType, NumGhosts, Dimension>::~AMRPhaseField ()
-{}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void AMRPhaseField<VariableType, NumGhosts, Dimension>::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid )
-{
-    PhaseField<VariableType, NumGhosts, Dimension>::problemSetup ( params, restart_prob_spec, grid );
-
-    ProblemSpecP diffusion = params->findBlock ( "PhaseField" );
-    diffusion->require ( "refine_threshold", refine_threshold );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void AMRPhaseField<VariableType, NumGhosts, Dimension>::scheduleRefine ( PatchSet const * patches, SchedulerP & sched )
-{
-    if ( getLevel ( patches )->getIndex() == 0 ) {
-        return;
-    }
-
-    Task * task = scinew Task ( "AMRPhaseField::task_refine", this, &AMRPhaseField::task_refine );
-    if ( VariableType == PF::CellCentered ) {
-        task->requires ( Task::NewDW, psi_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-        task->requires ( Task::NewDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-    } else {
-        task->requires ( Task::NewDW, psi_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::AroundNodes, 1 );
-        task->requires ( Task::NewDW, u_label, 0, Task::CoarseLevel, 0, Task::NormalDomain, Ghost::AroundNodes, 1 );
-    }
-    task->computes ( psi_label );
-    task->computes ( u_label );
-    sched->addTask ( task, patches, m_materialManager->allMaterials() );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void AMRPhaseField<VariableType, NumGhosts, Dimension>::scheduleCoarsen ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRPhaseField::task_coarsen", this, &AMRPhaseField::task_coarsen );
-    task->requires ( Task::NewDW, psi_label, 0, Task::FineLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-    task->requires ( Task::NewDW, u_label, 0, Task::FineLevel, 0, Task::NormalDomain, Ghost::None, 0 );
-    task->modifies ( psi_label );
-    task->modifies ( u_label );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void AMRPhaseField<VariableType, NumGhosts, Dimension>::scheduleErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "AMRPhaseField::task_error_estimate", this, &AMRPhaseField::task_error_estimate );
-    task->requires ( Task::NewDW, psi_label, Ghost::Ghost::None, 0 ); // this is actually the old value of this
-    task->modifies ( m_regridder->getRefineFlagLabel(), m_regridder->refineFlagMaterials() );
-    task->modifies ( m_regridder->getRefinePatchFlagLabel(), m_regridder->refineFlagMaterials() );
-    sched->addTask ( task, level_coarse->eachPatch(), m_materialManager->allMaterials() );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void AMRPhaseField<VariableType, NumGhosts, Dimension>::scheduleInitialErrorEstimate ( LevelP const & level_coarse, SchedulerP & sched )
-{
-    scheduleErrorEstimate ( level_coarse, sched );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void AMRPhaseField<VariableType, NumGhosts, Dimension>::task_refine ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches_fine, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRPhaseField::task_refine ====" << std::endl;
-
-    const Level * level_fine = getLevel ( patches_fine );
-    const Level * level_coarse = level_fine->getCoarserLevel().get_rep();
-
-    for ( int p = 0; p < patches_fine->size(); ++p ) {
-        const Patch * patch_fine = patches_fine->get ( p );
-        dbg_out2 << "== Fine Patch: " << *patch_fine << std::endl;
-
-        Variable psi_fine, u_fine;
-        dw_new->allocateAndPut ( psi_fine, psi_label, 0, patch_fine );
-        dw_new->allocateAndPut ( u_fine, u_label, 0, patch_fine );
-        dbg_out4 << "psi_fine \t window " << psi_fine.getLowIndex() << psi_fine.getHighIndex() << std::endl;
-        dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-        IntVector l_fine = get_low ( patch_fine );
-        IntVector h_fine = get_high ( patch_fine );
-
-        IntVector l_coarse = map_to_coarser ( level_fine, l_fine );
-        IntVector h_coarse = map_to_coarser ( level_fine, h_fine );
-        if ( VariableType == PF::NodeCentered ) { // Extening in order to select nodes on right edges
-            h_coarse += IntVector ( 1, 1, Dimension == 3 ? 1 : 0 );
-        }
-
-        dbg_out4 << "fine range" << BlockRange ( l_fine, h_fine ) << std::endl;
-        dbg_out4 << "coarse range" << BlockRange ( l_coarse, h_coarse ) << std::endl;
-
-        ConstVariable psi_coarse, u_coarse;
-        dw_new->getRegion ( psi_coarse, psi_label, 0, level_coarse, l_coarse, h_coarse );
-        dw_new->getRegion ( u_coarse, u_label, 0, level_coarse, l_coarse, h_coarse );
-        dbg_out4 << "psi_coarse \t window " << psi_coarse.getLowIndex() << psi_coarse.getHighIndex() << std::endl;
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        BlockRange range_fine ( l_fine, h_fine );
-        dbg_out3 << "= Iterating over fine range" << range_fine << std::endl;
-        parallel_for ( range_fine, [level_fine, level_coarse, &psi_coarse, &u_coarse, &psi_fine, &u_fine, this] ( int i, int j, int k )->void { refine ( i, j, k, level_fine, level_coarse, get_view ( psi_coarse ), get_view ( u_coarse ), get_view ( psi_fine ), get_view ( u_fine ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void
-AMRPhaseField<VariableType, NumGhosts, Dimension>::task_coarsen ( ProcessorGroup const * /*myworld*/, const PatchSubset * patches_coarse, const MaterialSubset * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRPhaseField::task_coarsen " << std::endl;
-
-    const Level * level_coarse = getLevel ( patches_coarse );
-    const Level * level_fine = level_coarse->getFinerLevel().get_rep();
-
-    for ( int p = 0; p < patches_coarse->size(); ++p ) {
-        const Patch * patch_coarse = patches_coarse->get ( p );
-        dbg_out2 << "== Coarse Patch: " << *patch_coarse << std::endl;
-
-        Variable psi_coarse, u_coarse;
-        dw_new->getModifiable ( psi_coarse, psi_label, 0, patch_coarse );
-        dw_new->getModifiable ( u_coarse, u_label, 0, patch_coarse );
-        dbg_out4 << "psi_coarse \t window " << psi_coarse.getLowIndex() << psi_coarse.getHighIndex() << std::endl;
-        dbg_out4 << "u_coarse \t window " << u_coarse.getLowIndex() << u_coarse.getHighIndex() << std::endl;
-
-        IntVector l_coarse = get_low ( patch_coarse );
-        IntVector h_coarse = get_high ( patch_coarse );
-
-        IntVector l_fine = map_to_finer ( level_coarse, l_coarse );
-        IntVector h_fine = map_to_finer ( level_coarse, h_coarse );
-
-        Level::selectType patches_fine;
-        level_fine->selectPatches ( l_fine, h_fine, patches_fine );
-
-        for ( unsigned int i = 0; i < patches_fine.size(); ++i ) {
-            const Patch * patch_fine = patches_fine[i];
-            dbg_out3 << "= Fine Patch " << *patch_fine << std::endl;
-
-            ConstVariable psi_fine, u_fine;
-            dw_new->get ( psi_fine, psi_label, 0, patch_fine, Ghost::None, 0 );
-            dw_new->get ( u_fine, u_label, 0, patch_fine, Ghost::None, 0 );
-            dbg_out4 << "psi_fine \t window " << psi_fine.getLowIndex() << psi_fine.getHighIndex() << std::endl;
-            dbg_out4 << "u_fine \t window " << u_fine.getLowIndex() << u_fine.getHighIndex() << std::endl;
-
-            BlockRange range_coarse (
-                Max ( l_coarse, map_to_coarser ( level_fine, get_low ( patch_fine ) ) ),
-                Min ( h_coarse, map_to_coarser ( level_fine, get_high ( patch_fine ) ) )
-            );
-
-            dbg_out3 << "= Iterating over coarse cells window " << range_coarse << std::endl;
-            parallel_for ( range_coarse, [level_coarse, level_fine, &psi_fine, &u_fine, &psi_coarse, &u_coarse, this] ( int i, int j, int k )->void { coarsen ( i, j, k, level_coarse, level_fine, get_view ( psi_fine ), get_view ( u_fine ), get_view ( psi_coarse ), get_view ( u_coarse ) ); } );
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void AMRPhaseField<VariableType, NumGhosts, Dimension>::task_error_estimate ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRPhaseField::task_error_estimate " << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p ) {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        FlagVariable flag_refine;
-        PerPatch<PatchFlagP> flag_refine_patch;
-        dw_new->getModifiable ( flag_refine, m_regridder->getRefineFlagLabel(), 0, patch );
-        dw_new->get ( flag_refine_patch, m_regridder->getRefinePatchFlagLabel(), 0, patch );
-        dbg_out4 << "flag_refine \t window " << flag_refine.getLowIndex() << flag_refine.getHighIndex() << std::endl;
-
-        PatchFlag * patch_flag_refine = flag_refine_patch.get().get_rep();
-        ConstVariable psi;
-        dw_new->get ( psi, psi_label, 0, patch, Ghost::None, 0 );
-        dbg_out4 << "psi \t window " << psi.getLowIndex() << psi.getHighIndex() << std::endl;
-
-        bool refine_patch = false;
-        BlockRange range = get_flag_inner_range ( patch );
-        dbg_out3 << "= Iterating over inner cells window " << range << std::endl;
-        parallel_for ( range, [patch, &psi, &flag_refine, &refine_patch, this] ( int i, int j, int k )->void { error_estimate ( i, j, k, patch, get_view ( psi ), get_view ( flag_refine ), refine_patch, refine_threshold ); } );
-
-        if ( refine_patch ) {
-            patch_flag_refine->set();
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void AMRPhaseFieldTest<VariableType, NumGhosts, Dimension>::task_error_estimate ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== AMRPhaseFieldTest::task_error_estimate " << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p ) {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        FlagVariable flag_refine;
-        PerPatch<PatchFlagP> flag_refine_patch;
-        dw_new->getModifiable ( flag_refine, m_regridder->getRefineFlagLabel(), 0, patch );
-        dw_new->get ( flag_refine_patch, m_regridder->getRefinePatchFlagLabel(), 0, patch );
-        dbg_out4 << "flag_refine \t window " << flag_refine.getLowIndex() << flag_refine.getHighIndex() << std::endl;
-
-        PatchFlag * patch_flag_refine = flag_refine_patch.get().get_rep();
-        ConstVariable psi;
-        dw_new->get ( psi, psi_label, 0, patch, Ghost::None, 0 );
-        dbg_out4 << "psi \t window " << psi.getLowIndex() << psi.getHighIndex() << std::endl;
-
-        bool refine_patch = false;
-        BlockRange range = get_flag_inner_range ( patch );
-        dbg_out3 << "= Iterating over inner cells window " << range << std::endl;
-        parallel_for ( range, [patch, &psi, &flag_refine, &refine_patch, this] ( int i, int j, int k )->void { error_estimate_test ( i, j, k, patch, get_view ( flag_refine ), refine_patch ); } );
-
-        if ( refine_patch ) {
-            patch_flag_refine->set();
-        }
-    }
-
-    dbg_out2 << std::endl;
-}
-}
-
-#endif
-
-
-
-
-
-
-
diff --git a/src/CCA/Components/PhaseField/Applications/Application.h b/src/CCA/Components/PhaseField/Applications/Application.h
new file mode 100644
index 00000000..a99ea0ea
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Applications/Application.h
@@ -0,0 +1,100 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Applications/Application.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Applications_Application_h
+#define Packages_Uintah_CCA_Components_PhaseField_Applications_Application_h
+
+#include <CCA/Components/Application/ApplicationCommon.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/BCInterface.h>
+#include <CCA/Components/PhaseField/AMR/AMRInterface.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Virtual base for PhaseField applications
+ *
+ * Wrapper of ApplicationCommon and interfaces
+ *
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ * @tparam STN finite-difference stencil
+ * @tparam AMR whether to use adaptive mesh refinement
+ */
+template < VarType VAR, DimType DIM, StnType STN, bool AMR = false > class Application;
+
+/**
+ * @brief Virtual base for PhaseField applications (non-AMR implementation)
+ *
+ * Wrapper of ApplicationCommon and interfaces
+ *
+ * @implements Application < VAR, DIM, STN, AMR >
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ * @tparam STN finite-difference stencil
+ */
+template < VarType VAR, DimType DIM, StnType STN>
+class Application<VAR, DIM, STN, false>
+    : public ApplicationCommon
+    , protected DWInterface<VAR, DIM>
+    , protected BCInterface<VAR, STN>
+{
+public:
+    using ApplicationCommon::ApplicationCommon;
+}; // class Application
+
+/**
+ * @brief Virtual base for PhaseField applications (AMR implementation)
+ *
+ * Wrapper of ApplicationCommon and interfaces
+ *
+ * @implements Application < VAR, DIM, STN, AMR >
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ * @tparam STN finite-difference stencil
+ */
+template < VarType VAR, DimType DIM, StnType STN>
+class Application<VAR, DIM, STN, true>
+    : public ApplicationCommon
+    , protected DWInterface<VAR, DIM>
+    , protected BCInterface<VAR, STN>
+    , protected AMRInterface<VAR, DIM>
+{
+public:
+    using ApplicationCommon::ApplicationCommon;
+}; // class Application
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Applications_Application_h
diff --git a/src/CCA/Components/PhaseField/Applications/ApplicationFactory.cc b/src/CCA/Components/PhaseField/Applications/ApplicationFactory.cc
new file mode 100644
index 00000000..9790bb44
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Applications/ApplicationFactory.cc
@@ -0,0 +1,81 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Applications/ApplicationFactory.cc
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#include <CCA/Components/PhaseField/Applications/ApplicationFactory.h>
+
+#include <Core/Exceptions/ProblemSetupException.h>
+#include <Core/Grid/MaterialManager.h>
+#include <Core/Parallel/UintahParallelComponent.h>
+#include <Core/ProblemSpec/ProblemSpec.h>
+
+using namespace Uintah;
+using namespace PhaseField;
+
+template<> UintahParallelComponentFactory::FactoryMap UintahParallelComponentFactory::RegisteredNames = {};
+
+UintahParallelComponent *
+ApplicationFactory::create (
+    const ProcessorGroup * myWorld,
+    const MaterialManagerP materialManager,
+    ProblemSpecP probSpec,
+    bool doAMR
+)
+{
+    std::string type;
+    if ( !probSpec->getAttribute ( "type", type ) )
+        SCI_THROW ( ProblemSetupException ( "Cannot find type attribute in PhaseField block within problem specification file.", __FILE__, __LINE__ ) );
+    std::transform ( type.begin(), type.end(), type.begin(), ::tolower );
+
+    // composing application factory name [amr|]<application>|<var>|<dim>|<stn>
+    std::string var;
+    var = "cc";
+    probSpec->getWithDefault ( "var", var, var );
+
+    int dim = 2;
+    probSpec->getWithDefault ( "dim", dim, dim );
+
+    std::string stn;
+    if ( dim == 2 ) stn = "p5";
+    else if ( dim == 3 ) stn = "p7";
+
+    probSpec->getWithDefault ( "dim", dim, dim );
+    std::transform ( stn.begin(), stn.end(), stn.begin(), ::tolower );
+
+    std::string application = ( doAMR ? "amr|" : "" ) + type + "|" + var + "|d" + std::to_string ( dim ) + "|" + stn;
+
+    int verbosity;
+    probSpec->getWithDefault ( "verbosity", verbosity, 0 );
+
+    UintahParallelComponentBase * ptr = UintahParallelComponentFactory::Create ( application, myWorld, materialManager, verbosity );
+
+    if ( !ptr )
+        SCI_THROW ( ProblemSetupException ( "Cannot Create PhaseField Application '" + application + "'", __FILE__, __LINE__ ) );
+    return dynamic_cast<UintahParallelComponent *> ( ptr );
+}
diff --git a/src/CCA/Components/PhaseField/Applications/ApplicationFactory.h b/src/CCA/Components/PhaseField/Applications/ApplicationFactory.h
new file mode 100644
index 00000000..f43a46d1
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Applications/ApplicationFactory.h
@@ -0,0 +1,86 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Applications/ApplicationFactory.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Applications_ApplicationFactory_h
+#define Packages_Uintah_CCA_Components_PhaseField_Applications_ApplicationFactory_h
+
+#include <CCA/Components/PhaseField/Factory/Base.h>
+#include <CCA/Components/PhaseField/Factory/Factory.h>
+
+#include <Core/Grid/MaterialManagerP.h>
+#include <Core/ProblemSpec/ProblemSpecP.h>
+
+namespace Uintah
+{
+
+class ProcessorGroup;
+class UintahParallelComponent;
+
+namespace PhaseField
+{
+
+/// Base class for UintahParallelComponent
+using UintahParallelComponentBase = Base<UintahParallelComponent>;
+
+/// Factory class for UintahParallelComponent
+using UintahParallelComponentFactory = Factory<UintahParallelComponent, const ProcessorGroup *, const MaterialManagerP, int>;
+
+/**
+ * @brief Factory class for different PhaseField applications
+ *
+ * Factory class for creating new instances of UintahParallelComponent
+ * within the PhaseField component
+ */
+class ApplicationFactory
+{
+public:
+    /**
+    * @brief factory create method
+    *
+    * Factory method for creating new instances of UintahParallelComponent
+    * within the PhaseField component
+    *
+    * @param myWorld data structure to manage mpi processes
+    * @param materialManager data structure to manage materials
+    * @param probSpec specifications parsed from ups input file
+    * @param doAMR if adaptive mesh refinement is requsted by the input
+    */
+    static UintahParallelComponent * create (
+        const ProcessorGroup * myWorld,
+        const MaterialManagerP materialManager,
+        ProblemSpecP probSpec,
+        bool doAMR
+    );
+}; // class ApplicationFactory
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Applications_ApplicationFactory_h
diff --git a/src/CCA/Components/PhaseField/Applications/PureMetal.cc b/src/CCA/Components/PhaseField/Applications/PureMetal.cc
new file mode 100644
index 00000000..03149b75
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Applications/PureMetal.cc
@@ -0,0 +1,70 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Applications/PureMetal.cc
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ *
+ * In this the names used by ApplicationFactory for the differnt implementations
+ * of the PureMetal application are defined as well as their explicit
+ * instantiation.
+ */
+
+#include <CCA/Components/PhaseField/Applications/PureMetal.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+#ifndef _DOXY_IGNORE_
+template<> const std::string PureMetalProblem<CC, P5>::Name = "PureMetalProblem";
+template<> const std::string PureMetalProblem<NC, P5>::Name = "PureMetalProblem";
+template<> const std::string PureMetalProblem<CC, P7>::Name = "PureMetalProblem";
+template<> const std::string PureMetalProblem<NC, P7>::Name = "PureMetalProblem";
+
+template<> const std::string PureMetal<CC, D2, P5>::Name = "pure_metal|cc|d2|p5";
+template<> const std::string PureMetal<NC, D2, P5>::Name = "pure_metal|nc|d2|p5";
+template<> const std::string PureMetal<CC, D3, P7>::Name = "pure_metal|cc|d3|p7";
+template<> const std::string PureMetal<NC, D3, P7>::Name = "pure_metal|nc|d3|p7";
+
+template<> const std::string PureMetal<CC, D2, P5, AMR>::Name = "amr|pure_metal|cc|d2|p5";
+template<> const std::string PureMetal<NC, D2, P5, AMR>::Name = "amr|pure_metal|nc|d2|p5";
+template<> const std::string PureMetal<CC, D3, P7, AMR>::Name = "amr|pure_metal|cc|d3|p7";
+template<> const std::string PureMetal<NC, D3, P7, AMR>::Name = "amr|pure_metal|nc|d3|p7";
+
+template class PureMetal<CC, D2, P5>;
+template class PureMetal<NC, D2, P5>;
+template class PureMetal<CC, D3, P7>;
+template class PureMetal<NC, D3, P7>;
+
+template class PureMetal<CC, D2, P5, AMR>;
+template class PureMetal<NC, D2, P5, AMR>;
+template class PureMetal<CC, D3, P7, AMR>;
+template class PureMetal<NC, D3, P7, AMR>;
+#endif
+
+} // namespace Uintah
+} // namespace PhaseField
diff --git a/src/CCA/Components/PhaseField/Applications/PureMetal.h b/src/CCA/Components/PhaseField/Applications/PureMetal.h
new file mode 100644
index 00000000..916a1862
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Applications/PureMetal.h
@@ -0,0 +1,2356 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Applications/PureMetal.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Applications_PureMetal_h
+#define Packages_Uintah_CCA_Components_PhaseField_Applications_PureMetal_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/Util/Expressions.h>
+#include <CCA/Components/PhaseField/Util/BlockRangeIO.h>
+#include <CCA/Components/PhaseField/DataTypes/PureMetalProblem.h>
+#include <CCA/Components/PhaseField/DataTypes/SubProblemsP.h>
+#include <CCA/Components/PhaseField/DataTypes/SubProblems.h> // must be included after SubProblemsP where swapbyte soverride is defined
+#include <CCA/Components/PhaseField/DataTypes/Variable.h>
+#include <CCA/Components/PhaseField/DataTypes/ScalarField.h>
+#include <CCA/Components/PhaseField/DataTypes/VectorField.h>
+#include <CCA/Components/PhaseField/Applications/Application.h>
+#include <CCA/Components/PhaseField/Factory/Implementation.h>
+#include <CCA/Components/PhaseField/Views/View.h>
+#include <CCA/Components/PhaseField/Views/FDView.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWView.h>
+#include <CCA/Components/PhaseField/AMR/AMRInterpolator.h>
+#include <CCA/Components/PhaseField/AMR/AMRRestrictor.h>
+
+#include <Core/Util/DebugStream.h>
+#include <Core/Grid/SimpleMaterial.h>
+#include <Core/Parallel/UintahParallelComponent.h>
+#include <CCA/Ports/Regridder.h>
+#include <Core/Grid/Variables/PerPatchVars.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/// Debugging stream for component schedulings
+static DebugStream cout_pure_metal_scheduling ( "PURE METAL SCHEDULING", false );
+
+/**
+ * @brief PureMetal PhaseField applications
+ *
+ * Implements a Finite Difference solver for the simulation of the anisotropic
+ * solidification of an under-cooled metal around a solid seed using the model
+ * from
+ *
+ * A, Karma and W.-J. Rappel,
+ * "Phase-Field Method for Computationally Efficient Modeling of Solidification
+ * with Arbitrary Interface Kinetics",
+ * Phys.Rev.E, 1996.
+ *
+ * Phase-field equation for \f$\psi : \Omega \to [-1. 1]\f$
+ * \f[
+ * \tau_0 A^2 \dot \psi = \psi (1-\psi^2) - \lambda u (\psi^2 - 1)^2
+ *                      + W_0^2 A^2 \nabla^2 \psi
+ *                      + W_0^2 (A^2_x - \partial_y B_{xy} - \partial_y B_{xz} \psi_x
+ *                      + W_0^2 (A^2_y + \partial_y B_{xy} - \partial_y B_{yz} \psi_y
+ *                      + W_0^2 (A^2_y + \partial_y B_{xz} + \partial_y B_{yz} \psi_z
+ * \f]
+ * (for 3D problems all quantities with \f$z\f$ in the subscript are null)
+ *
+ * non-dimensional temperature equation for \f$u:\Omega \to \mathbb R\f$
+ * \f[
+ * \dot u = \alpha \nabla^2 u + 1/2 \dot \psi
+ * \f]
+ *
+ * with the following anisotropy functions
+ * \f[ A    = 1 - 3 \epsilon + 4\epsilon \sum n_i^4 \f]
+ * \f[ B_ij = 16 \epsilon A \psi_i \psi_j (\psi_i^2-\psi_j^2) / |\nabla\psi|^4 \f]
+ * where \f$ n=\nabla\psi/|\nabla\psi \f$
+ *
+ * The model parameters are:
+ * - \f$ \lambda \f$  coupling parameter
+ * - \f$ W_0 \f$      width scaling (\f$ W = W_0 A \f$ is the interface width)
+ * - \f$ \tau_0 \f$   time scaling (\f$ \tau = \tau_0 A^2 \f$ is the characteristic
+ *                    time of attachment of atoms at the interface)
+ * - \f$ \epsilon \f$ anisotropy strength
+ * - \f$ \alpha \f$   thermal diffusivity
+ *
+ * The following no-dimensionalizations are performed
+ * - \f$ x \mapsto x/W_0 \f$
+ * - \f$ t \mapsto t/\tau_0 \f$
+ * - \f$ \alpha \mapsto \alpha\tau_0/W_0^2 \f$
+ *
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimensions
+ * @tparam STN finite-difference stencil
+ * @tparam AMR whether to use adaptive mesh refinement
+ */
+template<VarType VAR, DimType DIM, StnType STN, bool AMR = false>
+class PureMetal
+    : public Application<VAR, DIM, STN, AMR>
+    , public Implementation<PureMetal<VAR, DIM, STN, AMR>, UintahParallelComponent, const ProcessorGroup *, const MaterialManagerP, int>
+{
+    /// Problem material index (only one SimpleMaterial)
+    static constexpr int material = 0;
+
+    /// Number of anisotropy functions B
+    static constexpr size_t BSZ = combinations<DIM, 2>::value;
+
+    /// Indices for anisotropy functions B
+    static constexpr size_t XY = 0, XZ = 1, YZ = 2;
+
+    /// Number of ghost elements required by STN (on the same level)
+    static constexpr int FGN = get_stn<STN>::ghosts;
+
+    /// Type of ghost elements required by VAR and STN (on coarser level)
+    static constexpr Ghost::GhostType FGT = FGN ? get_var<VAR>::ghost_type : Ghost::None;
+
+    /// Number of ghost elements required by STN (on coarser level)
+    /// @remark this should depend on FCI bc type but if fixed for simplicity
+    static constexpr int CGN = 1;
+
+    /// Type of ghost elements required by VAR and STN (on the same level)
+    static constexpr Ghost::GhostType CGT = CGN ? get_var<VAR>::ghost_type : Ghost::None;
+
+    /// Interpolation type for refinement
+    static constexpr FCIType C2F = ( VAR == CC ) ? I0 : I1; // TODO make template parameter
+
+    /// Restriction type for coarsening
+    static constexpr FCIType F2C = ( VAR == CC ) ? I1 : I0; // TODO make template parameter
+
+    /// If grad_psi_norm2 is less than tol than psi is considered constant when computing anisotropy terms
+    static constexpr double tol = 1.e-6;
+
+    /// Index of variables within PureMetalProblem
+    static constexpr size_t PSI = 0; ///< Index for phase-field
+    static constexpr size_t U = 1;   ///< Index for non-dimensional temperature field
+    static constexpr size_t A2 = 2;  ///< Index for the square of the anisotropy function
+    static constexpr size_t B = 3;   ///< Index for the anisotropy terms B_ij
+
+public: // STATIC MEMBERS
+
+    /// Class name as used by ApplicationFactory
+    static const std::string Name;
+
+protected: // MEMBERS
+
+    /// Output streams for debugging
+    DebugStream dbg_out1, dbg_out2, dbg_out3, dbg_out4;
+
+    // Labels for variables to be stored into the DataWarehouse
+    const VarLabel * subproblems_label;
+    const VarLabel * psi_label, * u_label;
+    const VarLabel * grad_psi_norm2_label;
+    const VarLabel * a_label, * a2_label;
+    std::array<const VarLabel *, DIM> grad_psi_label;
+    std::array<const VarLabel *, BSZ> b_label;
+
+    /// Time step size
+    double delt;
+
+    /// Coupling parameter
+    double lambda;
+
+    /// Non-dimensional thermal diffusivity
+    double alpha;
+
+    /// Anisotropy strength
+    double epsilon;
+
+    /// Initial interface widths
+    double gamma_psi, gamma_u;
+
+    /// Initial seed radius
+    double r0;
+
+    /// Initial undercooling
+    double delta;
+
+    /// Threshold for AMR
+    double refine_threshold;
+
+    /// Store which fine/coarse interface conditions to use on each variable
+    std::map<std::string, FC> c2f;
+
+    /// Flag for avoiding multiple reinitialization of subproblems after regridding
+    bool is_first_schedule_refine;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Intantiate a PureMetal application
+     *
+     * @param myWorld data structure to manage mpi processes
+     * @param materialManager data structure to manage materials
+     * @param verbosity constrols amount of debugging output
+     */
+    PureMetal (
+        const ProcessorGroup * myWorld,
+        const MaterialManagerP materialManager,
+        int verbosity = 0
+    );
+
+    /**
+     * @brief Destructor
+     */
+    virtual ~PureMetal();
+
+    /// Prevent copy (and move) constructor
+    PureMetal ( const PureMetal & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    PureMetal & operator= ( const PureMetal & ) = delete;
+
+protected: // SETUP
+
+    /**
+     * @brief Setup
+     *
+     * Initialize problem parameters with values from problem specifications
+     *
+     * @param params problem specifications parsed from input file
+     * @param restart_prob_spec unused
+     * @param grid unused
+     */
+    virtual void
+    problemSetup (
+        const ProblemSpecP & params,
+        const ProblemSpecP & restart_prob_spec,
+        GridP & grid
+    ) override;
+
+protected: // SCHEDULINGS
+
+    /**
+     * @brief Schedule the initialization tasks
+     *
+     * Specify all tasks to be performed at initial timestep to initialize
+     * variables in the DataWarehouse
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleInitialize (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_initialize_subproblems (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleInitialize_subproblems (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_initialize_subproblems (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleInitialize_subproblems (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_initialize_solution (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleInitialize_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_initialize_solution (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleInitialize_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_initialize_grad_psi (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which initializes psi
+     * and grad_psi_norm2 allowing sched to control its execution order.
+     * Initialize also the anisotropy terms to 0
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleInitialize_grad_psi (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_initialize_grad_psi (AMR implementation)
+     *
+     * Does nothing since grad_psi and grad_psi_norm2 are computed by
+     * error_estimate_grad_psi.
+     *
+     * @param level unused
+     * @param sched unused
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleInitialize_grad_psi (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the initialization tasks for restarting a simulation
+     *
+     * Specify all tasks to be performed at fist timestep after a stop to
+     * initialize not saved variables to the DataWarehouse
+     *
+     * @remark only subproblems need to be reinitialized all other variables
+     * should be retrieved from saved checkpoints
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleRestartInitialize (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_compute_stable_timestep
+     *
+     * Specify all tasks to be performed before each time advance to compute a
+     * timestep size which ensures numerical stability
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleComputeStableTimeStep (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule the time advance tasks
+     *
+     * Specify all tasks to be performed at each timestep to update the
+     * simulation variables in the DataWarehouse
+     *
+     * @param level grid level to be initialized
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleTimeAdvance (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_time_advance_solution (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleTimeAdvance_subproblems (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_solution (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates the
+     * subproblems allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleTimeAdvance_subproblems (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_grad_psi (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates grad psi
+     * and grad_psi_norm2 allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleTimeAdvance_grad_psi (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_grad_psi (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates grad psi
+     * and grad_psi_norm2 allowing sched to control its execution order
+     *
+     * @remark does nothing since it grad_psi and grad_psi_norm2 are already
+     * computed by error_estimate_grad_psi
+     *
+     * @param level unused
+     * @param sched unused
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleTimeAdvance_grad_psi (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_anisotropy_terms
+     *
+     * Defines the dependencies and output of the task which updates the
+     * anisotropy terms allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     *
+     * @remark since no derivative is involved there is no need to have two
+     * different implementation for non AMR and non AMR cases
+     */
+    void
+    scheduleTimeAdvance_anisotropy_terms (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_solution (non AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates psi
+     * and u allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleTimeAdvance_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_time_advance_solution (AMR implementation)
+     *
+     * Defines the dependencies and output of the task which updates psi
+     * and u allowing sched to control its execution order
+     *
+     * @param level grid level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleTimeAdvance_solution (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the refinement tasks
+     *
+     * Specify all tasks to be performed after an AMR regrid in order to populate
+     * variables in the DataWarehouse at newly created patches
+     *
+     * @remark If regridding happens at initial time step scheduleInitialize is
+     * called instead
+     *
+     * @param new_patches patches to be populated
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleRefine (
+        const PatchSet * new_patches,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_initialize_subproblems after regridding
+     *
+     * Defines the dependencies and output of the task which initializes the
+     * subproblems allowing sched to control its execution order
+     *
+     * @remark subproblems need to be reinitialized on all patches because
+     * even preexisting patches may have different neighbors
+     *
+     * @param grid grid to be populated
+     * @param sched scheduler to manage the tasks
+     */
+    void
+    scheduleRefine_subproblems (
+        const GridP & grid,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_refine_solution
+     *
+     * Defines the dependencies and output of the task which interpolates the
+     * solution from the coarser level to each one of the new_patches
+     * allowing sched to control its execution order
+     *
+     * @param new_patches patches to be populated
+     * @param sched scheduler to manage the tasks
+     */
+    void
+    scheduleRefine_solution (
+        const PatchSet * new_patches,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_refine_grad_psi
+     *
+     * Defines the dependencies and output of the task which computes the
+     * derivatives of psi on each one of the new_patches allowing sched to
+     * control its execution order
+     *
+     * @param new_patches patches to be populated
+     * @param sched scheduler to manage the tasks
+     */
+    void
+    scheduleRefine_grad_psi (
+        const PatchSet * new_patches,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the refinement tasks
+     *
+     * Do nothing
+     *
+     * @param level_fine unused
+     * @param sched unused
+     * @param need_old_coarse unused
+     * @param need_new_coarse unused
+     */
+    virtual void
+    scheduleRefineInterface (
+        const LevelP & level_fine,
+        SchedulerP & sched,
+        bool need_old_coarse,
+        bool need_new_coarse
+    ) override;
+
+    /**
+     * @brief Schedule the time coarsen tasks
+     *
+     * Specify all tasks to be performed after each timestep to restrict the
+     * computed variables from finer to coarser levels
+     *
+     * @param level_coarse level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleCoarsen (
+        const LevelP & level_coarse,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_coarsen_solution
+     *
+     * Defines the dependencies and output of the task which restrict the
+     * solution to level_coarse from its finer level allowing sched to control
+     * its execution order
+     *
+     * @param level_coarse level to be updated
+     * @param sched scheduler to manage the tasks
+     */
+    void
+    scheduleCoarsen_solution (
+        const LevelP & level_coarse,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the error estimate tasks
+     *
+     * Specify all tasks to be performed before each timestep to estimate the
+     * spatial discretization error on the solution update in order to decide
+     * where to refine the grid
+     *
+     * @param level level to check
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleErrorEstimate (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+    /**
+     * @brief Schedule task_error_estimate_grad_psi (coarsest level implementation)
+     *
+     * Defines the dependencies and output of the task which estimates the
+     * spatial discretization error allowing sched to control its execution order
+     *
+     * @param level level to check
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < !MG, void >::type
+    scheduleErrorEstimate_grad_psi (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule task_error_estimate_grad_psi (refinement level implementation)
+     *
+     * Defines the dependencies and output of the task which estimates the
+     * spatial discretization error allowing sched to control its execution order
+     *
+     * @param level level to check
+     * @param sched scheduler to manage the tasks
+     */
+    template < bool MG >
+    typename std::enable_if < MG, void >::type
+    scheduleErrorEstimate_grad_psi (
+        const LevelP & level,
+        SchedulerP & sched
+    );
+
+    /**
+     * @brief Schedule the initial error estimate tasks
+     *
+     * Specify all tasks to be performed before the first timestep to estimate
+     * the spatial discretization error on the solution update in order to decide
+     * where to refine the grid
+     *
+     * @remark forward to scheduleErrorEstimate
+     *
+     * @param level level to check
+     * @param sched scheduler to manage the tasks
+     */
+    virtual void
+    scheduleInitialErrorEstimate (
+        const LevelP & level,
+        SchedulerP & sched
+    ) override;
+
+protected: // TASKS
+
+    /**
+     * @brief Initialize subproblems task
+     *
+     * Create the SubProblems for each one of the patches and save it to dw_new
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_initialize_subproblems (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Initialize solution task
+     *
+     * Allocate and save variables for psi and u for each one of the patches
+     * and save them to dw_new
+     * @remark initialize also anisotropy terms to 0
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_initialize_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Initialize grad psi task
+     *
+     * Allocate and save variable for psi derivatives for each one of the patches
+     * and save it to dw_new
+     * @remark initialize also anisotropy terms to 0
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_initialize_grad_psi (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Compute timestep task
+     *
+     * Puts into the new DataWarehouse the constant value specified in input (delt)
+     * of the timestep
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_compute_stable_timestep (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Advance subproblems task
+     *
+     * Move SubProblems for each one of the patches and from dw_old to dw_new
+     * or, if not found in dw_old (after regrid), create new subproblems in dw_new
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_subproblems (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Advance grad_psi task
+     *
+     * Computes the gradient of the phase field using its value at the previous
+     * timestep
+     *
+     * @remark this task is scheduled only if AMR is disabled since the the
+     * gradient of the phase field for AMR simulations is already computed by
+     * task_error_estimate_grad_psi
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_grad_psi (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Advance anisotropy terms task
+     *
+     * Computes A, A2 and B using the value of grad_psi at the previous timestep
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_anisotropy_terms (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Advance solution task
+     *
+     * Computes new value of psi and u using the newly computed anisotropy terms
+     * together with the value of the solution and grad_psi at the previous timestep
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_time_advance_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Refine solution task
+     *
+     * Computes interpolated value of u and psi on new refined patched
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches_fine list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_refine_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches_fine,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Refine grad psi task
+     *
+     * Computes value of grad psi on new refined patched from the interpolated
+     * values of psi
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches_fine list of patches to be initialized
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_refine_grad_psi (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches_fine,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief Coarsen solution task
+     *
+     * Restricted value of u and psi from refined regions to coarse patches
+     * underneath
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches_coarse list of patches to be updated
+     * @param matls unused
+     * @param dw_old unused
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_coarsen_solution (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches_coarse,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+    /**
+     * @brief ErrorEstimate grad_psi task
+     *
+     * Computes the gradient of the phase field using its value at the previous
+     * timestep and set refinement flag where it is above the threshold given
+     * in input
+     *
+     * @remark this task replaces task_time_advance_grad_psi for AMR simulations
+     *
+     * @param myworld data structure to manage mpi processes
+     * @param patches list of patches to be initialized
+     * @param matls unused
+     * @param dw_old DataWarehouse for previous timestep
+     * @param dw_new DataWarehouse to be initialized
+     */
+    void
+    task_error_estimate_grad_psi (
+        const ProcessorGroup * myworld,
+        const PatchSubset * patches,
+        const MaterialSubset * matls,
+        DataWarehouse * dw_old,
+        DataWarehouse * dw_new
+    );
+
+protected: // IMPLEMENTATIONS
+
+    /**
+     * @brief Initialize solution implementation
+     *
+     * compute initial condition for psi and u at a given grid position
+     *
+     * @param id grid index
+     * @param patch grid patch
+     * @param[out] psi view of the phase field in the new dw
+     * @param[out] u view of the temperature field in the new dw
+     */
+    void
+    initialize_solution (
+        const IntVector & id,
+        const Patch * patch,
+        View < ScalarField<double> > & psi,
+        View < ScalarField<double> > & u
+    );
+
+    /**
+     * @brief Advance grad_psi implementation
+     *
+     * compute new value for grad_psi at a given grid position using its value
+     * at the previous timestep
+     *
+     * @param id grid index
+     * @param psi view of the phase field in the old dw
+     * @param[out] grad_psi view of the phase gradient field in the new dw
+     * @param[out] grad_psi_norm2 view of the norm of the phase gradient field
+     * in the new dw
+     */
+    void
+    time_advance_grad_psi (
+        const IntVector & id,
+        FDView < ScalarField<const double>, STN > & psi,
+        View < VectorField<double, DIM > > & grad_psi,
+        View < ScalarField<double> > & grad_psi_norm2
+    );
+
+    /**
+     * @brief Advance anisotropy terms implementation
+     *
+     * compute new value for grad_psi at a given grid position using its value
+     * at the previous timestep
+     *
+     * @param id grid index
+     * @param grad_psi view of the phase gradient field in the old dw
+     * @param grad_psi_norm2 view of the norm of the phase gradient field
+     * in the old dw
+     * @param[out] a view of A in the new dw
+     * @param[out] a2 view of A2 in the new dw
+     * @param[out] b view of B in the new dw
+     */
+    void
+    time_advance_anisotropy_terms (
+        const IntVector & id,
+        View < VectorField<const double, DIM> > & grad_psi,
+        View < ScalarField<const double> > & grad_psi_norm2,
+        View < ScalarField<double> > & a,
+        View < ScalarField<double> > & a2,
+        View < VectorField<double, BSZ> > & b
+    );
+
+    /**
+     * @brief Advance solution terms implementation
+     *
+     * compute new value for psi and u at a given grid position using the newly
+     * computed anisotropy terms together with the value of the solution and
+     * grad_psi at the previous timestep
+     *
+     * @param id grid index
+     * @param psi_old view of the phase field in the old dw
+     * @param u_old view of the temperature field in the old dw
+     * @param grad_psi view of the phase gradient field in the old dw
+     * @param a view of A in the new dw
+     * @param a2 view of A2 in the new dw
+     * @param b view of B in the new dw
+     * @param[out] psi_new view of the phase field in the new dw
+     * @param[out] u_new view of the temperature field in the new dw
+     */
+    void
+    time_advance_solution (
+        const IntVector & id,
+        FDView < ScalarField<const double>, STN > & psi_old,
+        FDView < ScalarField<const double>, STN > & u_old,
+        View < VectorField<const double, DIM> > & grad_psi,
+        View < ScalarField<const double> > & a,
+        FDView < ScalarField<const double>, STN > & a2,
+        FDView < VectorField<const double, BSZ>, STN > & b,
+        View < ScalarField<double> > & psi_new,
+        View < ScalarField<double> > & u_new
+    );
+
+    /**
+     * @brief Refine solution implementation
+     *
+     * Computes interpolated value of u and psi at a given grid position
+
+     * @param id_fine fine grid index
+     * @param psi_coarse_interp interpolator of the phase field on the coarse level
+     * @param u_coarse_interp interpolator of the temperature field on the coarse level
+     * @param[out] psi_fine view of the phase field on the fine level
+     * @param[out] u_fine view of the temperature field on the fine level
+     */
+    void
+    refine_solution (
+        const IntVector id_fine,
+        const View < ScalarField<const double> > & psi_coarse_interp,
+        const View < ScalarField<const double> > & u_coarse_interp,
+        View < ScalarField<double> > & psi_fine,
+        View < ScalarField<double> > & u_fine
+    );
+
+    /**
+     * @brief Coarsen solution implementation
+     *
+     * Computes restricted value of u and psi at a given grid position
+
+     * @param id_coarse coarse grid index
+     * @param psi_fine_restr restrictor of the phase field on the fine level
+     * @param u_fine_restr restrictor of the temperature field on the fine level
+     * @param[out] psi_coarse view of the phase field on the coarse level
+     * @param[out] u_coarse view of the temperature field on the coarse level
+     */
+    void
+    coarsen_solution (
+        const IntVector id_coarse,
+        const View < ScalarField<const double> > & psi_fine_restr,
+        const View < ScalarField<const double> > & u_fine_restr,
+        View < ScalarField<double> > & psi_coarse,
+        View < ScalarField<double> > & u_coarse
+    );
+
+    /**
+     * @brief ErrorEstimate grad_psi implementation
+     *
+     * Computes the gradient of the phase field using its value at the previous
+     * timestep and set refinement flag where it is above the threshold given
+     * in input
+     *
+     * @param id grid index
+     * @param psi view of the phase field in the old dw
+     * @param[out] grad_psi view of the phase gradient field in the new dw
+     * @param[out] grad_psi_norm2 view of the norm of the phase gradient field
+     * in the new dw
+     * @param[out] refine_flag view of refine flag (grid field) in the new dw
+     * @param[out] refine_patch flag for patch refinement
+     */
+    void
+    error_estimate_grad_psi (
+        const IntVector & id,
+        FDView < ScalarField<const double>, STN > & psi,
+        View < VectorField<double, DIM> > & grad_psi,
+        View < ScalarField<double> > & grad_psi_norm2,
+        View< ScalarField<int> > & refine_flag,
+        bool & refine_patch
+    );
+
+}; // class PureMetal
+
+// CONSTRUCTORS/DESTRUCTOR
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+PureMetal<VAR, DIM, STN, AMR>::PureMetal (
+    const ProcessorGroup * myworld,
+    MaterialManagerP const materialManager,
+    int verbosity
+) : Application<VAR, DIM, STN, AMR> ( myworld, materialManager ),
+    dbg_out1 ( "PureMetal", verbosity > 0 ),
+    dbg_out2 ( "PureMetal", verbosity > 1 ),
+    dbg_out3 ( "PureMetal", verbosity > 2 ),
+    dbg_out4 ( "PureMetal", verbosity > 3 )
+{
+    subproblems_label = VarLabel::create ( "subproblems", Variable< PP, SubProblems < PureMetalProblem<VAR, STN> > >::getTypeDescription() );
+    psi_label = VarLabel::create ( "psi", Variable<VAR, double>::getTypeDescription() );
+    u_label = VarLabel::create ( "u", Variable<VAR, double>::getTypeDescription() );
+    grad_psi_norm2_label = VarLabel::create ( "grad_psi_norm2", Variable<VAR, double>::getTypeDescription() );
+    a_label = VarLabel::create ( "A", Variable<VAR, double>::getTypeDescription() );
+    a2_label = VarLabel::create ( "A2", Variable<VAR, double>::getTypeDescription() );
+
+    grad_psi_label[X] = VarLabel::create ( "psi_x", Variable<VAR, double>::getTypeDescription() );
+    if ( DIM > D1 )
+    {
+        grad_psi_label[Y] = VarLabel::create ( "psi_y", Variable<VAR, double>::getTypeDescription() );
+        b_label[XY] = VarLabel::create ( "Bxy", Variable<VAR, double>::getTypeDescription() );
+    }
+    if ( DIM > D2 )
+    {
+        grad_psi_label[Z] = VarLabel::create ( "psi_z", Variable<VAR, double>::getTypeDescription() );
+        b_label[XZ] = VarLabel::create ( "Bxz", Variable<VAR, double>::getTypeDescription() );
+        b_label[YZ] = VarLabel::create ( "Byz", Variable<VAR, double>::getTypeDescription() );
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+PureMetal<VAR, DIM, STN, AMR>::~PureMetal()
+{
+    VarLabel::destroy ( subproblems_label );
+    VarLabel::destroy ( psi_label );
+    VarLabel::destroy ( u_label );
+    VarLabel::destroy ( grad_psi_norm2_label );
+    VarLabel::destroy ( a_label );
+    VarLabel::destroy ( a2_label );
+    for ( size_t d = 0; d < DIM; ++d )
+        VarLabel::destroy ( grad_psi_label[d] );
+    for ( size_t d = 0; d < BSZ; ++d )
+        VarLabel::destroy ( b_label[d] );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::problemSetup (
+    const ProblemSpecP & params,
+    const ProblemSpecP & /*restart_prob_spec*/,
+    GridP & /*grid*/
+)
+{
+    // PerPatch variables are not copied automatically even if a task for copying
+    // them is scheduled, we need to prevent such task to be scheduled
+    this->m_scheduler->overrideVariableBehavior ( subproblems_label->getName(), false, false, false, true, true );
+
+    // register default material
+    this->m_materialManager->registerSimpleMaterial ( scinew SimpleMaterial() );
+
+    // read model parameters
+    ProblemSpecP pure_metal = params->findBlock ( "PhaseField" );
+    pure_metal->require ( "delt", delt );
+    pure_metal->require ( "alpha", alpha );
+    pure_metal->require ( "R0", r0 );
+    pure_metal->require ( "Delta", delta );
+    pure_metal->require ( "epsilon", epsilon );
+    pure_metal->getWithDefault ( "gamma_psi", gamma_psi, 1. );
+    pure_metal->getWithDefault ( "gamma_u", gamma_u, 1. );
+
+    // coupling parameter
+    lambda = alpha / 0.6267;
+
+    if ( AMR )
+    {
+        this->setLockstepAMR ( true );
+
+        // read amr parameters
+        pure_metal->require ( "refine_threshold", refine_threshold );
+
+        ProblemSpecP amr, regridder, fci;
+        if ( ! ( amr = params->findBlock ( "AMR" ) ) ) return;
+        if ( ! ( fci = amr->findBlock ( "FineCoarseInterfaces" ) ) ) return;
+        if ( ! ( fci = fci->findBlock ( "FCIType" ) ) ) return;
+        do
+        {
+            std::string label, var;
+            fci->getAttribute ( "label", label );
+            fci->getAttribute ( "var", var );
+            c2f[label] = str_to_fc ( var );
+        }
+        while ( ( fci = fci->findNextBlock ( "FCIType" ) ) );
+    }
+}
+
+// SCHEDULINGS
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleInitialize (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    scheduleInitialize_subproblems<AMR> ( level, sched );
+    scheduleInitialize_solution<AMR> ( level, sched );
+    scheduleInitialize_grad_psi<AMR> ( level, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleInitialize_subproblems (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_initialize_subproblems", this, &PureMetal::task_initialize_subproblems );
+    task->computes ( subproblems_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+/**
+ * @remark we need to schedule all levels before task_error_estimate_grad_psi to
+ * avoid the error "Failure finding [subproblems , coarseLevel, MI: none, NewDW
+ * (mapped to dw index 1), ####] for PureMetal::task_error_estimate_grad_psi",
+ * on patch #, Level #, on material #, resource (rank): #" while compiling the
+ * TaskGraph
+ */
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleInitialize_subproblems (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    // since the SimulationController is calling this scheduler starting from
+    // the finest level we schedule only on the finest level
+    if ( level->hasFinerLevel() ) return;
+
+    GridP grid = level->getGrid();
+    for ( int l = 0; l < grid->numLevels(); ++l )
+        scheduleInitialize_subproblems < !MG > ( grid->getLevel ( l ), sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleInitialize_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_initialize_solution", this, &PureMetal::task_initialize_solution );
+    task->computes ( psi_label );
+    task->computes ( u_label );
+    task->computes ( a_label );
+    task->computes ( a2_label );
+    for ( size_t d = 0; d < BSZ; ++d )
+        task->computes ( b_label[d] );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleInitialize_grad_psi (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_initialize_grad_psi", this, &PureMetal::task_initialize_grad_psi );
+    task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::NewDW, psi_label, FGT, FGN );
+    task->computes ( grad_psi_norm2_label );
+    for ( size_t d = 0; d < DIM; ++d )
+        task->computes ( grad_psi_label[d] );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleInitialize_grad_psi (
+    const LevelP & /*level*/,
+    SchedulerP & /*sched*/
+)
+{}
+
+/**
+ * @remark we need to schedule all levels before task_error_estimate_grad_psi to
+ * avoid the error "Failure finding [u , coarseLevel, MI: none, NewDW
+ * (mapped to dw index 1), ####] for PureMetal::task_error_estimate_grad_psi",
+ * on patch #, Level #, on material #, resource (rank): #" while compiling the
+ * TaskGraph
+ */
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleInitialize_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    // since the SimulationController is calling this scheduler starting from
+    // the finest level we schedule only on the finest level
+    if ( level->hasFinerLevel() ) return;
+
+    GridP grid = level->getGrid();
+    for ( int l = 0; l < grid->numLevels(); ++l )
+        scheduleInitialize_solution < !MG > ( grid->getLevel ( l ), sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleRestartInitialize (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    scheduleInitialize_subproblems<AMR> ( level, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void PureMetal<VAR, DIM, STN, AMR>::scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched )
+{
+    Task * task = scinew Task ( "PureMetal::task_compute_stable_timestep", this, &PureMetal::task_compute_stable_timestep );
+    task->computes ( this->getDelTLabel(), level.get_rep() );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+
+    // reset flag here since TaskGraph compiler call scheduleComputeStableTimeStep
+    // after each regridding
+    is_first_schedule_refine = true;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleTimeAdvance (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    scheduleTimeAdvance_subproblems<AMR> ( level, sched );
+    scheduleTimeAdvance_grad_psi<AMR> ( level, sched );
+    scheduleTimeAdvance_anisotropy_terms ( level, sched );
+    scheduleTimeAdvance_solution<AMR> ( level, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleTimeAdvance_subproblems (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_time_advance_subproblems", this, &PureMetal::task_time_advance_subproblems );
+    task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+    task->computes ( subproblems_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleTimeAdvance_subproblems (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    if ( level->hasCoarserLevel() ) return;
+
+    GridP grid = level->getGrid();
+    for ( int l = 0; l < grid->numLevels(); ++l )
+        scheduleTimeAdvance_subproblems < !MG > ( grid->getLevel ( l ), sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleTimeAdvance_grad_psi (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_time_advance_grad_psi", this, &PureMetal::task_time_advance_grad_psi );
+    task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::OldDW, psi_label, FGT, FGN );
+    task->computes ( grad_psi_norm2_label );
+    for ( size_t d = 0; d < DIM; ++d )
+        task->computes ( grad_psi_label[d] );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleTimeAdvance_grad_psi (
+    const LevelP & ,
+    SchedulerP &
+)
+{
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleTimeAdvance_anisotropy_terms (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_time_advance_anisotropy_terms", this, &PureMetal::task_time_advance_anisotropy_terms );
+    task->requires ( Task::OldDW, grad_psi_norm2_label, Ghost::None, 0 );
+    for ( size_t d = 0; d < DIM; ++d )
+        task->requires ( Task::OldDW, grad_psi_label[d], Ghost::None, 0 );
+    task->computes ( a_label );
+    task->computes ( a2_label );
+    for ( size_t d = 0; d < BSZ; ++d )
+        task->computes ( b_label[d] );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleTimeAdvance_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_time_advance_solution", this, &PureMetal::task_time_advance_solution );
+    task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::OldDW, psi_label, FGT, FGN );
+    task->requires ( Task::OldDW, u_label, FGT, FGN );
+    for ( size_t d = 0; d < DIM; ++d )
+        task->requires ( Task::OldDW, grad_psi_label[d], Ghost::None, 0 );
+    task->requires ( Task::NewDW, a_label, Ghost::None, 0 );
+    task->requires ( Task::NewDW, a2_label, FGT, FGN );
+    for ( size_t d = 0; d < BSZ; ++d )
+        task->requires ( Task::NewDW, b_label[d], FGT, FGN );
+    task->computes ( psi_label );
+    task->computes ( u_label );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleTimeAdvance_solution (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    if ( !level->hasCoarserLevel() ) scheduleTimeAdvance_solution < !MG > ( level, sched );
+    else
+    {
+        Task * task = scinew Task ( "PureMetal::task_time_advance_solution", this, &PureMetal::task_time_advance_solution );
+        task->requires ( Task::OldDW, subproblems_label, Ghost::None, 0 );
+        task->requires ( Task::OldDW, subproblems_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->requires ( Task::OldDW, psi_label, FGT, FGN );
+        task->requires ( Task::OldDW, psi_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        for ( size_t d = 0; d < DIM; ++d )
+            task->requires ( Task::OldDW, grad_psi_label[d], Ghost::None, 0 );
+        task->requires ( Task::OldDW, u_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->requires ( Task::OldDW, u_label, FGT, FGN );
+        task->requires ( Task::OldDW, u_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->requires ( Task::NewDW, a_label, Ghost::None, 0 );
+        task->requires ( Task::NewDW, a2_label, FGT, FGN );
+        task->requires ( Task::NewDW, a2_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        for ( size_t d = 0; d < BSZ; ++d )
+        {
+            task->requires ( Task::NewDW, b_label[d], FGT, FGN );
+            task->requires ( Task::NewDW, b_label[d], nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        }
+        task->computes ( psi_label );
+        task->computes ( u_label );
+        sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleRefine
+(
+    const PatchSet * new_patches,
+    SchedulerP & sched
+)
+{
+    cout_pure_metal_scheduling << "scheduleRefine on: " << *new_patches << std::endl;
+
+    const Level * level = getLevel ( new_patches );
+    const GridP & grid = level->getGrid();
+
+    // we need to create subproblems for new patches.
+    // moreover, since SchedulerCommon::copyDataToNewGrid is not copying PerPatch
+    // variable to the new grid (which is fine since the geometry -thus the subproblems-
+    // has changed) we need to schedule their creation within scheduleRefine/scheduleRefineInterface
+    // since this tasks are compiled separately from those scheduled by scheduleTimeAdvance
+    if ( is_first_schedule_refine )
+    {
+        scheduleRefine_subproblems ( grid, sched );
+        is_first_schedule_refine = false;
+    };
+
+    // no need to refine on coarser level
+    if ( level->hasCoarserLevel() )
+    {
+        scheduleRefine_solution ( new_patches, sched );
+        scheduleRefine_grad_psi ( new_patches, sched );
+    }
+}
+
+/**
+ * @remark we need to schedule all levels before task_error_estimate_grad_psi
+ * to avoid the error "Failure finding [subproblems , coarseLevel, MI: none, NewDW
+ * (mapped to dw index 1), ####] for PureMetal::task_error_estimate_grad_psi",
+ * on patch #, Level #, on material #, resource (rank): #" while compiling the
+ * TaskGraph
+ */
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleRefine_subproblems (
+    const GridP & grid,
+    SchedulerP & sched
+)
+{
+    cout_pure_metal_scheduling << "scheduleRefine_subproblems" << std::endl;
+
+    for ( int l = 0; l < grid->numLevels(); ++l )
+    {
+        Task * task = scinew Task ( "PureMetal::task_initialize_subproblems", this, &PureMetal::task_initialize_subproblems );
+        task->computes ( subproblems_label );
+        sched->addTask ( task, grid->getLevel ( l )->eachPatch(), this->m_materialManager->allMaterials() );
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleRefine_solution (
+    const PatchSet * patches,
+    SchedulerP & sched
+)
+{
+    cout_pure_metal_scheduling << "scheduleRefine_solution on: " << *patches << std::endl;
+
+    Task * task = scinew Task ( "PureMetal::task_refine_solution", this, &PureMetal::task_refine_solution );
+    task->requires ( Task::NewDW, psi_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+    task->requires ( Task::NewDW, u_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+    task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::NewDW, subproblems_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+    task->computes ( psi_label );
+    task->computes ( u_label );
+    sched->addTask ( task, patches, this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleRefine_grad_psi (
+    const PatchSet * patches,
+    SchedulerP & sched
+)
+{
+    cout_pure_metal_scheduling << "scheduleRefine_grad_psi on: " << *patches << std::endl;
+
+    Task * task = scinew Task ( "PureMetal::task_refine_grad_psi", this, &PureMetal::task_refine_grad_psi );
+    task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::NewDW, psi_label, nullptr, Task::ThisLevel, nullptr, Task::NormalDomain, FGT, FGN );
+    task->computes ( grad_psi_norm2_label );
+    for ( size_t d = 0; d < DIM; ++d )
+        task->computes ( grad_psi_label[d] );
+    sched->addTask ( task, patches, this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleRefineInterface (
+    const LevelP & /*level_fine*/,
+    SchedulerP & /*sched*/,
+    bool /*need_old_coarse*/,
+    bool /*need_new_coarse*/
+)
+{};
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleCoarsen
+(
+    const LevelP & level_coarse,
+    SchedulerP & sched
+)
+{
+    scheduleCoarsen_solution ( level_coarse, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleCoarsen_solution (
+    const LevelP & level_coarse,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_coarsen_solution", this, &PureMetal::task_coarsen_solution );
+    task->requires ( Task::NewDW, psi_label, nullptr, Task::FineLevel, nullptr, Task::NormalDomain, Ghost::None, 0 );
+    task->requires ( Task::NewDW, u_label, nullptr, Task::FineLevel, nullptr, Task::NormalDomain, Ghost::None, 0 );
+    task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::NewDW, subproblems_label, nullptr, Task::FineLevel, nullptr, Task::NormalDomain, Ghost::None, 0 );
+    task->modifies ( psi_label );
+    task->modifies ( u_label );
+    sched->addTask ( task, level_coarse->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::scheduleErrorEstimate
+(
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    scheduleErrorEstimate_grad_psi<AMR> ( level, sched );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < !MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleErrorEstimate_grad_psi (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    Task * task = scinew Task ( "PureMetal::task_error_estimate_grad_psi", this, &PureMetal::task_error_estimate_grad_psi );
+    task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+    task->requires ( Task::NewDW, psi_label, FGT, FGN );
+    task->modifies ( this->m_regridder->getRefineFlagLabel(), this->m_regridder->refineFlagMaterials() );
+    task->modifies ( this->m_regridder->getRefinePatchFlagLabel(), this->m_regridder->refineFlagMaterials() );
+    task->computes ( grad_psi_norm2_label );
+    for ( size_t d = 0; d < DIM; ++d )
+        task->computes ( grad_psi_label[d] );
+    sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+template < bool MG >
+typename std::enable_if < MG, void >::type
+PureMetal<VAR, DIM, STN, AMR>::scheduleErrorEstimate_grad_psi (
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    if ( !level->hasCoarserLevel() ) scheduleErrorEstimate_grad_psi < !MG > ( level, sched );
+    else
+    {
+        Task * task = scinew Task ( "PureMetal::task_error_estimate_grad_psi", this, &PureMetal::task_error_estimate_grad_psi );
+        task->requires ( Task::NewDW, subproblems_label, Ghost::None, 0 );
+        task->requires ( Task::NewDW, subproblems_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->requires ( Task::NewDW, psi_label, FGT, FGN );
+        task->requires ( Task::NewDW, psi_label, nullptr, Task::CoarseLevel, nullptr, Task::NormalDomain, CGT, CGN );
+        task->modifies ( this->m_regridder->getRefineFlagLabel(), this->m_regridder->refineFlagMaterials() );
+        task->modifies ( this->m_regridder->getRefinePatchFlagLabel(), this->m_regridder->refineFlagMaterials() );
+        task->computes ( grad_psi_norm2_label );
+        for ( size_t d = 0; d < DIM; ++d )
+            task->computes ( grad_psi_label[d] );
+        sched->addTask ( task, level->eachPatch(), this->m_materialManager->allMaterials() );
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void PureMetal<VAR, DIM, STN, AMR>::scheduleInitialErrorEstimate
+(
+    const LevelP & level,
+    SchedulerP & sched
+)
+{
+    scheduleErrorEstimate ( level, sched );
+}
+
+// TASKS
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_initialize_subproblems (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset * /*matls*/,
+    DataWarehouse * /*dw_old*/,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_initialize_subproblems ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        Variable < PP, SubProblems < PureMetalProblem<VAR, STN> > > subproblems;
+        subproblems.setData ( scinew SubProblems < PureMetalProblem<VAR, STN> > ( this, psi_label, u_label, a2_label, b_label, subproblems_label, material, patch, &c2f ) );
+        dw_new->put ( subproblems, subproblems_label, material, patch );
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_initialize_solution (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset * /*matls*/,
+    DataWarehouse * /*dw_old*/,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_initialize_solution ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << std::endl;
+
+        // Allocate solution variables into the new DataWarehouse
+        DWView < ScalarField<double>, VAR, DIM > psi ( dw_new, psi_label, material, patch );
+        DWView < ScalarField<double>, VAR, DIM > u ( dw_new, u_label, material, patch );
+
+        // Get patch range
+        BlockRange range ( this->get_range ( patch ) );
+        dbg_out3 << myrank << "= Iterating over range " << range << std::endl;
+
+        // Initialize solution variables in range
+        parallel_for ( range, [patch, &psi, &u, this] ( int i, int j, int k )->void { initialize_solution ( {i, j, k}, patch, psi, u ); } );
+
+        // Allocate anisotropy terms variables into the new DataWarehouse
+        DWView < ScalarField<double>, VAR, DIM > a ( dw_new, a_label, material, patch );
+        DWView < ScalarField<double>, VAR, DIM > a2 ( dw_new, a2_label, material, patch );
+        DWView < VectorField<double, BSZ>, VAR, DIM > b ( dw_new, b_label, material, patch );
+
+        // Initialize anisotropy terms variables
+        a.initialize ( 0. );
+        a2.initialize ( 0. );
+        b.initialize ( 0. );
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_initialize_grad_psi (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset * /*matls*/,
+    DataWarehouse * /*dw_old*/,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_initialize_grad_psi ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << std::endl;
+
+        // Allocate grad_psi and grad_psi_norm2 variables into the new DataWarehouse
+        DWView < ScalarField<double>, VAR, DIM > grad_psi_norm2 ( dw_new, grad_psi_norm2_label, material, patch );
+        DWView < VectorField<double, DIM>, VAR, DIM > grad_psi ( dw_new, grad_psi_label, material, patch );
+
+        // Retrieve subproblems from the DataWarehouse
+        Variable < PP, SubProblems < PureMetalProblem<VAR, STN> > > subproblems;
+        dw_new->get ( subproblems, subproblems_label, material, patch );
+        const auto * problems = subproblems.get().get_rep();
+
+        // Iterate over each subproblem
+        for ( const auto & p : *problems )
+        {
+            // Get a view of psi that implements finite differences approximations
+            dbg_out3 << myrank << "= Iterating over " << p << std::endl;
+            FDView < ScalarField<const double>, STN > & psi = p.template get_fd_view<PSI> ( dw_new );
+
+            // Compute psi derivatives on subproblem range
+            parallel_for ( p.get_range(), [patch, &psi, &grad_psi, &grad_psi_norm2, this] ( int i, int j, int k )->void { time_advance_grad_psi ( {i, j, k}, psi, grad_psi, grad_psi_norm2 ); } );
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_compute_stable_timestep (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse *,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_compute_stable_timestep ====" << std::endl;
+
+    dw_new->put ( delt_vartype ( delt ), this->getDelTLabel(), getLevel ( patches ) );
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_time_advance_subproblems (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== PureMetal::task_time_advance_subproblems ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        if ( dw_old->exists ( subproblems_label, material, patch ) )
+        {
+            Variable < PP, SubProblems < PureMetalProblem<VAR, STN> > > subproblems;
+            dw_old->get ( subproblems, subproblems_label, material, patch );
+            dw_new->put ( subproblems, subproblems_label, material, patch );
+            dbg_out4 << "subproblems moved from OldDW to NewDW" << std::endl;
+        }
+        else // after a regrid all patches are new thus subproblems does not exists in old db
+            // not bad since we want re recompute them!
+        {
+            auto * problems = scinew SubProblems < PureMetalProblem<VAR, STN> > ( this, psi_label, u_label, a2_label, b_label, subproblems_label, material, patch, &c2f );
+
+            Variable < PP, SubProblems < PureMetalProblem<VAR, STN> > > subproblems;
+            subproblems.setData ( problems );
+            dw_new->put ( subproblems, subproblems_label, material, patch );
+            dbg_out4 << "subproblems initialized in NewDW" << std::endl;
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_time_advance_grad_psi (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_time_advance_grad_psi ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << std::endl;
+
+        DWView < ScalarField<double>, VAR, DIM > grad_psi_norm2 ( dw_new, grad_psi_norm2_label, material, patch );
+        DWView < VectorField<double, DIM>, VAR, DIM > grad_psi ( dw_new, grad_psi_label, material, patch );
+
+        Variable < PP, SubProblems < PureMetalProblem<VAR, STN> > > subproblems;
+        dw_new->get ( subproblems, subproblems_label, material, patch );
+        auto problems = subproblems.get().get_rep();
+
+        for ( const auto & p : *problems )
+        {
+            dbg_out3 << myrank << "= Iterating over " << p << std::endl;
+            FDView < ScalarField<const double>, STN > & psi = p.template get_fd_view<PSI> ( dw_old );
+            parallel_for ( p.get_range(), [patch, &psi, &grad_psi, &grad_psi_norm2, this] ( int i, int j, int k )->void { time_advance_grad_psi ( {i, j, k}, psi, grad_psi, grad_psi_norm2 ); } );
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_time_advance_anisotropy_terms (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_time_advance_anisotropy_terms ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << std::endl;
+
+        DWView < ScalarField<const double>, VAR, DIM > grad_psi_norm2 ( dw_old, grad_psi_norm2_label, material, patch );
+        DWView < VectorField<const double, DIM>, VAR, DIM > grad_psi ( dw_old, grad_psi_label, material, patch );
+
+        DWView < ScalarField<double>, VAR, DIM > a ( dw_new, a_label, material, patch );
+        DWView < ScalarField<double>, VAR, DIM > a2 ( dw_new, a2_label, material, patch );
+        DWView < VectorField<double, BSZ>, VAR, DIM > b ( dw_new, b_label, material, patch );
+
+        BlockRange range ( this->get_range ( patch ) );
+        dbg_out3 << myrank << "= Iterating over range " << range << std::endl;
+        parallel_for ( range, [&grad_psi, &grad_psi_norm2, &a, &a2, &b, this] ( int i, int j, int k )->void { time_advance_anisotropy_terms ( {i, j, k}, grad_psi, grad_psi_norm2, a, a2, b ); } );
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_time_advance_solution (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset *,
+    DataWarehouse * dw_old,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_time_advance_solution ====" << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << std::endl;
+
+        DWView < VectorField<const double, DIM>, VAR, DIM > grad_psi ( dw_old, grad_psi_label, material, patch );
+        DWView < ScalarField<const double>, VAR, DIM > a ( dw_new, a_label, material, patch );
+
+        DWView < ScalarField<double>, VAR, DIM > psi_new ( dw_new, psi_label, material, patch );
+        DWView < ScalarField<double>, VAR, DIM > u_new ( dw_new, u_label, material, patch );
+
+        Variable < PP, SubProblems < PureMetalProblem<VAR, STN> > > subproblems;
+        dw_new->get ( subproblems, subproblems_label, material, patch );
+        auto problems = subproblems.get().get_rep();
+
+        for ( const auto & p : *problems )
+        {
+            dbg_out3 << myrank << "= Iterating over " << p << std::endl;
+            FDView < ScalarField<const double>, STN > & psi_old = p.template get_fd_view<PSI> ( dw_old );
+            FDView < ScalarField<const double>, STN > & u_old = p.template get_fd_view<U> ( dw_old );
+            FDView < ScalarField<const double>, STN > & a2 = p.template get_fd_view<A2> ( dw_new );
+            FDView < VectorField<const double, BSZ>, STN > b = p.template get_fd_view<B> ( dw_new );
+            parallel_for ( p.get_range(), [&psi_old, &u_old, &grad_psi, &a, &a2, &b, &psi_new, &u_new, this] ( int i, int j, int k )->void { time_advance_solution ( {i, j, k}, psi_old, u_old, grad_psi, a, a2, b, psi_new, u_new ); } );
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_refine_solution
+(
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches_fine,
+    const MaterialSubset * ,
+    DataWarehouse * ,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== PureMetal::task_refine_solution ====" << std::endl;
+
+    for ( int p = 0; p < patches_fine->size(); ++p )
+    {
+        const Patch * patch_fine = patches_fine->get ( p );
+        dbg_out2 << myrank << "== Fine Patch: " << *patch_fine << " Level: " << patch_fine->getLevel()->getIndex() << std::endl;
+
+        DWView < ScalarField<double>, VAR, DIM > psi_fine ( dw_new, psi_label, material, patch_fine );
+        DWView < ScalarField<double>, VAR, DIM > u_fine ( dw_new, u_label, material, patch_fine );
+
+        AMRInterpolator < PureMetalProblem<VAR, STN>, PSI, C2F > psi_coarse_interp ( dw_new, psi_label, subproblems_label, material, patch_fine );
+        AMRInterpolator < PureMetalProblem<VAR, STN>, U, C2F > u_coarse_interp ( dw_new, u_label, subproblems_label, material, patch_fine );
+
+        BlockRange range_fine ( this->get_range ( patch_fine ) );
+        dbg_out3 << myrank << "= Iterating over fine range" << range_fine << std::endl;
+        parallel_for ( range_fine, [&psi_coarse_interp, &u_coarse_interp, &psi_fine, &u_fine, this] ( int i, int j, int k )->void { refine_solution ( {i, j, k}, psi_coarse_interp, u_coarse_interp, psi_fine, u_fine ); } );
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_refine_grad_psi
+(
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches_fine,
+    const MaterialSubset * ,
+    DataWarehouse * ,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_refine_grad_psi ====" << std::endl;
+
+    for ( int p = 0; p < patches_fine->size(); ++p )
+    {
+        const Patch * patch_fine = patches_fine->get ( p );
+        dbg_out2 << myrank << "== Fine Patch: " << *patch_fine << " Level: " << patch_fine->getLevel()->getIndex() << std::endl;
+
+        DWView < ScalarField<double>, VAR, DIM > grad_psi_norm2 ( dw_new, grad_psi_norm2_label, material, patch_fine );
+        DWView < VectorField<double, DIM>, VAR, DIM > grad_psi ( dw_new, grad_psi_label, material, patch_fine );
+
+        Variable < PP, SubProblems < PureMetalProblem<VAR, STN> > > subproblems;
+        dw_new->get ( subproblems, subproblems_label, material, patch_fine );
+        auto problems = subproblems.get().get_rep();
+
+        for ( const auto & p : *problems )
+        {
+            dbg_out3 << myrank << "= Iterating over " << p << std::endl;
+            FDView < ScalarField<const double>, STN > & psi = p.template get_fd_view<PSI> ( dw_new );
+            parallel_for ( p.get_range(), [patch_fine, &psi, &grad_psi, &grad_psi_norm2, this] ( int i, int j, int k )->void { time_advance_grad_psi ( {i, j, k}, psi, grad_psi, grad_psi_norm2 ); } );
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_coarsen_solution (
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches_coarse,
+    const MaterialSubset * ,
+    DataWarehouse * ,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+    dbg_out1 << myrank << "==== PureMetal::task_coarsen_solution " << std::endl;
+
+    for ( int p = 0; p < patches_coarse->size(); ++p )
+    {
+        const Patch * patch_coarse = patches_coarse->get ( p );
+        dbg_out2 << myrank << "== Coarse Patch: " << *patch_coarse << " Level: " << patch_coarse->getLevel()->getIndex() << std::endl;
+
+        DWView < ScalarField<double>, VAR, DIM > psi_coarse ( dw_new, psi_label, material, patch_coarse );
+        DWView < ScalarField<double>, VAR, DIM > u_coarse ( dw_new, u_label, material, patch_coarse );
+
+        AMRRestrictor < PureMetalProblem<VAR, STN>, PSI, F2C > psi_fine_restr ( dw_new, psi_label, subproblems_label, material, patch_coarse, false );
+        AMRRestrictor < PureMetalProblem<VAR, STN>, U, F2C > u_fine_restr ( dw_new, u_label, subproblems_label, material, patch_coarse, false );
+
+        for ( const auto & region : u_fine_restr.get_support() )
+        {
+            dbg_out3 << myrank << "= Iterating over coarse cells region " << region << std::endl;
+            BlockRange range_coarse (
+                Max ( region.getLow(), this->get_low ( patch_coarse ) ),
+                Min ( region.getHigh(), this->get_high ( patch_coarse ) )
+            );
+
+            parallel_for ( range_coarse, [&psi_fine_restr, &u_fine_restr, &psi_coarse, &u_coarse, this] ( int i, int j, int k )->void { coarsen_solution ( {i, j, k}, psi_fine_restr, u_fine_restr, psi_coarse, u_coarse ); } );
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::task_error_estimate_grad_psi
+(
+    const ProcessorGroup * myworld,
+    const PatchSubset * patches,
+    const MaterialSubset * ,
+    DataWarehouse * ,
+    DataWarehouse * dw_new
+)
+{
+    int myrank = myworld->myRank();
+
+    dbg_out1 << myrank << "==== PureMetal::task_error_estimate_grad_psi " << std::endl;
+
+    for ( int p = 0; p < patches->size(); ++p )
+    {
+        const Patch * patch = patches->get ( p );
+        dbg_out2 << myrank << "== Patch: " << *patch << " Level: " << patch->getLevel()->getIndex() << std::endl;
+
+        PerPatch<PatchFlagP> refine_patch_flag;
+        dw_new->get ( refine_patch_flag, this->m_regridder->getRefinePatchFlagLabel(), material, patch );
+
+        PatchFlag * patch_flag_refine = refine_patch_flag.get().get_rep();
+
+        bool refine_patch = false;
+
+        DWView < ScalarField<double>, VAR, DIM > grad_psi_norm2 ( dw_new, grad_psi_norm2_label, material, patch );
+        DWView < VectorField<double, DIM>, VAR, DIM > grad_psi ( dw_new, grad_psi_label, material, patch );
+        DWView < ScalarField<int>, CC, DIM > refine_flag ( dw_new, this->m_regridder->getRefineFlagLabel(), material, patch );
+
+        Variable<PP, SubProblems < PureMetalProblem<VAR, STN> > > subproblems;
+        dw_new->get ( subproblems, subproblems_label, material, patch );
+
+        auto problems = subproblems.get().get_rep();
+
+        for ( const auto & p : *problems )
+        {
+            dbg_out3 << myrank << "= Iterating over " << p << std::endl;
+            FDView < ScalarField<const double>, STN > & psi = p.template get_fd_view<PSI> ( dw_new );
+            parallel_reduce_sum ( p.get_range(), [&psi, &grad_psi, &grad_psi_norm2, &refine_flag, &refine_patch, this] ( int i, int j, int k, bool & refine_patch )->void { error_estimate_grad_psi ( {i, j, k}, psi, grad_psi, grad_psi_norm2, refine_flag, refine_patch ); }, refine_patch );
+        }
+
+        if ( refine_patch )
+        {
+            dbg_out3 << myrank << "= Setting refine flag" << std::endl;
+            patch_flag_refine->set();
+        }
+    }
+
+    dbg_out2 << myrank << std::endl;
+}
+
+// IMPLEMENTATIONS
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::initialize_solution (
+    const IntVector & id,
+    const Patch * patch,
+    View < ScalarField<double> > & psi,
+    View < ScalarField<double> > & u
+)
+{
+    Vector v ( this->get_position ( patch, id ).asVector() );
+
+    // BUG workaround
+    std::stringstream ss;
+    ss << v << std::endl;
+
+    double r2 = 0;
+
+    for ( size_t d = 0; d < DIM; ++d )
+        r2 += v[d] * v[d];
+
+    double tmp = r2 - r0 * r0;
+
+    psi[id] = - tanh ( gamma_psi * tmp );
+    u[id] = -delta * ( 1. + tanh ( gamma_u * tmp ) ) / 2.;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::time_advance_grad_psi (
+    const IntVector & id,
+    FDView < ScalarField<const double>, STN > & psi,
+    View < VectorField<double, DIM> > & grad_psi,
+    View < ScalarField<double> > & grad_psi_norm2
+)
+{
+    auto grad = psi.gradient ( id );
+
+    grad_psi_norm2[id] = 0;
+    for ( size_t d = 0; d < DIM; ++d )
+    {
+        grad_psi[d][id] = grad[d];
+        grad_psi_norm2[id] += grad[d] * grad[d];
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void PureMetal<VAR, DIM, STN, AMR>::time_advance_anisotropy_terms (
+    const IntVector & id,
+    View < VectorField<const double, DIM> > & grad_psi,
+    View < ScalarField<const double> > & grad_psi_norm2,
+    View < ScalarField<double> > & a,
+    View < ScalarField<double> > & a2,
+    View < VectorField<double, BSZ> > & b
+)
+{
+    double tmp = 1. + epsilon;
+    double n2 = grad_psi_norm2[id];
+    if ( n2 < tol )
+    {
+        a[id] = tmp;
+        a2[id] = tmp * tmp;
+        for ( size_t d = 0; d < BSZ; ++d )
+            b[d][id] = 0.;
+    }
+    else
+    {
+        double n4 = n2 * n2;
+
+        double tmp4 = 0.;
+        double grad[DIM], grad2[DIM];
+        for ( size_t d = 0; d < BSZ; ++d )
+        {
+            grad[d] = grad_psi[d][id];
+            grad2[d] = grad[d] * grad[d];
+            tmp4 += grad2[d] * grad2[d];
+        }
+        tmp4 *= 4. / n4;
+
+        double tmp = 1. + epsilon * ( tmp4 - 3. );
+        a[id] = tmp;
+        a2[id] = tmp * tmp;
+        if ( DIM > 1 )
+        {
+            b[XY][id] = 16. * epsilon * tmp * ( grad[X] * grad[Y] )  * ( grad2[X] - grad2[Y] ) / n4;
+        }
+        if ( DIM > 2 ) // Compile time if
+        {
+            b[XZ][id] = 16. * epsilon * tmp * ( grad[X] * grad[Z] ) * ( grad2[X] - grad2[Z] ) / n4;
+            b[YZ][id] = 16. * epsilon * tmp * ( grad[Y] * grad[Z] ) * ( grad2[Y] - grad2[Z] ) / n4;
+        }
+    }
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::time_advance_solution (
+    const IntVector & id,
+    FDView < ScalarField<const double>, STN > & psi_old,
+    FDView < ScalarField<const double>, STN > & u_old,
+    View < VectorField<const double, DIM> > & grad_psi,
+    View < ScalarField<const double> > & a,
+    FDView < ScalarField<const double>, STN > & a2,
+    FDView < VectorField<const double, BSZ>, STN > & b,
+    View < ScalarField<double> > & psi_new,
+    View < ScalarField<double> > & u_new
+)
+{
+    double source = 1. - psi_old[id] * psi_old[id];
+    source *= ( psi_old[id] - lambda * u_old[id] * source );
+
+    double delta_psi = 0;
+
+    if ( DIM == 2 )
+    {
+        delta_psi = delt * ( psi_old.laplacian ( id ) * a2[id]
+                             + ( a2.dx ( id ) - b[XY].dy ( id ) ) * grad_psi[X][id]
+                             + ( a2.dy ( id ) + b[XY].dx ( id ) ) * grad_psi[Y][id]
+                             + source ) / a[id];
+
+    }
+    if ( DIM == 3 )
+        delta_psi = delt * ( psi_old.laplacian ( id ) * a2[id]
+                             + ( a2.dx ( id ) - b[XY].dy ( id ) - b[XZ].dz ( id ) ) * grad_psi[X][id]
+                             + ( a2.dy ( id ) + b[XY].dx ( id ) - b[YZ].dz ( id ) ) * grad_psi[Y][id]
+                             + ( a2.dz ( id ) + b[XZ].dx ( id ) + b[YZ].dy ( id ) ) * grad_psi[Z][id]
+                             + source ) / a[id];
+
+    double delta_u = delt * u_old.laplacian ( id ) * alpha + delta_psi / 2.;
+
+    psi_new[id] = psi_old[id] + delta_psi;
+    u_new[id] = u_old[id] + delta_u;
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::refine_solution
+(
+    const IntVector id_fine,
+    const View < ScalarField<const double> > & psi_coarse_interp,
+    const View < ScalarField<const double> > & u_coarse_interp,
+    View < ScalarField<double> > & psi_fine,
+    View < ScalarField<double> > & u_fine
+)
+{
+    psi_fine[id_fine] = psi_coarse_interp[id_fine];
+    u_fine[id_fine] = u_coarse_interp[id_fine];
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::coarsen_solution
+(
+    const IntVector id_coarse,
+    const View < ScalarField<const double> > & psi_fine_restr,
+    const View < ScalarField<const double> > & u_fine_restr,
+    View < ScalarField<double> > & psi_coarse,
+    View < ScalarField<double> > & u_coarse
+)
+{
+    psi_coarse[id_coarse] = psi_fine_restr[id_coarse];
+    u_coarse[id_coarse] = u_fine_restr[id_coarse];
+}
+
+template<VarType VAR, DimType DIM, StnType STN, bool AMR>
+void
+PureMetal<VAR, DIM, STN, AMR>::error_estimate_grad_psi (
+    const IntVector & id,
+    FDView < ScalarField<const double>, STN > & psi,
+    View < VectorField<double, DIM> > & grad_psi,
+    View < ScalarField<double> > & grad_psi_norm2,
+    View< ScalarField<int> > & refine_flag,
+    bool & refine_patch
+)
+{
+    bool refine = false;
+    auto grad = psi.gradient ( id );
+
+    grad_psi_norm2[id] = 0;
+    for ( size_t d = 0; d < DIM; ++d )
+    {
+        grad_psi[d][id] = grad[d];
+        grad_psi_norm2[id] += grad[d] * grad[d];
+    }
+
+    refine = grad_psi_norm2[id] > refine_threshold * refine_threshold;
+    refine_flag[id] = refine;
+    refine_patch |= refine;
+}
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Applications_PureMetal_h
diff --git a/src/CCA/Components/PhaseField/Applications/sub.mk b/src/CCA/Components/PhaseField/Applications/sub.mk
new file mode 100644
index 00000000..b3ccd418
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Applications/sub.mk
@@ -0,0 +1,34 @@
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+#
+#
+#
+#
+# Makefile fragment for this subdirectory
+
+SRCDIR := CCA/Components/PhaseField/Applications
+
+SRCS += \
+  $(SRCDIR)/ApplicationFactory.cc \
+  $(SRCDIR)/PureMetal.cc \
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView-bld.sh b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView-bld.sh
new file mode 100755
index 00000000..2649d63d
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView-bld.sh
@@ -0,0 +1,279 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+VARs=(CC NC)
+STNs=(P5 P7)
+DIMs=(2 3)
+PPPs=(
+  "PureMetalProblem"
+  "PureMetalProblem"
+)
+NFFs=(
+  "4"
+  "4"
+)
+DIRs=(x y z)
+SIGNs=(minus plus)
+BCs=(Dirichlet Neumann)
+
+SS=""
+VV=""
+PP=""
+
+POSITIONAL=()
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    -v|--var)
+    VARs=("$2")
+    VV="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -s|--stn)
+    SS="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -p|--pb)
+    PP="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    *)    # unknown option
+    POSITIONAL+=("$1") # save it in an array for later
+    shift # past argument
+    ;;
+esac
+done
+set -- "${POSITIONAL[@]}" # restore positional parameters
+
+if [ -n "${SS}" ]; then
+  FOUND=0
+  for ((s=0; s<${#STNs[@]}; s++)); do
+    if [ "${SS}" == "${STNs[s]}" ]; then
+      STNs=("${STNs[s]}");
+      DIMs=("${DIMs[s]}");
+      PPPs=("${PPPs[s]}");
+      NFFs=("${NFFs[s]}");
+      FOUND=1
+    fi
+  done
+  if [[ $FOUND -eq 0 ]]; then
+    >&2 echo "cannot find the stencil"
+    exit
+  fi
+fi
+
+if [ -n "${PP}" ]; then
+  for ((pp=0; pp<${#PPPs[@]}; pp++)); do
+    FOUND=0
+    IFS=';' read -r -a PPs <<< "${PPPs[pp]}"
+    IFS=';' read -r -a NFs <<< "${NFFs[pp]}"
+    for ((p=0; p<${#PPs[@]}; p++)); do
+      if [ "${PP}" == "${PPs[p]}" ]; then
+        PPPs[pp]="${PPs[p]}";
+        NFFs[pp]="${NFs[p]}";
+        FOUND=1
+      fi
+    done
+    if [[ $FOUND -eq 0 ]]; then
+      PPPs[pp]="";
+      NFFs[pp]="";
+    fi
+  done
+fi
+
+PBS=()
+for ((pp=0; pp<${#PPPs[@]}; pp++)); do
+  IFS=';' read -r -a PPs <<< "${PPPs[pp]}"
+  for ((p=0; p<${#PPs[@]}; p++)); do
+    FOUND=0
+    for ((q=0; q<${#PBS[@]}; q++)); do
+      if [ "${PPs[p]}" == "${PBS[q]}" ]; then
+        FOUND=1
+      fi
+    done
+    if [[ $FOUND -eq 0 ]]; then
+      PBS+=("${PPs[p]}")
+    fi
+  done
+done
+
+SRC=${0%-bld.sh}${PP}${VV}${SS}-bld.cc
+
+echo "generating $SRC"
+
+echo '/*' > $SRC
+echo ' * The MIT License' >> $SRC
+echo ' *' >> $SRC
+echo ' * Copyright (c) 1997-2018 The University of Utah' >> $SRC
+echo ' *' >> $SRC
+echo ' * Permission is hereby granted, free of charge, to any person obtaining a copy' >> $SRC
+echo ' * of this software and associated documentation files (the "Software"), to' >> $SRC
+echo ' * deal in the Software without restriction, including without limitation the' >> $SRC
+echo ' * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or' >> $SRC
+echo ' * sell copies of the Software, and to permit persons to whom the Software is' >> $SRC
+echo ' * furnished to do so, subject to the following conditions:' >> $SRC
+echo ' *' >> $SRC
+echo ' * The above copyright notice and this permission notice shall be included in' >> $SRC
+echo ' * all copies or substantial portions of the Software.' >> $SRC
+echo ' *' >> $SRC
+echo ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' >> $SRC
+echo ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' >> $SRC
+echo ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' >> $SRC
+echo ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' >> $SRC
+echo ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING' >> $SRC
+echo ' * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS' >> $SRC
+echo ' * IN THE SOFTWARE.' >> $SRC
+echo ' */' >> $SRC
+echo '' >> $SRC
+for PB in ${PBS[@]}; do
+  echo '#include <CCA/Components/PhaseField/DataTypes/'$PB'.h>' >> $SRC
+done
+echo '#include <CCA/Components/PhaseField/BoundaryConditions/BCFDView.h>' >> $SRC
+echo '#include <CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory.h>' >> $SRC
+echo '' >> $SRC
+echo 'namespace Uintah {' >> $SRC
+echo 'namespace PhaseField {' >> $SRC
+echo '' >> $SRC
+
+for VAR in ${VARs[@]}; do
+  for ((s=0; s<${#STNs[@]}; s++)); do
+    STN="${STNs[s]}"
+    DIM="${DIMs[s]}"
+    IFS=';' read -r -a PPs <<< "${PPPs[s]}"
+    IFS=';' read -r -a NFs <<< "${NFFs[s]}"
+    for ((n=0; n<${#PPs[@]}; n++)); do
+      PP="${PPs[n]}"
+      NF="${NFs[n]}"
+      PB="$PP<$VAR, $STN>"
+      for ((f=0; f<$NF; f++)); do
+        I=$f
+
+        for ((d0=0; d0<$DIM; d0++)); do
+          DIR0="${DIRs[d0]}"
+          for SIGN0 in "${SIGNs[@]}"; do
+            F0=$DIR0$SIGN0
+
+            for BC0 in "${BCs[@]}"; do
+              P0="Patch::$F0 | BC::$BC0"
+              echo "template<> const std::string BCFDView < $PB, $I, $P0 >::Name = \"$PP|$I|$VAR|$F0|$BC0|\";" >> $SRC
+
+              for ((d1=d0+1; d1<$DIM; d1++)); do
+                DIR1="${DIRs[d1]}"
+                for SIGN1 in "${SIGNs[@]}"; do
+                  F1=$DIR1$SIGN1
+                  for BC1 in "${BCs[@]}"; do
+                    P1="Patch::$F1 | BC::$BC1"
+                    echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1 >::Name = \"$PP|$I|$VAR|$F0|$BC0|$F1|$BC1|\";" >> $SRC
+
+                    for ((d2=d1+1; d2<$DIM; d2++)); do
+                      DIR2="${DIRs[d2]}"
+                      for SIGN2 in "${SIGNs[@]}"; do
+                        F2=$DIR2$SIGN2
+                        for BC2 in "${BCs[@]}"; do
+                          P2="Patch::$F2 | BC::$BC2"
+                          echo "template<> const std::string BCFDView < $PB, $I, $P0, $P1, $P2 >::Name = \"$PP|$I|$VAR|$F0|$BC0|$F1|$BC1|$F2|$BC2|\";" >> $SRC
+
+                        done
+                      done
+                    done
+
+                  done
+                done
+              done
+
+            done
+          done
+        done
+
+      done
+    done
+  done
+done
+
+echo "" >> $SRC
+
+for VAR in ${VARs[@]}; do
+  for ((s=0; s<${#STNs[@]}; s++)); do
+    STN="${STNs[s]}"
+    DIM="${DIMs[s]}"
+    IFS=';' read -r -a PPs <<< "${PPPs[s]}"
+    IFS=';' read -r -a NFs <<< "${NFFs[s]}"
+    for ((n=0; n<${#PPs[@]}; n++)); do
+      PB="${PPs[n]}<$VAR, $STN>"
+      NF="${NFs[n]}"
+      for ((f=0; f<$NF; f++)); do
+        I=$f
+
+        for ((d0=0; d0<$DIM; d0++)); do
+          DIR0="${DIRs[d0]}"
+          for SIGN0 in "${SIGNs[@]}"; do
+            F0=$DIR0$SIGN0
+
+            for BC0 in "${BCs[@]}"; do
+              P0="Patch::$F0 | BC::$BC0"
+              echo "template class BCFDView < $PB, $I, $P0 >;" >> $SRC
+
+              for ((d1=d0+1; d1<$DIM; d1++)); do
+                DIR1="${DIRs[d1]}"
+                for SIGN1 in "${SIGNs[@]}"; do
+                  F1=$DIR1$SIGN1
+                  for BC1 in "${BCs[@]}"; do
+                    P1="Patch::$F1 | BC::$BC1"
+                    echo "template class BCFDView < $PB, $I, $P0, $P1 >;" >> $SRC
+
+                    for ((d2=d1+1; d2<$DIM; d2++)); do
+                      DIR2="${DIRs[d2]}"
+                      for SIGN2 in "${SIGNs[@]}"; do
+                        F2=$DIR2$SIGN2
+                        for BC2 in "${BCs[@]}"; do
+                          P2="Patch::$F2 | BC::$BC2"
+                          echo "template class BCFDView < $PB, $I, $P0, $P1, $P2 >;" >> $SRC
+
+                        done
+                      done
+                    done
+
+                  done
+                done
+              done
+
+            done
+          done
+        done
+
+      done
+    done
+  done
+done
+
+echo "" >> $SRC
+
+echo '} // namespace Uintah' >> $SRC
+echo '} // namespace PhaseField' >> $SRC
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView.h b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView.h
new file mode 100644
index 00000000..772bfb8f
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDView.h
@@ -0,0 +1,140 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/BCFDView.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCFDView_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCFDView_h
+
+#include <CCA/Components/PhaseField/Factory/Implementation.h>
+#include <CCA/Components/PhaseField/Views/FDView.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bcfd_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Wrapper of DataWarehouse variables for both basic and complex
+ * differential operations at both physical and amr boundaries
+ *
+ * Factory Implementation for dynamic instantiation
+ *
+ * @tparam Problem type of PhaseField problem
+ * @tparam I index of Field within Problem
+ * @tparam P list of BC, FC, and Patch::Face packs
+ */
+template < typename Problem, size_t I, BCF... P >
+class BCFDView
+    : virtual public FDView < typename Problem::template get_field<I>::type, Problem::Stn >
+    , public Implementation < BCFDView<Problem, I, P...>, FDView < typename Problem::template get_field<I>::type, Problem::Stn >, const typename Problem::template get_field<I>::type::label_type &, const VarLabel *, int, const Level *, const std::vector < BCInfo < typename Problem::template get_field<I>::type > > & >
+    , public detail::bcfd_view< typename Problem::template get_field<I>::type, Problem::Stn, Problem, index_sequence<I>, P... >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = typename Problem::template get_field<I>::type;
+
+    /// Index of Field within Problem (first element is variable index, following
+    /// ones, if present, are the component index within the variable)
+    using Index = index_sequence<I>;
+
+private: // STATIC MEMBERS
+
+    /// Finite-difference stencil
+    static constexpr StnType STN = Problem::Stn;
+
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = true;
+
+    /// Implementation identifier within Factory
+    static const std::string Name;
+
+public: // CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components without gathering info from the DataWarehouse
+     *
+     * @param label list of variable labels for each component
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material material index
+     * @param level grid level
+     * @param bcs vector with info on the boundary conditions
+     */
+    BCFDView (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        const std::vector< BCInfo<Field> > & bcs
+    ) : detail::bcfd_view<Field, STN, Problem, Index, P...> ( label, subproblems_label, material, level, bcs )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch grid patch
+     * @param bcs vector with info on the boundary conditions
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    BCFDView (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        const std::vector< BCInfo<Field> > & bcs,
+        bool use_ghosts = use_ghosts_dflt
+    ) : detail::bcfd_view<Field, STN, Problem, Index, P...> ( dw, label, subproblems_label, material, patch, bcs, use_ghosts )
+    {}
+
+    /// Destructor
+    virtual ~BCFDView() = default;
+
+    /// Prevent copy (and move) constructor
+    BCFDView ( const BCFDView & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    BCFDView & operator= ( const BCFDView & ) = delete;
+}; // class BCFDView
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCFDView_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory-bld.sh b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory-bld.sh
new file mode 100755
index 00000000..cede1b22
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory-bld.sh
@@ -0,0 +1,186 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+VARs=(CC NC)
+STNs=(P5 P7)
+DIMs=(2 3)
+PPPs=(
+  "PureMetalProblem"
+  "PureMetalProblem"
+)
+NFFs=(
+  "4"
+  "4"
+)
+DIRs=(x y z)
+SIGNs=(minus plus)
+BCs=(Dirichlet Neumann)
+
+SS=""
+VV=""
+PP=""
+
+POSITIONAL=()
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    -v|--var)
+    VARs=("$2")
+    VV="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -s|--stn)
+    SS="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -p|--pb)
+    PP="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    *)    # unknown option
+    POSITIONAL+=("$1") # save it in an array for later
+    shift # past argument
+    ;;
+esac
+done
+set -- "${POSITIONAL[@]}" # restore positional parameters
+
+if [ -n "${SS}" ]; then
+  FOUND=0
+  for ((s=0; s<${#STNs[@]}; s++)); do
+    if [ "${SS}" == "${STNs[s]}" ]; then
+      STNs=("${STNs[s]}");
+      DIMs=("${DIMs[s]}");
+      PPPs=("${PPPs[s]}");
+      NFFs=("${NFFs[s]}");
+      FOUND=1
+    fi
+  done
+  if [[ $FOUND -eq 0 ]]; then
+    >&2 echo "cannot find the stencil"
+    exit
+  fi
+fi
+
+if [ -n "${PP}" ]; then
+  for ((pp=0; pp<${#PPPs[@]}; pp++)); do
+    FOUND=0
+    IFS=';' read -r -a PPs <<< "${PPPs[pp]}"
+    IFS=';' read -r -a NFs <<< "${NFFs[pp]}"
+    for ((p=0; p<${#PPs[@]}; p++)); do
+      if [ "${PP}" == "${PPs[p]}" ]; then
+        PPPs[pp]="${PPs[p]}";
+        NFFs[pp]="${NFs[p]}";
+        FOUND=1
+      fi
+    done
+    if [[ $FOUND -eq 0 ]]; then
+      PPPs[pp]="";
+      NFFs[pp]="";
+    fi
+  done
+fi
+
+PBS=()
+for ((pp=0; pp<${#PPPs[@]}; pp++)); do
+  IFS=';' read -r -a PPs <<< "${PPPs[pp]}"
+  for ((p=0; p<${#PPs[@]}; p++)); do
+    FOUND=0
+    for ((q=0; q<${#PBS[@]}; q++)); do
+      if [ "${PPs[p]}" == "${PBS[q]}" ]; then
+        FOUND=1
+      fi
+    done
+    if [[ $FOUND -eq 0 ]]; then
+      PBS+=("${PPs[p]}")
+    fi
+  done
+done
+
+SRC=${0%-bld.sh}${PP}${VV}${SS}-bld.cc
+
+echo "generating $SRC"
+
+echo '/*' > $SRC
+echo ' * The MIT License' >> $SRC
+echo ' *' >> $SRC
+echo ' * Copyright (c) 1997-2018 The University of Utah' >> $SRC
+echo ' *' >> $SRC
+echo ' * Permission is hereby granted, free of charge, to any person obtaining a copy' >> $SRC
+echo ' * of this software and associated documentation files (the "Software"), to' >> $SRC
+echo ' * deal in the Software without restriction, including without limitation the' >> $SRC
+echo ' * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or' >> $SRC
+echo ' * sell copies of the Software, and to permit persons to whom the Software is' >> $SRC
+echo ' * furnished to do so, subject to the following conditions:' >> $SRC
+echo ' *' >> $SRC
+echo ' * The above copyright notice and this permission notice shall be included in' >> $SRC
+echo ' * all copies or substantial portions of the Software.' >> $SRC
+echo ' *' >> $SRC
+echo ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' >> $SRC
+echo ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' >> $SRC
+echo ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' >> $SRC
+echo ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' >> $SRC
+echo ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING' >> $SRC
+echo ' * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS' >> $SRC
+echo ' * IN THE SOFTWARE.' >> $SRC
+echo ' */' >> $SRC
+echo '' >> $SRC
+for PB in ${PBS[@]}; do
+  echo '#include <CCA/Components/PhaseField/DataTypes/'$PB'.h>' >> $SRC
+done
+echo '#include <CCA/Components/PhaseField/BoundaryConditions/BCFDView.h>' >> $SRC
+echo '#include <CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory.h>' >> $SRC
+echo '' >> $SRC
+echo 'namespace Uintah {' >> $SRC
+echo 'namespace PhaseField {' >> $SRC
+echo '' >> $SRC
+
+Fs=(
+  "ScalarField<const double>"
+  "VectorField<const double, 1>"
+  "VectorField<const double, 3>"
+)
+STNs=(
+  "P3 P5 P7"
+  "P5"
+  "P7"
+)
+VARs=(CC NC)
+
+for ((f=0; f<${#Fs[@]}; f++)); do
+  F="${Fs[f]}";
+  for STN in ${STNs[f]}; do
+    echo "template<> BCFactoryFDView < $F, $STN >::FactoryMap BCFactoryFDView < $F, $STN >::RegisteredNames = {};" >> $SRC
+  done
+  echo "" >> $SRC
+done
+
+echo '} // namespace Uintah' >> $SRC
+echo '} // namespace PhaseField' >> $SRC
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory.h b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory.h
new file mode 100644
index 00000000..b1a167df
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory.h
@@ -0,0 +1,123 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCViewFactory_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCViewFactory_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/Util/Expressions.h>
+#include <CCA/Components/PhaseField/Factory/Base.h>
+#include <CCA/Components/PhaseField/Factory/Factory.h>
+#include <CCA/Components/PhaseField/DataTypes/BCInfo.h>
+#include <CCA/Components/PhaseField/DataTypes/ScalarField.h>
+#include <CCA/Components/PhaseField/DataTypes/VectorField.h>
+#include <CCA/Components/PhaseField/Views/FDView.h>
+
+#include <Core/Exceptions/ProblemSetupException.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/// Factory creator for BCFDView
+template<typename Field, StnType STN> using BCFactoryFDView = Factory < FDView<Field, STN>, const typename Field::label_type &, const VarLabel *, int, const Level *, const std::vector< BCInfo<Field> > & >;
+
+/// Factory base for BCFDView
+template<typename Field, StnType STN> using BCBaseFDView = Base< FDView<Field, STN> >;
+
+/**
+ * @brief Factory creator implementation for BCFDView
+ *
+ * @tparam Problem type of PhaseField problem
+ * @tparam I index of Field within Problem
+ */
+template<typename Problem, size_t I>
+class BCFDViewFactory
+{
+    using Field = typename Problem::template get_field<I>::type;
+
+private: // STATIC MEMBERS
+
+    /// Problem variable representation
+    static constexpr VarType VAR = Problem::Var;
+
+    /// Finite-difference stencil
+    static constexpr StnType STN = Problem::Stn;
+
+public:
+
+    /**
+     * @brief factory static method for intantiating a BCView< T, S >
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param level level on which data is retrieved
+     * @param faces list of the faces where to impose boundary conditions
+     * @param bcs vector with info on the boundary conditions (ordered as in faces)
+     * @return FDView< T, S >* newly instantiated view
+     */
+    static FDView<Field, STN> *
+    create (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        const std::list<Patch::FaceType> & faces,
+        const std::vector < BCInfo<Field> > & bcs
+    )
+    {
+        BCBaseFDView<Field, STN> * ptr = nullptr;
+        std::string bcview = Problem::Name + "|" + std::to_string ( I ) + "|" + var_to_str ( VAR ) + "|";
+
+        auto face = faces.begin();
+        auto bci = bcs.begin();
+        while ( face != faces.end() && bci != bcs.end() )
+        {
+            bcview += Patch::getFaceName ( *face ) + "|" + ( bci->bc == BC::FineCoarseInterface ? fc_to_str ( bci->c2f ) : bc_to_str ( bci->bc ) ) + "|";
+            ++face;
+            ++bci;
+        }
+        ptr = BCFactoryFDView<Field, STN>::Create ( bcview, label, subproblems_label, material, level, bcs );
+        if ( !ptr )
+        {
+            SCI_THROW ( ProblemSetupException ( "Cannot Create BCView '" + bcview + "'", __FILE__, __LINE__ ) );
+        }
+
+        return dynamic_cast< FDView<Field, STN>* > ( ptr );
+    }
+
+}; // class BCFDViewFactory
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCViewFactory_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/BCInterface.h b/src/CCA/Components/PhaseField/BoundaryConditions/BCInterface.h
new file mode 100644
index 00000000..a1907689
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/BCInterface.h
@@ -0,0 +1,101 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/BCInterface.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCInterface_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCInterface_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/get_bcs.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/partition_range.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Interface for boundary conditions
+ *
+ * groups together various methods to get info about boundary conditions which
+ * depend on the different types of variable representation and fine-differences
+ * stencils allowing to choose the relevant implementation at compile time
+ * @tparam VAR type of variable representation
+ * @tparam STN finite-difference stencil
+ */
+template < VarType VAR, StnType STN>
+struct BCInterface
+{
+    /**
+     * @brief Partition a patch into a list of Problems
+     *
+     * Retrieves boundary conditions and partirion a patch accordingly
+     *
+     * @tparam Field list of type of fields (ScalarField < T> or VectorField < T, N >) of the Problems
+     * @param labels list of lables for each variable of the problem
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material problem material index
+     * @param patch grid patch to be partitioned
+     * @param c2f which fine/coarse interface conditions to use on each variable
+     * @return list of partitioned Problems
+     */
+    template <typename... Field>
+    static std::list < Problem<VAR, STN, Field...> >
+    partition_patch (
+        const typename Field::label_type & ...  labels,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        const std::map<std::string, FC> * c2f = nullptr
+    )
+    {
+        /// Problem Dimension
+        constexpr DimType DIM = get_stn<STN>::dim;
+        constexpr DirType DIR = get_dim<DIM>::highest_dir;
+        constexpr int GN = get_stn<STN>::ghosts;
+
+        // output container
+        std::list < Problem<VAR, STN, Field...> > problems;
+
+        // one flag for each patch face to store if it is a boundary face
+        std::array<bool, 2 * DIM> flags;
+        flags.fill ( false );
+
+        // start partitioning from the highest_dir detail::partition_range iterates on lower directions
+        detail::partition_range < DIR, GN, 0, Field... >::template exec<VAR, STN> ( labels..., subproblems_label, material, patch->getLevel(), DWInterface<VAR, DIM>::get_low ( patch ), DWInterface<VAR, DIM>::get_high ( patch ), {}, detail::get_bcs<DIM, Field>::exec ( patch, 0, 0, labels, c2f, flags )..., flags, problems );
+        return problems;
+    }
+
+}; // struct BCInterface
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCInterface_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_basic_fd_view.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_basic_fd_view.h
new file mode 100644
index 00000000..146e0d69
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_basic_fd_view.h
@@ -0,0 +1,342 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WAPBRRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_basic_fd_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_basic_fd_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_basic_fd_view_h
+
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of DataWarehouse variables for basic differential operations
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of basic differential operations (first and second order derivatives) at
+ * boundary faces
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ * @tparam P BC, FC, and Patch::Face pack
+ */
+template<typename Field, StnType STN, VarType VAR, BCF P> class bc_basic_fd_view;
+
+/**
+ * @brief Wrapper of DataWarehouse variables for basic differential operations
+ * (ScalarField implementation)
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of basic differential operations (first and second order derivatives) at
+ * boundary faces
+ *
+ * @remark actual finite-differences implementations are in bc_fd
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ * @tparam P BC, FC, and Patch::Face pack
+ */
+template<typename T, StnType STN, VarType VAR, BCF P>
+class bc_basic_fd_view < ScalarField<T>, STN, VAR, P >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+    , public bc_fd < ScalarField<T>, STN, VAR, get_bcf<P>::face, get_bcf<P>::bc, get_stn<STN>::ghosts, get_bcf <P>::c2f >  // fd implementation
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required by STN
+    static constexpr int GN = get_stn<STN>::ghosts;
+
+    /// Type of boundary conditions
+    static constexpr BC B = get_bcf<P>::bc;
+
+    /// Type of fine/coarse interface conditions
+    static constexpr FC C2F = get_bcf<P>::c2f;
+
+    /// Patch face
+    static constexpr Patch::FaceType F = get_bcf<P>::face;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+    /// Type of rhs for the given BC
+    using BV = typename get_bc< B >::template value_type< Field >;
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    bc_basic_fd_view (
+        const bc_basic_fd_view * copy,
+        bool deep
+    ) : bc_fd<Field, STN, VAR, F, B, GN, C2F> ( copy, deep )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the
+     * DataWarehouse
+     *
+     * @param view view on which the bc has to be imposed
+     * @param label variable label
+     * @param material material index
+     * @param level grid level
+     * @param value used when imposing the prescribed BC
+     */
+    bc_basic_fd_view (
+        view<Field> * view,
+        const typename Field::label_type & label,
+        int material,
+        const Level * level,
+        const BV & value
+    ) : bc_fd<Field, STN, VAR, F, B, GN, C2F> ( view, label, material, level, value )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param view view on which the bc has to be imposed
+     * @param label variable label
+     * @param material material index
+     * @param level grid level
+     * @param value used when imposing the prescribed BC
+     * @param patch grid patch owning the face
+     * @param use_ghosts if ghosts value are to be retrieved
+    */
+    bc_basic_fd_view (
+        const view<Field> * view,
+        DataWarehouse * dw,
+        const VarLabel * label,
+        int material,
+        const Level * level,
+        const BV & value,
+        const Patch * patch,
+        bool use_ghosts
+    ) : bc_fd<Field, STN, VAR, F, B, GN, C2F> ( view, dw, label, material, level, value, patch, use_ghosts )
+    {}
+
+    virtual ~bc_basic_fd_view() = default;
+
+    /// Prevent copy (and move) constructor
+    bc_basic_fd_view ( const bc_basic_fd_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_basic_fd_view & operator= ( const bc_basic_fd_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    ) const override
+    {
+        return scinew bc_basic_fd_view ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<bc_basic_fd_view, Field> ( this, deep, offset );
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (virtual implementation)
+     *
+     * @remark bc values are computed at runtime thus cannot create non const
+     * view, there's nothing to modify in the DataWarehouse
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual inline const view<Field> *
+    get_view()
+    const override
+    {
+        return bc_fd<Field, STN, VAR, F, B, GN, C2F>::get_view();
+    };
+
+    /**
+     * @brief Partial x derivative
+     *
+     * First order derivative along x at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V
+    dx (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d < X > ( id );
+    }
+
+    /**
+     * @brief Partial y derivative
+     *
+     * First order derivative along y at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V
+    dy (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d < Y > ( id );
+    }
+
+    /**
+     * @brief Partial z derivative
+     *
+     * First order derivative along z at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V
+    dz (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d < Z > ( id );
+    };
+
+    /**
+     * @brief Partial x second order derivative
+     *
+     * Second order derivative along x at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V
+    dxx (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d2 < X > ( id );
+    }
+
+    /**
+     * @brief Partial x second order derivative
+     *
+     * Second order derivative along y at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V
+    dyy (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d2 < Y > ( id );
+    }
+
+    /**
+     * @brief Partial x second order derivative
+     *
+     * Second order derivative along z at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V
+    dzz (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d2 < Z > ( id );
+    }
+
+}; // class bc_basic_fd_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_basic_fd_view_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd.h
new file mode 100644
index 00000000..2bfe8988
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd.h
@@ -0,0 +1,105 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Abstract finite-differences scheme for variables at grid boundary
+ *
+ * To implement a new boundary-condition it should be sufficient to
+ * define a new BC and code the relevant implementations of this class
+ * (for amr simulations also the corresponding bc_fd implementation for
+ * fine/coarse interfaces must be provided)
+ *
+ * @implements basic_fd_view < Field, STN >
+ *
+ * @remark the method implemented in this class are ment to be called only by
+ * bcs_basic_fd_view to compute bc dependent quantities only
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ * @tparam F patch face on which bc is to be applied
+ * @tparam B type of boundary conditions
+ * @tparam GN Number of ghosts required
+ * @tparam C2F Fine/Coarse Interface conditions
+ * @tparam CNEW Wheter to use new datawarehouse for retrieving corse grid data
+ */
+template <typename Field, StnType STN, VarType VAR, Patch::FaceType F, BC B, int GN, FC C2F = FC::None, bool CNEW = false> class bc_fd;
+_DOXYBDY (
+    /// Non const type of the field value
+    using V;
+
+    /**
+     * @brief First order derivative
+     *
+     * First order derivative along DIR at index id
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template <DirType DIR> inline V d ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Second order derivative
+     *
+     * Second order derivative along DIR at index id
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template <DirType DIR> inline V d2 ( const IntVector & id ) const = 0;
+             );
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_CC.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_NC.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_CC.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_NC.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCSimple.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCLinear.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCBilinear.h>
+
+#endif //Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_CC.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_CC.h
new file mode 100644
index 00000000..5deef1f4
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_CC.h
@@ -0,0 +1,403 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_CC.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Dirichlet_G1_CC_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Dirichlet_G1_CC_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme at Dirichlet boundaries interface
+ * (ScalarField, Cell-centered, 1-ghost stencils implementation)
+ *
+ * approximation of ghost value across Dirichlet boundaries
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam F patch face on which bc is to be applied
+ */
+template<typename T, StnType STN, Patch::FaceType F>
+class bc_fd < ScalarField<T>, STN, CC, F, BC::Dirichlet, 1 >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+    /// Boundary face normal vector direction
+    static constexpr DirType D = get_face<F>::dir;
+
+    /// Boundary face normal vector sign (int)
+    static constexpr int SGN = get_face<F>::sgn;
+
+    /// Boundary face normal vector sign (double)
+    static constexpr double DSGN = get_face<F>::dsgn;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // MEMBERS
+
+    /// View for grid values
+    const view<Field> * m_view;
+
+    /// Imposed value at boundary
+    const V m_value;
+
+    /// Grid level
+    const Level * m_level;
+
+    /// Grid spacing
+    const Vector m_h;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id grid index
+     * @return value at id
+     */
+    inline V
+    value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_view ) [ id ];
+    };
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    bc_fd (
+        const bc_fd * copy,
+        bool deep
+    ) : m_view ( copy->m_view ),
+        m_value ( copy->m_value ),
+        m_level ( copy->m_level ),
+        m_h ( copy->m_h ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param view view to access grid values
+     * @param label unused since value is already in view
+     * @param material unused since value is already in view
+     * @param level fine grid level
+     * @param value imposed value at boundary
+     */
+    bc_fd (
+        const view<Field> * view,
+        const VarLabel * _DOXYARG ( label ),
+        int _DOXYARG ( material ),
+        const Level * level,
+        const V & value
+    ) : m_view ( view ),
+        m_value ( value ),
+        m_level ( level ),
+        m_h ( level->dCell() )
+    {
+    }
+
+    /// Destructor
+    virtual ~bc_fd() = default;
+
+    /// Prevent copy (and move) constructor
+    bc_fd ( const bc_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_fd & operator= ( const bc_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark Fails because cannot set bc_fd over a patch
+     *
+     * @param dw unused
+     * @param patch unused
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Patch * _DOXYARG ( patch ),
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * Does not retrieve data since it is not required to enforce boundary
+     * conditions (inner view is just referenced here and is already set by
+     * bcs_basic_fd_view which owns it. It just set the view support.
+     *
+     * @param dw unused
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        // on bc ghost nodes are only those from fci or neighbors not domain bc
+
+        m_level = level;
+        m_support.clear();
+
+        IntVector l ( low ), h ( high );
+        if ( SGN > 0 ) // F=D+
+        {
+            l[D] = high[D];
+            h[D] += GN;
+        }
+        else // F=D-
+        {
+            h[D] = low[D];
+            l[D] -= GN;
+        }
+
+        m_support.emplace_back ( l, h );
+    };
+
+    /**
+     * @brief get bc view support
+     *
+     * we want to extend this to ghost cells/nodes
+     *
+     * @return support of the view
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_support.front().getLow() }, high { m_support.front().getHigh() };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @remark Fails because inner view is constant
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        IntVector i ( id );
+        i[D] -= SGN;
+        return 2. * m_value - value ( i );
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (Virtual Implementation)
+     *
+     * @remark Fails because inner view is constant
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    };
+
+public: // BC FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     * (parallel direction implementation)
+     *
+     * First order derivative along DIR at index id at boundary interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief First order derivative
+     * (normal direction implementation)
+     *
+     * First order derivative along DIR at index id at boundary interface
+     * @remark Dirichlet condition is applied to cell edge
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d (
+        const IntVector & id
+    ) const
+    {
+        IntVector j ( id );
+        j[D] -= SGN;
+        return -0.5 * DSGN * ( value ( j ) + value ( id ) - 2. * m_value ) / m_h[D];
+    }
+
+    /**
+     * @brief Second order derivative
+     * (parallel direction implementation)
+     *
+     * Second order derivative along DIR at index id at boundary interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d2 (
+        const IntVector & _DOXYARG ( id )
+    ) const VIRT;
+
+    /**
+     * @brief Second order derivative
+     * (normal direction implementation)
+     *
+     * Second order derivative along DIR at index id at boundary interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const
+    {
+        IntVector j ( id );
+        j[D] -= SGN;
+        return ( value ( j ) - 3. * value ( id ) + 2. * m_value ) / ( m_h[D] * m_h[D] );
+    }
+
+}; // class bc_fd
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Dirichlet_G1_CCh
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_NC.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_NC.h
new file mode 100644
index 00000000..53bc5d8d
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_NC.h
@@ -0,0 +1,399 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Dirichlet_G1_NC.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Dirichlet_G1_NC_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Dirichlet_G1_NC_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme at Dirichlet boundaries interface
+ * (ScalarField, node-centered, 1-ghost stencils implementation)
+ *
+ * approximation of ghost value across Dirichlet boundaries
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam F patch face on which bc is to be applied
+ */
+template<typename T, StnType STN, Patch::FaceType F >
+class bc_fd < ScalarField<T>, STN, NC, F, BC::Dirichlet, 1 >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+    /// Boundary face normal vector direction
+    static constexpr DirType D = get_face<F>::dir;
+
+    /// Boundary face normal vector sign (int)
+    static constexpr int SGN = get_face<F>::sgn;
+
+    /// Boundary face normal vector sign (double)
+    static constexpr double DSGN = get_face<F>::dsgn;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // MEMBERS
+
+    /// View for grid values
+    const view<Field> * m_view;
+
+    /// Imposed value at boundary
+    const V m_value;
+
+    /// Grid level
+    const Level * m_level;
+
+    /// Grid spacing
+    Vector m_h;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id grid index
+     * @return value at id
+     */
+    inline V
+    value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_view ) [ id ];
+    };
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    bc_fd (
+        const bc_fd * copy,
+        bool deep
+    ) : m_view ( copy->m_view ),
+        m_value ( copy->m_value ),
+        m_level ( copy->m_level ),
+        m_h ( copy->m_h ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param view view to access grid values
+     * @param label unused since value is already in view
+     * @param material unused since value is already in view
+     * @param level fine grid level
+     * @param value imposed value at boundary
+     */
+    bc_fd (
+        const view<Field> * view,
+        const VarLabel * _DOXYARG ( label ),
+        int _DOXYARG ( material ),
+        const Level * level,
+        const V & value
+    ) : m_view ( view ),
+        m_value ( value ),
+        m_level ( level ),
+        m_h ( level->dCell() )
+    {
+    }
+
+    /// Destructor
+    virtual ~bc_fd() = default;
+
+    /// Prevent copy (and move) constructor
+    bc_fd ( const bc_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_fd & operator= ( const bc_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark Does nothing because cannot set bc_fd over a patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Patch * _DOXYARG ( patch ),
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * Does not retrieve data since it is not required to enforce boundary
+     * conditions (inner view is just referenced here and is already set by
+     * bcs_basic_fd_view which owns it. It just set the view support.
+     *
+     * @param dw unused
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        // on bc ghost nodes are only those from fci or neighbors not domain bc
+        m_level = level;
+        m_h = level->dCell();
+        m_support.clear();
+
+        IntVector l ( low ), h ( high );
+        if ( SGN > 0 ) // F=D+
+        {
+            l[D] = high[D];
+            h[D] += GN;
+        }
+        else // F=D-
+        {
+            h[D] = low[D];
+            l[D] -= GN;
+        }
+
+        m_support.emplace_back ( l, h );
+    };
+
+    /**
+     * @brief get bc view range
+     *
+     * we want to extend this to ghost cells/nodes
+     *
+     * @return range
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_support.front().getLow() }, high { m_support.front().getHigh() };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @remark Fails because inner view is constant
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        IntVector i ( id );
+        i[D] -= 2 * SGN;
+        return  m_value - value ( i );
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (Virtual Implementation)
+     *
+     * @remark Fails because inner view is constant
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    };
+
+public: // BC FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     * (parallel direction implementation)
+     *
+     * First order derivative along DIR at index id at boundary interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d (
+        const IntVector & _DOXYARG ( id )
+    ) const VIRT;
+
+    /**
+     * @brief First order derivative
+     * (normal direction implementation)
+     *
+     * First order derivative along DIR at index id at boundary interface
+     * @remark Dirichlet condition is applied to cell edge
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d (
+        const IntVector & id
+    ) const
+    {
+        IntVector j ( id );
+        j[D] -= SGN;
+        return DSGN * ( m_value - value ( j ) ) / m_h[D];
+    }
+
+    /**
+     * @brief Second order derivative
+     * (parallel direction implementation)
+     *
+     * Second order derivative along DIR at index id at boundary interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d2 (
+        const IntVector & _DOXYARG ( id )
+    ) const VIRT;
+
+    /**
+     * @brief Second order derivative
+     * (normal direction implementation)
+     *
+     * Second order derivative along DIR at index id at boundary interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d2 (
+        const IntVector & _DOXYARG ( id )
+    ) const
+    {
+        return 0.;
+    }
+
+}; // class bc_fd
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Dirichlet_G1_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1.h
new file mode 100644
index 00000000..037dc28b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1.h
@@ -0,0 +1,432 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_h
+
+#include <CCA/Components/PhaseField/Views/detail/view.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme at fine/coarse interfaces (1-ghost stencils)
+ * (ScalarField implementation)
+ *
+ * approximation of ghost value across the amr interface is done using
+ * interpolator
+ *
+ * @image latex fc0.eps "FC0"
+ * @image html  fc0.png "FC0"
+ * @image latex fc1.eps "FC1"
+ * @image html  fc1.png "FC1"
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ * @tparam F patch face on which bc is to be applied
+ * @tparam C2F Fine/Coarse Interface conditions
+ */
+template<typename T, StnType STN, VarType VAR, Patch::FaceType F, FC C2F >
+class bc_fd < ScalarField<T>, STN, VAR, F, BC::FineCoarseInterface, 1, C2F >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+    /// Boundary face normal vector direction
+    static constexpr DirType D = get_face<F>::dir;
+
+    /// Boundary face normal vector sign (int)
+    static constexpr int SGN = get_face<F>::sgn;
+
+    /// Boundary face normal vector sign (double)
+    static constexpr double DSGN = get_face<F>::dsgn;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // MEMBERS
+
+    /// View of the fine level for grid values
+    const view<Field> * m_fine_view;
+
+    /// Coarse interpolator for ghost values
+    view<Field> * m_coarse_interp;
+
+    /// Grid spacing of fine level
+    const Vector m_h;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get fine value at position
+     *
+     * @param id fine index
+     * @return fine value at id
+     */
+    inline V
+    fine_value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_fine_view ) [ id ];
+    };
+
+    /**
+     * @brief Get coarse interpolation at position
+     *
+     * @param id position index
+     * @return coarse field interpolated value at id
+     */
+    inline V
+    coarse_interp (
+        const IntVector & id
+    ) const
+    {
+        const auto & coarse_interp = *m_coarse_interp;
+        return coarse_interp[id];
+    };
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    bc_fd (
+        const bc_fd * copy,
+        bool deep
+    ) : m_fine_view ( copy->m_fine_view ),
+        m_coarse_interp ( copy->m_coarse_interp->clone ( deep ) ),
+        m_h ( copy->m_h ),
+        m_support ( copy->m_support )
+    {
+    }
+
+protected: // CONSTRUCTORS
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param fine_view view to access fine grid values
+     * @param label unused since value is already in fine/coarse_view
+     * @param material unused since value is already in fine/coarse_view
+     * @param level fine grid level
+     * @param coarse_interp interpolator of coarse grid values
+     */
+    bc_fd (
+        const view<Field> * fine_view,
+        const VarLabel * _DOXYARG ( label ),
+        int _DOXYARG ( material ),
+        const Level * level,
+        view<Field> * coarse_interp
+    ) : m_fine_view ( fine_view ),
+        m_coarse_interp ( coarse_interp ),
+        m_h ( level->dCell() )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// Destructor
+    virtual ~bc_fd()
+    {
+        delete m_coarse_interp; // created by bcs_basic_fd_view::get_and_pop_front_value
+    };
+
+    /// Prevent copy (and move) constructor
+    bc_fd ( const bc_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_fd & operator= ( const bc_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark bc_fd should not be set to range over a patch
+     *
+     * @param dw unused
+     * @param patch unused
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Patch * _DOXYARG ( patch ),
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * retrieve also info from coarser level region by setting the coarser
+     * interpolator
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        m_support.clear();
+
+        IntVector l ( low ), h ( high );
+
+        if ( SGN > 0 ) // F=D+
+        {
+            l[D] = high[D];
+            if ( use_ghosts ) h[D] += GN;
+        }
+        else // F=D-
+        {
+            h[D] = low[D];
+            if ( use_ghosts ) l[D] -= GN;
+        }
+
+        m_support.emplace_back ( l, h );
+
+        m_coarse_interp->set ( dw, level, l, h );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (virtual implementation)
+     *
+     * @remark value at boundary is computed at runtime thus doesn't exist in the
+     * DataWarehouse
+     *
+     * @param id unused
+     * @return nothing
+     */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief Get value at position with index id
+     *
+     * @param id position index (on fine level)
+     * @return interpolated value from coarser level
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        return coarse_interp ( id );
+    };
+
+    /**
+     * @brief Get the region on which the view is defined
+     *
+     * It is the ghost fine region across an amr interface
+     *
+     * @return support of the view
+     */
+    virtual
+    Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the fine position with index id
+     *
+     * @param id fine position index
+     * @return check result
+     */
+    virtual
+    bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_support.front().getLow() }, high { m_support.front().getHigh() };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (virtual implementation)
+     *
+     * @remark bc values are computed at runtime thus cannot create non const
+     * view, there's nothing to modify in the DataWarehouse
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual inline const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    };
+
+public: // BC FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     * (parallel direction implementation)
+     *
+     * First order derivative along DIR at index id at amr interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template<DirType DIR>
+    inline typename std::enable_if < D != DIR, T >::type
+    d (
+        const IntVector & _DOXYARG ( id )
+    ) const VIRT;
+
+    /**
+     * @brief First order derivative
+     * (normal direction implementation)
+     *
+     * First order derivative along DIR at index id at amr interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template<DirType DIR>
+    inline typename std::enable_if < D == DIR, T >::type
+    d (
+        const IntVector & id
+    ) const
+    {
+        IntVector ip ( id ), im ( id );
+        ip[D] += SGN;
+        im[D] -= SGN;
+        return 0.5 * DSGN * ( coarse_interp ( ip ) - fine_value ( im ) ) / m_h[D];
+    }
+
+    /**
+     * @brief Second order derivative
+     * (parallel direction implementation)
+     *
+     * Second order derivative along DIR at index id at amr interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template<DirType DIR>
+    inline typename std::enable_if < D != DIR, T >::type
+    d2 (
+        const IntVector & _DOXYARG ( id )
+    ) const VIRT;
+
+    /**
+     * @brief Second order derivative
+     * (normal direction implementation)
+     *
+     * Second order derivative along DIR at index id at amr interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template<DirType DIR>
+    inline typename std::enable_if < D == DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const
+    {
+        IntVector ip ( id ), im ( id );
+        ip[D] += SGN;
+        im[D] -= SGN;
+        return ( fine_value ( im ) + coarse_interp ( ip ) - 2. * fine_value ( id ) )
+               / ( m_h[D] * m_h[D] );
+    }
+
+}; // class bc_fd
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Dirichlet_G1_CCh
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCBilinear.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCBilinear.h
new file mode 100644
index 00000000..6a29ea00
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCBilinear.h
@@ -0,0 +1,502 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCBilinear.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_FCBilinear_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_FCBilinear_h
+
+#include <CCA/Components/PhaseField/Views/detail/view.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+#include <CCA/Components/PhaseField/AMR/AMRInterface.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme at fine/coarse interfaces (1-ghost stencils)
+ * (ScalarField implementation)
+ *
+ * Implement FCLinear approximation of ghost value across the amr interface
+ *
+ * @image latex fclinear.eps "FCLinear"
+ * @image html  fclinear.png "FCLinear"
+ *
+ * @todo generilize to DIM != D2
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ * @tparam F patch face on which bc is to be applied
+ */
+template<typename T, StnType STN, VarType VAR, Patch::FaceType F>
+class bc_fd < ScalarField<T>, STN, VAR, F, BC::FineCoarseInterface, 1, FC::FCBilinear >
+    : virtual public basic_fd_view< ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+    /// Problem dimension
+    static constexpr DimType DIM = get_stn<STN>::dim;
+
+    /// Boundary face normal vector direction
+    static constexpr DirType D = get_face<F>::dir;
+
+    /// Boundary face normal vector sign (int)
+    static constexpr int SGN = get_face<F>::sgn;
+
+    /// Boundary face normal vector sign (double)
+    static constexpr int DSGN = get_face<F>::dsgn;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( DIM == D2, "FCLinear must be used only for 2D problems" );
+
+private: // MEMBERS
+
+    /// View of the fine level for grid values
+    const view<Field> * m_fine_view;
+
+    /// View of the coarse level for computing fine ghost values
+    view<Field> * m_coarse_view;
+
+    /// Fine grid level
+    const Level * m_level_fine;
+
+    /// Coarse grid level
+    const Level * m_level_coarse;
+
+    /// Grid spacing of fine level
+    Vector m_h;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get fine value at position
+     *
+     * @param id fine index
+     * @return fine value at id
+     */
+    inline V
+    fine_value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_fine_view ) [ id ];
+    };
+
+    /**
+     * @brief Get coarse value at position
+     *
+     * @param id coarse index
+     * @return fine value at id
+     */
+    inline V
+    coarse_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & coarse_view = *m_coarse_view;
+        return coarse_view[id];
+    };
+
+    /**
+     * @brief Get coarse interpolation at position
+     *
+     * @param id position index
+     * @return coarse field interpolated value at id
+     */
+    inline V
+    coarse_interp (
+        const IntVector & id
+    ) const
+    {
+        return operator[] ( id );
+    };
+
+protected:
+    bc_fd (
+        const bc_fd * copy,
+        bool deep
+    ) : m_fine_view ( copy->m_fine_view ),
+        m_coarse_view ( copy->m_coarse_view->clone ( deep ) ),
+        m_level_fine ( copy->m_level_fine ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_h ( copy->m_h ),
+        m_support ( copy->m_support )
+    {}
+
+protected: // CONSTRUCTORS
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param fine_view view to access fine grid values
+     * @param label unused since value is already in fine/coarse_view
+     * @param material unused since value is already in fine/coarse_view
+     * @param level fine grid level
+     * @param coarse_view view to access coarse grid values
+     */
+    bc_fd (
+        const view<Field> * fine_view,
+        const VarLabel * _DOXYARG ( label ),
+        int _DOXYARG ( material ),
+        const Level * level,
+        view<Field> * coarse_view
+    ) : m_fine_view ( fine_view ),
+        m_coarse_view ( coarse_view ),
+        m_level_fine ( level ),
+        m_level_coarse ( level->getCoarserLevel().get_rep() ),
+        m_h ( level->dCell() )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// Destructor
+    virtual ~bc_fd()
+    {
+        delete m_coarse_view; // created by bcs_basic_fd_view::get_value
+    };
+
+    /// Prevent copy (and move) constructor
+    bc_fd ( const bc_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_fd & operator= ( const bc_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark bc_fd should not be set to range over a patch
+     *
+     * @param dw unused
+     * @param patch unused
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Patch * _DOXYARG ( patch ),
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * retrieve also info from coarser level region by setting the coarser
+     * view
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        m_support.clear();
+
+        IntVector l ( low ), h ( high );
+
+        if ( SGN > 0 ) // F=D+
+        {
+            l[D] = high[D];
+            if ( use_ghosts ) h[D] += GN;
+        }
+        else // F=D-
+        {
+            h[D] = low[D];
+            if ( use_ghosts ) l[D] -= GN;
+        }
+
+        m_support.emplace_back ( l, h );
+
+        m_level_fine = level;
+        m_level_coarse = level->getCoarserLevel().get_rep();
+        m_h = level->dCell();
+
+        m_coarse_view->set ( dw, level, low - get_dim<DIM>::unit_vector(), high + get_dim<DIM>::unit_vector() );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (virtual implementation)
+     *
+     * @remark value at boundary is computed at runtime thus doesn't exist in the
+     * DataWarehouse
+     *
+     * @param id unused
+     * @return nothing
+     */
+    virtual T &
+    operator[] (
+        const IntVector & id
+    ) override VIRT;
+
+    /**
+     * @brief Get value at position with index id
+     *
+     * @param id position index (on fine level)
+     * @return interpolated value from coarser level
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        IntVector id0 = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, id );
+        Point p_fine = DWInterface<VAR, DIM>::get_position ( m_level_fine, id );
+        Point p0 = DWInterface<VAR, DIM>::get_position ( m_level_coarse, id0 );
+        double w0, w1, w2, w3;
+        IntVector id1 { id }, id2 { id }, id3 { id };
+        id2[D] -= SGN;
+
+
+        V u0 = coarse_value ( id ), u1, u2 = fine_value ( id2 ), u3;
+        for ( size_t d = 0; d < DIM; ++d )
+            if ( p0.asVector() [d] < p_fine.asVector() [d] )
+            {
+                id1[d] += 1;
+                if ( d != D ) id3[d] += 1;
+            }
+            else
+            {
+                id1[d] -= 1;
+                if ( d != D ) id3[d] -= 1;
+            }
+
+        if ( m_fine_view->is_defined_at ( id3 ) )
+        {
+            if ( m_fine_view->is_defined_at ( id1 ) )
+            {
+                w0 = 4. / 9.;
+                w1 = -1. / 9.;
+                w2 = 1. / 3.;
+                w3 = 1. / 3.;
+                u1 = fine_value ( id1 );
+            }
+            else
+            {
+                w0 = 9. / 20.;
+                w1 = -1. / 20.;
+                w2 = 3. / 10.;
+                w3 = 3. / 10.;
+                u1 = coarse_value ( id1 );
+            }
+            u3 = fine_value ( id3 );
+            return w0 * u0 + w1 * u1 + w2 * u2 + w3 * u3;
+        }
+        else
+        {
+            w0 = 1. / 2.;
+            w2 = 1. / 3.;
+            w3 = 1. / 6.;
+            u3 = coarse_value ( id3 );
+            return w0 * u0 + w2 * u2 + w3 * u3;
+        }
+    };
+
+    /**
+     * @brief get bc view range
+     *
+     * we want to extend this to ghost cells/nodes
+     *
+     * @return range
+     */
+    virtual
+    Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the fine position with index id
+     *
+     * @param id fine position index
+     * @return check result
+     */
+    virtual
+    bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_support.front().getLow() }, high { m_support.front().getHigh() };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (virtual implementation)
+     *
+     * @remark bc values are computed at runtime thus cannot create non const
+     * view, there's nothing to modify in the DataWarehouse
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual inline const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    };
+
+public: // BC FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     * (parallel direction implementation)
+     *
+     * First order derivative along DIR at index id at amr interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief First order derivative
+     *
+     * First order derivative along DIR at index id at amr interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d (
+        const IntVector & id
+    ) const
+    {
+        IntVector ip ( id ), im ( id );
+        ip[D] += SGN;
+        im[D] -= SGN;
+        return 0.5 * DSGN * ( coarse_interp ( ip ) - fine_value ( im ) ) / m_h[D];
+    }
+
+    /**
+     * @brief Second order derivative
+     * (parallel direction implementation)
+     *
+     * Second order derivative along DIR at index id at amr interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief Second order derivative
+     * (normal direction implementation)
+     *
+     * Second order derivative along DIR at index id at amr interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const
+    {
+        IntVector ip ( id ), im ( id );
+        ip[D] += SGN;
+        im[D] -= SGN;
+        return ( fine_value ( im ) + coarse_interp ( ip ) - 2. * fine_value ( id ) )
+               / ( m_h[D] * m_h[D] );
+    }
+
+}; // class bc_fd
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_FCBilinear_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCLinear.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCLinear.h
new file mode 100644
index 00000000..7039696b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCLinear.h
@@ -0,0 +1,474 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCLinear.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_FCLinear_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_FCLinear_h
+
+#include <CCA/Components/PhaseField/Views/detail/view.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+#include <CCA/Components/PhaseField/AMR/AMRInterface.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme at fine/coarse interfaces (1-ghost stencils)
+ * (ScalarField implementation)
+ *
+ * Implement FCLinear approximation of ghost value across the amr interface
+ *
+ * @image latex fclinear.eps "FCLinear"
+ * @image html  fclinear.png "FCLinear"
+ *
+ * @todo generilize to DIM != D2
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ * @tparam F patch face on which bc is to be applied
+ */
+template<typename T, StnType STN, VarType VAR, Patch::FaceType F>
+class bc_fd < ScalarField<T>, STN, VAR, F, BC::FineCoarseInterface, 1, FC::FCLinear >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+    /// Problem dimension
+    static constexpr DimType DIM = get_stn<STN>::dim;
+
+    /// Boundary face normal vector direction
+    static constexpr DirType D = get_face<F>::dir;
+
+    /// Boundary face normal vector sign (int)
+    static constexpr int SGN = get_face<F>::sgn;
+
+    /// Boundary face normal vector sign (double)
+    static constexpr int DSGN = get_face<F>::dsgn;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( DIM == D2, "FCLinear must be used only for 2D problems" );
+
+private: // MEMBERS
+
+    /// View of the fine level for grid values
+    const view<Field> * m_fine_view;
+
+    /// View of the coarse level for computing fine ghost values
+    view<Field> * m_coarse_view;
+
+    /// Fine grid level
+    const Level * m_level_fine;
+
+    /// Coarse grid level
+    const Level * m_level_coarse;
+
+    /// Grid spacing of fine level
+    Vector m_h;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get fine value at position
+     *
+     * @param id fine index
+     * @return fine value at id
+     */
+    inline V
+    fine_value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_fine_view ) [ id ];
+    };
+
+    /**
+     * @brief Get coarse value at position
+     *
+     * @param id coarse index
+     * @return fine value at id
+     */
+    inline V
+    coarse_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & coarse_view = *m_coarse_view;
+        return coarse_view[id];
+    };
+
+    /**
+     * @brief Get coarse interpolation at position
+     *
+     * @param id position index
+     * @return coarse field interpolated value at id
+     */
+    inline V
+    coarse_interp (
+        const IntVector & id
+    ) const
+    {
+        return operator[] ( id );
+    };
+
+protected:
+    bc_fd (
+        const bc_fd * copy,
+        bool deep
+    ) : m_fine_view ( copy->m_fine_view ),
+        m_coarse_view ( copy->m_coarse_view->clone ( deep ) ),
+        m_level_fine ( copy->m_level_fine ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_h ( copy->m_h ),
+        m_support ( copy->m_support )
+    {}
+
+protected: // CONSTRUCTORS
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param fine_view view to access fine grid values
+     * @param label unused since value is already in fine/coarse_view
+     * @param material unused since value is already in fine/coarse_view
+     * @param level fine grid level
+     * @param coarse_view view to access coarse grid values
+     */
+    bc_fd (
+        const view<Field> * fine_view,
+        const VarLabel * _DOXYARG ( label ),
+        int _DOXYARG ( material ),
+        const Level * level,
+        view<Field> * coarse_view
+    ) : m_fine_view ( fine_view ),
+        m_coarse_view ( coarse_view ),
+        m_level_fine ( level ),
+        m_level_coarse ( level->getCoarserLevel().get_rep() ),
+        m_h ( level->dCell() )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// Destructor
+    virtual ~bc_fd()
+    {
+        delete m_coarse_view; // created by bcs_basic_fd_view::get_value
+    };
+
+    /// Prevent copy (and move) constructor
+    bc_fd ( const bc_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_fd & operator= ( const bc_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark bc_fd should not be set to range over a patch
+     *
+     * @param dw unused
+     * @param patch unused
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Patch * _DOXYARG ( patch ),
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * retrieve also info from coarser level region by setting the coarser
+     * view
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        m_support.clear();
+
+        IntVector l ( low ), h ( high );
+
+        if ( SGN > 0 ) // F=D+
+        {
+            l[D] = high[D];
+            if ( use_ghosts ) h[D] += GN;
+        }
+        else // F=D-
+        {
+            h[D] = low[D];
+            if ( use_ghosts ) l[D] -= GN;
+        }
+
+        m_support.emplace_back ( l, h );
+
+        m_level_fine = level;
+        m_level_coarse = level->getCoarserLevel().get_rep();
+        m_h = level->dCell();
+
+        m_coarse_view->set ( dw, level, l, h );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (virtual implementation)
+     *
+     * @remark value at boundary is computed at runtime thus doesn't exist in the
+     * DataWarehouse
+     *
+     * @param id unused
+     * @return nothing
+     */
+    virtual T &
+    operator[] (
+        const IntVector & id
+    ) override VIRT;
+
+    /**
+     * @brief Get value at position with index id
+     *
+     * @param id position index (on fine level)
+     * @return interpolated value from coarser level
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        IntVector id0 = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, id );
+        Point p_fine = DWInterface<VAR, DIM>::get_position ( m_level_fine, id );
+        Point p0 = DWInterface<VAR, DIM>::get_position ( m_level_coarse, id0 );
+        double w0, w1, w2;
+        IntVector id1 { id }, id2 { id };
+        id1[D] = id2[D] -= SGN;
+
+        for ( size_t d = 0; d < DIM; ++d )
+            if ( d != D )
+            {
+                if ( p0.asVector() [d] < p_fine.asVector() [d] )
+                    id2[d] -= 1;
+                else
+                    id2[d] += 1;
+            }
+        w0 = 2. / 3.;
+        w1 = 2. / 3.;
+        w2 = -1. / 3.;
+        typename std::remove_const<T>::type u0 = coarse_value ( id ),
+                                            u1 = fine_value ( id1 ),
+                                            u2 = fine_value ( id2 );
+        return w0 * u0 + w1 * u1 + w2 * u2;
+    };
+
+    /**
+     * @brief Get the region on which the view is defined
+     *
+     * It is the ghost fine region across an amr interface
+     *
+     * @return support of the view
+     */
+    virtual
+    Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the fine position with index id
+     *
+     * @param id fine position index
+     * @return check result
+     */
+    virtual
+    bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_support.front().getLow() }, high { m_support.front().getHigh() };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (virtual implementation)
+     *
+     * @remark bc values are computed at runtime thus cannot create non const
+     * view, there's nothing to modify in the DataWarehouse
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual inline const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    };
+
+public: // BC FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     * (parallel direction implementation)
+     *
+     * First order derivative along DIR at index id at amr interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief First order derivative
+     *
+     * First order derivative along DIR at index id at amr interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d (
+        const IntVector & id
+    ) const
+    {
+        IntVector ip ( id ), im ( id );
+        ip[D] += SGN;
+        im[D] -= SGN;
+        return 0.5 * DSGN * ( coarse_interp ( ip ) - fine_value ( im ) ) / m_h[D];
+    }
+
+    /**
+     * @brief Second order derivative
+     * (parallel direction implementation)
+     *
+     * Second order derivative along DIR at index id at amr interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief Second order derivative
+     * (normal direction implementation)
+     *
+     * Second order derivative along DIR at index id at amr interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const
+    {
+        IntVector ip ( id ), im ( id );
+        ip[D] += SGN;
+        im[D] -= SGN;
+        return ( fine_value ( im ) + coarse_interp ( ip ) - 2. * fine_value ( id ) )
+               / ( m_h[D] * m_h[D] );
+    }
+
+}; // class bc_fd
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_FCLinear_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCSimple.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCSimple.h
new file mode 100644
index 00000000..390d5060
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCSimple.h
@@ -0,0 +1,476 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_FineCoarseInterface_G1_FCSimple.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_FCSimple_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_FineCoarseInterface_G1_FCSimple_h
+
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+#include <CCA/Components/PhaseField/AMR/AMRInterface.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme at fine/coarse interfaces
+ * (ScalarField implementation)
+ *
+ * Implement FCSimple approximation of ghost value across the amr interface
+ *
+ * @image latex fcsimple.eps "FCSimple"
+ * @image html  fcsimple.png "FCSimple"
+ *
+ * @todo generilize to DIM != D2
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ * @tparam F patch face on which bc is to be applied
+ */
+template<typename T, StnType STN, VarType VAR, Patch::FaceType F>
+class bc_fd < ScalarField<T>, STN, VAR, F, BC::FineCoarseInterface, 1, FC::FCSimple >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+    /// Problem dimension
+    static constexpr DimType DIM = get_stn<STN>::dim;
+
+    /// Boundary face normal vector direction
+    static constexpr DirType D = get_face<F>::dir;
+
+    /// Boundary face normal vector sign (int)
+    static constexpr int SGN = get_face<F>::sgn;
+
+    /// Boundary face normal vector sign (double)
+    static constexpr int DSGN = get_face<F>::dsgn;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( DIM == D2, "FCSimple must be used only for 2D problems" );
+
+private: // MEMBERS
+
+    /// View of the fine level for grid values
+    const view<Field> * m_fine_view;
+
+    /// View of the coarse level for computing fine ghost values
+    view<Field> * m_coarse_view;
+
+    /// Fine grid level
+    const Level * m_level_fine;
+
+    /// Coarse grid level
+    const Level * m_level_coarse;
+
+    /// Grid spacing of fine level
+    Vector m_h;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get fine value at position
+     *
+     * @param id fine index
+     * @return fine value at id
+     */
+    inline V
+    fine_value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_fine_view ) [ id ];
+    };
+
+    /**
+     * @brief Get coarse value at position
+     *
+     * @param id coarse index
+     * @return fine value at id
+     */
+    inline V
+    coarse_value (
+        const IntVector & id
+    ) const
+    {
+        const auto & coarse_view = *m_coarse_view;
+        return coarse_view[id];
+    };
+
+    /**
+     * @brief Get coarse interpolation at position
+     *
+     * @param id position index
+     * @return coarse field interpolated value at id
+     */
+    inline V
+    coarse_interp (
+        const IntVector & id
+    ) const
+    {
+        return operator[] ( id );
+    };
+
+protected:
+    bc_fd (
+        const bc_fd * copy,
+        bool deep
+    ) : m_fine_view ( copy->m_fine_view ),
+        m_coarse_view ( copy->m_coarse_view->clone ( deep ) ),
+        m_level_fine ( copy->m_level_fine ),
+        m_level_coarse ( copy->m_level_coarse ),
+        m_h ( copy->m_h ),
+        m_support ( copy->m_support )
+    {}
+
+protected: // CONSTRUCTORS
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param fine_view view to access fine grid values
+     * @param label unused since value is already in fine/coarse_view
+     * @param material unused since value is already in fine/coarse_view
+     * @param level fine grid level
+     * @param coarse_view view to access coarse grid values
+     */
+    bc_fd (
+        const view<Field> * fine_view,
+        const VarLabel * _DOXYARG ( label ),
+        int _DOXYARG ( material ),
+        const Level * level,
+        view<Field> * coarse_view
+    ) : m_fine_view ( fine_view ),
+        m_coarse_view ( coarse_view ),
+        m_level_fine ( level ),
+        m_level_coarse ( level->getCoarserLevel().get_rep() ),
+        m_h ( level->dCell() )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// Destructor
+    virtual ~bc_fd()
+    {
+        delete m_coarse_view; // created by bcs_basic_fd_view::get_value
+    };
+
+    /// Prevent copy (and move) constructor
+    bc_fd ( const bc_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_fd & operator= ( const bc_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark bc_fd should not be set to range over a patch
+     *
+     * @param dw unused
+     * @param patch unused
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Patch * _DOXYARG ( patch ),
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * retrieve also info from coarser level region by setting the coarser
+     * view
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        m_support.clear();
+
+        IntVector l ( low ), h ( high );
+
+        if ( SGN > 0 ) // F=D+
+        {
+            l[D] = high[D];
+            h[D] += GN;
+        }
+        else // F=D-
+        {
+            h[D] = low[D];
+            l[D] -= GN;
+        }
+
+        m_support.emplace_back ( l, h );
+
+        m_level_fine = level;
+        m_level_coarse = level->getCoarserLevel().get_rep();
+        m_h = level->dCell();
+
+        m_coarse_view->set ( dw, level, low - get_dim<DIM>::unit_vector(), high + get_dim<DIM>::unit_vector() );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (virtual implementation)
+     *
+     * @remark value at boundary is computed at runtime thus doesn't exist in the
+     * DataWarehouse
+     *
+     * @param id unused
+     * @return nothing
+     */
+    virtual T &
+    operator[] (
+        const IntVector & id
+    ) override VIRT;
+
+    /**
+     * @brief Get value at position with index id
+     *
+     * @param id position index (on fine level)
+     * @return interpolated value from coarser level
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        IntVector id0 = AMRInterface<VAR, DIM>::get_coarser ( m_level_fine, id );
+        Point p_fine = DWInterface<VAR, DIM>::get_position ( m_level_fine, id );
+        Point p0 = DWInterface<VAR, DIM>::get_position ( m_level_coarse, id0 );
+        double w0, w1;
+        typename std::remove_const<T>::type u0 = coarse_value ( id ), u1;
+        IntVector id1 { id };
+        for ( size_t d = 0; d < DIM; ++d )
+            if ( p0.asVector() [d] < p_fine.asVector() [d] )
+                id1[d] += 1;
+            else
+                id1[d] -= 1;
+        if ( m_fine_view->is_defined_at ( id1 ) )
+        {
+            w0 = 2. / 3.;
+            w1 = 1. / 3.;
+            u1 = fine_value ( id1 );
+        }
+        else
+        {
+            w0 = 3. / 4.;
+            w1 = 1. / 4.;
+            u1 = coarse_value ( id1 );
+        }
+        return w0 * u0 + w1 * u1;
+    };
+
+    /**
+     * @brief Get the region on which the view is defined
+     *
+     * It is the ghost fine region across an amr interface
+     *
+     * @return support of the view
+     */
+    virtual
+    Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the fine position with index id
+     *
+     * @param id fine position index
+     * @return check result
+     */
+    virtual
+    bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_support.front().getLow() }, high { m_support.front().getHigh() };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (virtual implementation)
+     *
+     * @remark bc values are computed at runtime thus cannot create non const
+     * view, there's nothing to modify in the DataWarehouse
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual inline const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    };
+
+public: // BC FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     * (parallel direction implementation)
+     *
+     * First order derivative along DIR at index id at amr interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief First order derivative
+     *
+     * First order derivative along DIR at index id at amr interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d (
+        const IntVector & id
+    ) const
+    {
+        IntVector ip ( id ), im ( id );
+        ip[D] += SGN;
+        im[D] -= SGN;
+        return 0.5 * DSGN * ( coarse_interp ( ip ) - fine_value ( im ) ) / m_h[D];
+    }
+
+    /**
+     * @brief Second order derivative
+     * (parallel direction implementation)
+     *
+     * Second order derivative along DIR at index id at amr interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief Second order derivative
+     * (normal direction implementation)
+     *
+     * Second order derivative along DIR at index id at amr interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const
+    {
+        IntVector ip ( id ), im ( id );
+        ip[D] += SGN;
+        im[D] -= SGN;
+        return ( fine_value ( im ) + coarse_interp ( ip ) - 2. * fine_value ( id ) )
+               / ( m_h[D] * m_h[D] );
+    }
+
+}; // class bc_fd
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Dirichlet_G1_FCSimple_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_CC.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_CC.h
new file mode 100644
index 00000000..82d8961c
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_CC.h
@@ -0,0 +1,405 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_CC.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Neumann_G1_CC_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Neumann_G1_CC_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme at Neumann boundaries interface
+ * (ScalarField, Cell-centered, 1-ghost stencils implementation)
+ *
+ * approximation of ghost value across Neumann boundaries
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam F patch face on which bc is to be applied
+ */
+template<typename T, StnType STN, Patch::FaceType F >
+class bc_fd < ScalarField<T>, STN, CC, F, BC::Neumann, 1 >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+    /// Boundary face normal vector direction
+    static constexpr DirType D = get_face<F>::dir;
+
+    /// Boundary face normal vector sign (int)
+    static constexpr int SGN = get_face<F>::sgn;
+
+    /// Boundary face normal vector sign (double)
+    static constexpr double DSGN = get_face<F>::dsgn;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // MEMBERS
+
+    /// View for grid values
+    const view<Field> * m_view;
+
+    /// Imposed value at boundary
+    const V m_value;
+
+    /// Grid level
+    const Level * m_level;
+
+    /// Grid spacing
+    Vector m_h;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id grid index
+     * @return value at id
+     */
+    inline V
+    value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_view ) [ id ];
+    };
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    bc_fd (
+        const bc_fd * copy,
+        bool deep
+    ) : m_view ( copy->m_view ),
+        m_value ( copy->m_value ),
+        m_level ( copy->m_level ),
+        m_h ( copy->m_h ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param view view to access grid values
+     * @param label unused since value is already in view
+     * @param material unused since value is already in view
+     * @param level fine grid level
+     * @param value imposed value at boundary
+     */
+    bc_fd (
+        const view<Field> * view,
+        const VarLabel * _DOXYARG ( label ),
+        int _DOXYARG ( material ),
+        const Level * level,
+        const V & value
+    ) : m_view ( view ),
+        m_value ( value ),
+        m_level ( level ),
+        m_h ( level->dCell() )
+    {
+    }
+
+    /// Destructor
+    virtual ~bc_fd() = default;
+
+    /// Prevent copy (and move) constructor
+    bc_fd ( const bc_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_fd & operator= ( const bc_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark Fails because cannot set bc_fd over a patch
+     *
+     * @param dw unused
+     * @param patch unused
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * Does not retrieve data since it is not required to enforce boundary
+     * conditions (inner view is just referenced here and is already set by
+     * bcs_basic_fd_view which owns it. It just set the view support.
+     *
+     * @param dw unused
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        // on bc ghost nodes are only those from fci or neighbors not domain bc
+
+        m_level = level;
+        m_h = level->dCell();
+
+        m_support.clear();
+
+        IntVector l ( low ), h ( high );
+        if ( SGN > 0 ) // F=D+
+        {
+            l[D] = high[D];
+            h[D] += GN;
+        }
+        else // F=D-
+        {
+            h[D] = low[D];
+            l[D] -= GN;
+        }
+
+        m_support.emplace_back ( l, h );
+    };
+
+    /**
+     * @brief get bc view support
+     *
+     * we want to extend this to ghost cells/nodes
+     *
+     * @return support of the view
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_support.front().getLow() }, high { m_support.front().getHigh() };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @remark Fails because inner view is constant
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        IntVector i ( id );
+        i[D] -= SGN;
+        return value ( i ) + DSGN * m_value * m_h[D];
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (Virtual Implementation)
+     *
+     * @remark Fails because inner view is constant
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    };
+
+public: // BC FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     * (parallel direction implementation)
+     *
+     * First order derivative along DIR at index id at boundary interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief First order derivative
+     * (normal direction implementation)
+     *
+     * First order derivative along DIR at index id at boundary interface
+     * @remark Dirichlet condition is applied to cell edge
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d (
+        const IntVector & id
+    ) const
+    {
+        IntVector j ( id );
+        j[D] -= SGN;
+        return DSGN * ( value ( id ) - value ( j ) ) / ( 2. * m_h[D] ) + m_value / 2.;
+    }
+
+    /**
+     * @brief Second order derivative
+     * (parallel direction implementation)
+     *
+     * Second order derivative along DIR at index id at boundary interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief Second order derivative
+     * (normal direction implementation)
+     *
+     * Second order derivative along DIR at index id at boundary interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T>::type
+    d2 (
+        const IntVector & id
+    ) const
+    {
+        IntVector j ( id );
+        j[D] -= SGN;
+        return ( value ( j ) - value ( id ) + DSGN * m_h[D] * m_value ) / ( m_h[D] * m_h[D] );
+    }
+
+}; // class bc_fd
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Neumann_G1_CC_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_NC.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_NC.h
new file mode 100644
index 00000000..6327cc95
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_NC.h
@@ -0,0 +1,403 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bc_fd_Neumann_G1_NC.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Neumann_G1_NC_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Neumann_G1_NC_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme at Neumann boundaries interface
+ * (ScalarField, node-centered, 1-ghost stencils implementation)
+ *
+ * approximation of ghost value across Neumann boundaries
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam F patch face on which bc is to be applied
+ */
+template<typename T, StnType STN, Patch::FaceType F >
+class bc_fd < ScalarField<T>, STN, NC, F, BC::Neumann, 1 >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+    /// Boundary face normal vector direction
+    static constexpr DirType D = get_face<F>::dir;
+
+    /// Boundary face normal vector sign (int)
+    static constexpr int SGN = get_face<F>::sgn;
+
+    /// Boundary face normal vector sign (double)
+    static constexpr double DSGN = get_face<F>::dsgn;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // MEMBERS
+
+    /// View for grid values
+    const view<Field> * m_view;
+
+    /// Imposed value at boundary
+    const V m_value;
+
+    /// Grid level
+    const Level * m_level;
+
+    /// Grid spacing
+    Vector m_h;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // METHODS
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id grid index
+     * @return value at id
+     */
+    inline V
+    value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_view ) [ id ];
+    };
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    bc_fd (
+        const bc_fd * copy,
+        bool deep
+    ) : m_view ( copy->m_view ),
+        m_value ( copy->m_value ),
+        m_level ( copy->m_level ),
+        m_h ( copy->m_h ),
+        m_support ( copy->m_support )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param view view to access grid values
+     * @param label unused since value is already in view
+     * @param material unused since value is already in view
+     * @param level fine grid level
+     * @param value imposed value at boundary
+     */
+    bc_fd (
+        const view<Field> * view,
+        const VarLabel * _DOXYARG ( label ),
+        int _DOXYARG ( material ),
+        const Level * level,
+        const V & value
+    ) : m_view ( view ),
+        m_value ( value ),
+        m_level ( level ),
+        m_h ( level->dCell() )
+    {
+    }
+
+    /// Destructor
+    virtual ~bc_fd() = default;
+
+    /// Prevent copy (and move) constructor
+    bc_fd ( const bc_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bc_fd & operator= ( const bc_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark Fails because cannot set bc_fd over a patch
+     *
+     * @param dw unused
+     * @param patch unused
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Patch * _DOXYARG ( patch ),
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * Does not retrieve data since it is not required to enforce boundary
+     * conditions (inner view is just referenced here and is already set by
+     * bcs_basic_fd_view which owns it. It just set the view support.
+     *
+     * @param dw unused
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        // on bc ghost nodes are only those from fci or neighbors not domain bc
+        m_level = level;
+        m_h = level->dCell();
+
+        m_support.clear();
+
+        IntVector l ( low ), h ( high );
+        if ( SGN > 0 ) // F=D+
+        {
+            l[D] = high[D];
+            h[D] += GN;
+        }
+        else // F=D-
+        {
+            h[D] = low[D];
+            l[D] -= GN;
+        }
+
+        m_support.emplace_back ( l, h );
+    };
+
+    /**
+     * @brief get bc view support
+     *
+     * we want to extend this to ghost cells/nodes
+     *
+     * @return support of the view
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_support.front().getLow() }, high { m_support.front().getHigh() };
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @remark Fails because inner view is constant
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual T &
+    operator[] (
+        const IntVector & _DOXYARG ( id )
+    ) override VIRT;
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        IntVector i ( id );
+        i[D] -= SGN;
+        return value ( i ) + DSGN * m_value * m_h[D];
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view (Virtual Implementation)
+     *
+     * @remark Fails because inner view is constant
+     *
+     * @return nothing
+     */
+    virtual inline view<Field> *
+    get_view()
+    override VIRT;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual
+    const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    };
+
+public: // BC FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     * (parallel direction implementation)
+     *
+     * First order derivative along DIR at index id at boundary interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief First order derivative
+     * (normal direction implementation)
+     *
+     * First order derivative along DIR at index id at boundary interface
+     * @remark Dirichlet condition is applied to cell edge
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template <DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d (
+        const IntVector & id
+    ) const
+    {
+        return m_value;
+    }
+
+    /**
+     * @brief Second order derivative
+     * (parallel direction implementation)
+     *
+     * Second order derivative along DIR at index id at boundary interface
+     *
+     * @remark derivative parallel to the face should not be computed by this bc_fd
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id unused
+     * @return nothing
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D != DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const VIRT;
+
+    /**
+     * @brief Second order derivative
+     * (normal direction implementation)
+     *
+     * Second order derivative along DIR at index id at boundary interface
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template < DirType DIR >
+    inline typename std::enable_if < D == DIR, T >::type
+    d2 (
+        const IntVector & id
+    ) const
+    {
+        IntVector j ( id );
+        j[D] -= SGN;
+        return 2. * ( value ( j ) - value ( id ) + DSGN * m_h[D] * m_value ) / ( m_h[D] * m_h[D] );
+    }
+
+}; // class bc_fd
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bc_fd_Neumann_G1_NC_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bcfd_view.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bcfd_view.h
new file mode 100644
index 00000000..d6050353
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bcfd_view.h
@@ -0,0 +1,309 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bcfd_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bcfd_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bcfd_view_h
+
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bcs_basic_fd_view.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of DataWarehouse variables for both basic and complex
+ * differential operations over both physical and amr boundaries
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of differential operations at boundary cells/points
+ *
+ * @tparam Field type of Field
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ * @tparam P list of BC, FC, and Patch::Face packs
+ */
+template<typename Field, StnType STN, typename Problem, typename Index, BCF ... P > class bcfd_view;
+
+/**
+ * @brief Wrapper of DataWarehouse variables for both basic and complex
+ * differential operations over both physical and amr boundaries
+ * (ScalarField implementation)
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of differential operations at boundary cells/points
+ *
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ * @tparam P list of BC, FC, and Patch::Face packs
+ */
+template<typename T, StnType STN, typename Problem, typename Index, BCF ... P >
+class bcfd_view < ScalarField<T>, STN, Problem, Index, P... >
+    : virtual public fd_view < ScalarField<T>, STN >
+    , public bcs_basic_fd_view < ScalarField<T>, STN, Problem, Index, P... >
+    , public dw_fd_view < ScalarField<T>, STN, Problem::Var >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// View is constructed by bcs_basic_fd_view
+    using bcs_basic_fd_view<Field, STN, Problem, Index, P...>::bcs_basic_fd_view;
+
+    /// Default destructor
+    virtual ~bcfd_view() = default;
+
+    /// Prevent copy (and move) constructor
+    bcfd_view ( const bcfd_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bcfd_view & operator= ( const bcfd_view & ) = delete;
+
+}; // class bcfd_view
+
+/**
+ * @brief Wrapper of DataWarehouse variables for both basic and complex
+ * differential operations over both physical and amr boundaries
+ * (VectorField implementation)
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of differential operations at boundary cells/points
+ *
+ * @tparam Problem type of PhaseField problem
+ * @tparam I variable index within Problem
+ * @tparam P list of BC, FC, and Patch::Face packs
+ */
+template<typename T, size_t N, StnType STN, typename Problem, size_t I, BCF ... P >
+class bcfd_view < VectorField<T, N>, STN, Problem, index_sequence<I>, P... >
+    : virtual public view_array < fd_view < ScalarField<T>, STN >, ScalarField<T>, N >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = VectorField<T, N>;
+
+    /// Type of View of each component
+    using View = fd_view < ScalarField<T>, STN >;
+
+private: // SINGLE INDEX METHODS
+
+    /**
+     * @brief Create bcfd view for a given component
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @tparam J component index
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param level level on which data is retrieved
+     * @param bcs vector with info on the boundary conditions
+     * @return pointer to the newly created view
+     */
+    template<size_t J>
+    void * create_element (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        const std::vector< BCInfo<Field> > & bcs
+    )
+    {
+        std::vector< BCInfo< ScalarField<T> > > bci;
+        for ( const auto & b : bcs )
+            bci.push_back ( { b.value[J], b.bc, b.c2f } );
+        return this->m_view_ptr[J] = new bcfd_view < ScalarField<T>, STN, Problem, index_sequence<I, J>, P... > ( label[J], subproblems_label, material, level, bci );
+    }
+
+    /**
+     * @brief Create bcfd view for a given component
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @tparam J component index
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch grid patch on which data is retrieved
+     * @param bcs vector with info on the boundary conditions
+     * @return pointer to the newly created view
+     */
+    template<size_t J>
+    void * create_element (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        const std::vector< BCInfo<Field> > & bcs,
+        bool use_ghosts
+    )
+    {
+        std::vector< BCInfo< ScalarField<T> > > bci;
+        for ( const auto & b : bcs )
+            bci.push_back ( { b.value[J], b.bc, b.c2f } );
+        return this->m_view_ptr[J] = new bcfd_view < ScalarField<T>, STN, Problem, index_sequence<I, J>, P... > ( dw, label[J], subproblems_label, material, patch, bci, use_ghosts );
+    }
+
+private: // INDEXED CONSTRUCTOR
+
+    /**
+     * @brief Indexed constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @tparam J indices for boundary views
+     * @param unused to allow template argument deduction
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param level grid level on which data is retrieved
+     * @param bcs vector with info on the boundary conditions
+     */
+    template<size_t... J>
+    bcfd_view (
+        index_sequence<J...>,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        const std::vector< BCInfo<Field> > & bcs
+    )
+    {
+        std::array<bool, N> {{ create_element<J> ( label, subproblems_label, material, level, bcs )... }};
+    }
+
+    /**
+     * @brief Indexed constructor
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @tparam J indices for boundary views
+     * @param unused to allow template argument deduction
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch grid patch
+     * @param bcs vector with info on the boundary conditions
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    template<size_t... J>
+    bcfd_view (
+        index_sequence<J...>,
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        const std::vector< BCInfo<Field> > & bcs,
+        bool use_ghosts
+    )
+    {
+        std::vector< BCInfo< ScalarField<T> > > bci;
+        for ( const auto & b : bcs )
+            bci.push_back ( { b.value[I], b.bc, b.c2f } );
+        std::array<bool, N> {{ create_element<J> ( dw, label, subproblems_label, material, patch, bcs, use_ghosts )... }};
+    }
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param level grid level on which data is retrieved
+     * @param bcs vector with info on the boundary conditions
+     */
+    bcfd_view (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        const std::vector< BCInfo<Field> > & bcs
+    ) : bcfd_view ( make_index_sequence<N> {}, label, subproblems_label, material, level, bcs )
+    {};
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch grid patch
+     * @param bcs vector with info on the boundary conditions
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    bcfd_view (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        const std::vector< BCInfo<Field> > & bcs,
+        bool use_ghosts
+    ) : bcfd_view ( make_index_sequence<N> {}, dw, label, subproblems_label, material, patch, bcs, use_ghosts )
+    {}
+
+    /// Destructor
+    virtual ~bcfd_view()
+    {
+        for ( auto view : this->m_view_ptr )
+            delete view;
+    }
+
+    /// Prevent copy (and move) constructor
+    bcfd_view ( const bcfd_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bcfd_view & operator= ( const bcfd_view & ) = delete;
+
+}; // bcfd_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_BCFDView_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/bcs_basic_fd_view.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bcs_basic_fd_view.h
new file mode 100644
index 00000000..77502708
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/bcs_basic_fd_view.h
@@ -0,0 +1,670 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR stencil_entries PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/bcs_basic_fd_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bcs_basic_fd_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bcs_basic_fd_view_h
+
+#include <CCA/Components/PhaseField/Util/Expressions.h>
+#include <CCA/Components/PhaseField/DataTypes/Support.h>
+#include <CCA/Components/PhaseField/Views/detail/piecewise_view.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/bc_basic_fd_view.h>
+#include <CCA/Components/PhaseField/AMR/detail/amr_interpolator.h>
+
+#include <memory>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Detail implementation of variables wrapper for both basic differential
+ * operations over both physical and amr boundaries
+ *
+ * Group together multiple views (one for eatch edge the boundary belongs to,
+ * and one for accessing the DataWarehouse on internal indices) and
+ * expose the correct implementation of basic differential operations for each
+ * direction
+ *
+ * @tparam Field type of Field
+ * @tparam Problem type of PhaseField problem
+ * @tparam Index index_sequence of Field within Problem (first element is variable index,
+ * following ones, if present, are the component index within the variable)
+ * @tparam P list of BC, FC, and Patch::Face packs
+ */
+template<typename Field, StnType STN, typename Problem, typename Index, BCF ... P > class bcs_basic_fd_view;
+
+template<typename T, StnType STN, typename Problem, typename Index, BCF ... P >
+class bcs_basic_fd_view < ScalarField<T>, STN, Problem, Index, P... >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+    , public piecewise_view< ScalarField<T> >
+{
+private: // STATIC MEMBERS
+
+    /// Problem variable representation
+    static constexpr VarType VAR = Problem::Var;
+
+    /// Problem dimension
+    static constexpr DimType DIM = Problem::Dim;
+
+    /// Number of ghosts required by STN
+    static constexpr int GN = get_stn<STN>::ghosts;
+
+    static constexpr size_t N = sizeof ... ( P );
+    static constexpr BCF Q[N] = { P ... };
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // STATIC ASSERTIONS
+
+    static_assert ( STN == STN, "stencil value must match" );
+
+private: // MEMBERS
+
+    /// Label for the grid variable into the DataWarehouse
+    const VarLabel * m_label;
+
+    /// Label for subprombelms in the DataWarehouse
+    const VarLabel * m_subproblems_label;
+
+    /// Material index in the DataWarehouse
+    const int m_material;
+
+    /// Inner view to grid variable
+    std::unique_ptr < dw_basic_fd_view<Field, STN, VAR> > m_dw_view;
+
+    /// Inner view pointers to grid variable (indexed by direction)
+    std::vector < basic_fd_view<Field, STN> * > m_fd_view;
+
+    /// Inner view to boundary views
+    std::tuple < std::unique_ptr < bc_basic_fd_view<Field, STN, VAR, P> > ... > m_bc_view;
+
+    /// Region where the view is defined
+    Support m_support;
+
+private: // INDEXED CONSTRUCTOR
+
+    /**
+     * @brief Indexed constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @tparam J indices for boundary views
+     * @param unused to allow template argument deduction
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    template < size_t ... J >
+    bcs_basic_fd_view (
+        index_sequence<J...>,
+        const bcs_basic_fd_view * copy,
+        bool deep
+    ) : piecewise_view<Field> (), // copy is made in this constructor we don't want to duplicate clones
+        m_label ( copy->m_label ),
+        m_subproblems_label ( copy->m_subproblems_label ),
+        m_material ( copy->m_material ),
+        m_dw_view ( dynamic_cast < dw_basic_fd_view < Field, STN, VAR > * > ( copy->m_dw_view->clone ( deep ) ) ), m_fd_view ( DIM, m_dw_view.get () ),
+        m_bc_view { std::unique_ptr < bc_basic_fd_view < Field, STN, VAR, P > > ( dynamic_cast < bc_basic_fd_view < Field, STN, VAR, P > * > ( m_fd_view[get_face< get_bcf<P>::face >::dir] = dynamic_cast < bc_basic_fd_view<Field, STN, VAR, P> * > ( std::get<J> ( copy->m_bc_view )->clone ( deep ) ) ) ) ... }
+    {
+        std::array<bool, N> {{ push_back_bc<J> () ... }};
+
+        // dw view has to be last ( when dw has ghost they may overlap physical bc_views
+        this->m_views.push_back ( m_dw_view.get() );
+    }
+
+    /**
+     * @brief Indexed constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @tparam J indices for boundary views
+     * @param unused to allow template argument deduction
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param level grid level on which data is retrieved
+     * @param bcs vector with info on the boundary conditions
+     */
+    template < size_t ... J >
+    bcs_basic_fd_view (
+        index_sequence<J...>,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        const std::vector < BCInfo<Field> > & bcs
+    ) : piecewise_view<Field> (),
+        m_label ( label ),
+        m_subproblems_label ( subproblems_label ),
+        m_material ( material ),
+        m_dw_view ( scinew dw_basic_fd_view<Field, STN, VAR> { label, material, level } ),
+              m_fd_view ( DIM, m_dw_view.get () ),
+    m_bc_view { std::unique_ptr< bc_basic_fd_view< Field, STN, VAR, P > > ( dynamic_cast < bc_basic_fd_view < Field, STN, VAR, P > * > ( m_fd_view[get_face< get_bcf<P>::face >::dir] = scinew bc_basic_fd_view<Field, STN, VAR, P> ( this, label, material, level, get_value<J> ( bcs ) ) ) ) ...  }
+    {
+        std::array<bool, N> {{ push_back_bc<J> () ... }};
+
+        // dw view has to be last ( when dw has ghost they may overlap physical bc_views
+        this->m_views.push_back ( m_dw_view.get() );
+    }
+
+private: // SINGLE INDEX METHODS
+
+    /**
+     * @brief push a bc_view back in the piece-views vector
+     * @tparam J index of the bc
+     * @return unused value (to allow call in array initialization for variadic
+     * template expansions)
+     */
+    template < size_t J >
+    bool
+    push_back_bc ()
+    {
+        if ( get_bcf< Q[J] >::bc != BC::FineCoarseInterface )
+            this->m_views.push_back ( std::get<J> ( m_bc_view ).get() );
+        return true;
+    }
+
+    /**
+     * @brief Get BC value (non FineCoarseInterface implementation)
+     * @tparam J index of the bc
+     * @return the value to impose as BC
+     */
+    template<size_t J, BC B = get_bcf< Q[J] >::bc >
+    typename std::enable_if < B != BC::FineCoarseInterface, T >::type
+    get_value (
+        const std::vector < BCInfo<Field> > & bc
+    )
+    {
+        return bc[J].value;
+    }
+
+    /**
+     * @brief Get BC value (FineCoarseInterface implementation)
+     * @tparam J index of the bc
+     * @return newly created interpolator to impose continuity across fine/coarse
+     * interfaces
+     */
+    template < size_t J, BC B = get_bcf< Q[J] >::bc, FC C2F = get_bcf< Q[J] >::c2f >
+    typename std::enable_if < B == BC::FineCoarseInterface, view<Field> * >::type
+    get_value (
+        const std::vector < BCInfo<Field> > & bc
+    )
+    {
+        return scinew amr_interpolator < Field, Problem, Index, get_fc<C2F>::fci, DIM > ( m_label, m_subproblems_label, m_material ); // deleted by bc_fd_FineCoarseInterface destructor
+    }
+
+    /**
+     * Modify the given region bounds to avoid to retrieved from DataWarehouse
+     * values that should instead be computed as per imposed boundary conditions
+     *
+     * @param low [in,out] lower bound
+     * @param high [in,out] requested upper bound
+     * @return unused value (to allow call in array initialization for variadic
+     * template expansions)
+     */
+    template <BCF Q>
+    bool adjust_dw_region (
+        IntVector & low,
+        IntVector & high
+    )
+    {
+        constexpr Patch::FaceType F = get_bcf<Q>::face;
+        constexpr DirType D = get_face<F>::dir;
+        constexpr int SGN = get_face<F>::sgn;
+        if ( SGN > 0 ) // F=D+
+            high[D] -= GN ;
+        else // F=D-
+            low[D] += GN;
+        return true;
+    }
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region for inner
+     * dw_view
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    void
+    set_dw (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    )
+    {
+        m_dw_view->set ( dw, level, low, high, use_ghosts );
+        IntVector l { low };
+        IntVector h { high };
+        if ( use_ghosts )
+        {
+            l -= get_dim<DIM>::template scalar_vector<GN>();
+            h += get_dim<DIM>::template scalar_vector<GN>();
+            std::array<bool, N> {{ adjust_dw_region<P> ( l, h )... }};
+        }
+        m_support.emplace_back ( l, h );
+    }
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region for inner
+     * bc_view
+     *
+     * @tparam J index of the bc
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    template < size_t J >
+    bool
+    set_bc (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    )
+    {
+        basic_fd_view<Field, STN> * bc_view = std::get<J> ( m_bc_view ).get();
+        bc_view->set ( dw, level, low, high, use_ghosts );
+        if ( get_bcf< Q[J] >::bc != BC::FineCoarseInterface )
+            m_support.splice ( m_support.end(), bc_view->get_support() );
+        return true;
+    }
+
+private: // INDEXED VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * Retrieve data for all internal views
+     *
+     * @tparam J indices for boundary views
+     * @param unused to allow template argument deduction
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    template < size_t ... J >
+    void
+    set (
+        index_sequence<J...>,
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    )
+    {
+        m_support.clear();
+        set_dw ( dw, level, low, high, use_ghosts );
+        std::array<bool, N> {{ set_bc<J> ( dw, level, low, high, use_ghosts ) ... }};
+    }
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    bcs_basic_fd_view (
+        const bcs_basic_fd_view * copy,
+        bool deep
+    ) : bcs_basic_fd_view ( make_index_sequence<N> {}, copy, deep )
+    {
+    }
+
+public: // CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param label unused since value is already in view
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material unused since value is already in view
+     * @param level fine grid level
+     * @param bcs vector with info on the boundary conditions
+     */
+    bcs_basic_fd_view (
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        const std::vector < BCInfo<Field> > & bcs
+    ) : bcs_basic_fd_view ( make_index_sequence<N> {}, label, subproblems_label, material, level, bcs )
+    {
+    }
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label label of variable in the DataWarehouse
+     * @param subproblems_label label of subproblems in the DataWarehouse
+     * @param material index of material in the DataWarehouse
+     * @param patch grid patch
+     * @param bcs vector with info on the boundary conditions
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    bcs_basic_fd_view (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        const std::vector < BCInfo<Field> > & bcs,
+        bool use_ghosts
+    ) : m_label ( label ),
+        m_subproblems_label ( subproblems_label ),
+        m_material ( material )
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    }
+
+    /// Destructor
+    ~bcs_basic_fd_view () = default;
+
+    /// Prevent copy (and move) constructor
+    bcs_basic_fd_view ( const bcs_basic_fd_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    bcs_basic_fd_view & operator= ( const bcs_basic_fd_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @remark bcs_basic_fd_view should not be set to range over a patch
+     *
+     * @param dw unused
+     * @param patch unused
+     * @param use_ghosts unused
+     */
+    virtual void
+    set (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Patch * _DOXYARG ( patch ),
+        bool _DOXYARG ( use_ghosts )
+    ) override
+    {
+        ASSERTFAIL ( "cannot set bc_fd over a patch" );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * Retrieve data for all internal views
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        set ( make_index_sequence<N> {}, dw, level, low, high, use_ghosts );
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    ) const override
+    {
+        return scinew bcs_basic_fd_view ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    ) const override
+    {
+        return scinew virtual_view<bcs_basic_fd_view, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief Get the region for which the view has access to the DataWarehouse
+     *
+     * It is the boundary region plus ghosts
+     *
+     * @return support of the view
+     */
+    virtual
+    Support
+    get_support()
+    const override
+    {
+        return m_support;
+    };
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual
+    bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        for ( auto & region : m_support )
+        {
+            IntVector low { region.getLow() }, high { region.getHigh() };
+            if ( ( low[X] <= id[X] && id[X] < high[X] ) &&
+                    ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+                    ( low[Z] <= id[Z] && id[Z] < high[Z] ) )
+                return true;
+        }
+        return false;
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view
+     *
+     * @return non const pointer to base view implementation
+     */
+    virtual view<Field> *
+    get_view()
+    override
+    {
+        return this;
+    }
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual const view<Field> *
+    get_view()
+    const override
+    {
+        return this;
+    }
+
+    /**
+     * @brief Partial x derivative
+     *
+     * First order derivative along x at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dx (
+        const IntVector & id
+    ) const override
+    {
+        return m_fd_view[X]->dx ( id );
+    }
+
+    /**
+     * @brief Partial y derivative
+     *
+     * First order derivative along y at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dy (
+        const IntVector & id
+    ) const override
+    {
+        return m_fd_view[Y]->dy ( id );
+    }
+
+    /**
+     * @brief Partial z derivative
+     *
+     * First order derivative along z at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dz (
+        const IntVector & id
+    ) const override
+    {
+        return m_fd_view[Z]->dz ( id );
+    };
+
+    /**
+     * @brief Partial x second order derivative
+     *
+     * Second order derivative along x at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dxx (
+        const IntVector & id
+    ) const override
+    {
+        return m_fd_view[X]->dxx ( id );
+    }
+
+    /**
+     * @brief Partial y second order derivative
+     *
+     * Second order derivative along y at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dyy (
+        const IntVector & id
+    ) const override
+    {
+        return m_fd_view[Y]->dyy ( id );
+    }
+
+    /**
+     * @brief Partial z second order derivative
+     *
+     * Second order derivative along z at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dzz (
+        const IntVector & id
+    ) const override
+    {
+        return m_fd_view[Z]->dzz ( id );
+    }
+
+}; // bcs_basic_fd_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_bcs_basic_fd_view_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/get_bc.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/get_bc.h
new file mode 100644
index 00000000..c3285eca
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/get_bc.h
@@ -0,0 +1,237 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/get_bc.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_get_bc_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_get_bc_h
+
+#include <CCA/Components/PhaseField/DataTypes/BCInfo.h>
+
+#include <Core/Grid/BoundaryConditions/BCDataArray.h>
+#include <Core/Grid/BoundaryConditions/BoundCond.h>
+#include <Core/Exceptions/InvalidValue.h>
+#include <CCA/Components/PhaseField/Util/Expressions.h>
+#include <CCA/Components/PhaseField/DataTypes/ScalarField.h>
+#include <CCA/Components/PhaseField/DataTypes/VectorField.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Get boundary conditions on one face static functor
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ */
+template<typename Field>
+class get_bc
+    _DOXYBDY (
+        /// Execute the functor
+        inline static BCInfo<Field> exec = 0;
+    );
+
+/**
+ * @brief Get boundary conditions on one face static functor
+ * (ScalarField implementation)
+ *
+ * Allows to get the boundary value for a given variable label on a given
+ * boundary face (face, child) of the given patch.
+ *
+ * @remark Refactor of getBCValue function in Core/Grid/BoundaryConditions/BCUtils.h
+ *
+ * @implements get_bc < Field >
+ */
+template<typename T>
+class get_bc< ScalarField<T> >
+{
+    using Field = ScalarField<T>;
+
+public:
+    /**
+     * @brief Execute the functor
+     *
+     * If patch getBCType is Patch::Coarse it also populate the output c2f field
+     * with the relevant value from the c2f map in input
+     * Otherwise, if getBCType is specified but not "simmetry", retrieves the
+     * values required to enforce the boundary conditions specified in input.
+     *
+     * @param patch grid patch to be checked
+     * @param face face to check
+     * @param child bc index (it is possible to specify multiple bc for the same variable)
+     * @param material problem material index
+     * @param label variable label to check
+     * @param c2f which fine/coarse interface conditions to use on each variable
+     * @param[in,out] flag flag to check if any bc is applied to the given face
+     * @return Retrieved boundary conditions information
+     */
+    BCInfo<Field>
+    static exec (
+        Patch const * patch,
+        const Patch::FaceType & face,
+        const int & child,
+        const int & material,
+        const VarLabel * const & label,
+        const std::map<std::string, FC> * c2f,
+        bool & flag
+    )
+    {
+        BCInfo<Field> bci { T{}, BC::Unknown, FC::None };
+
+        const std::string & desc = label->getName();
+        if ( patch->getBCType ( face ) == Patch::Coarse )
+        {
+            ASSERTMSG ( c2f, "null c2f map in get_bc" );
+            ASSERTMSG ( c2f->find ( desc ) != c2f->end(), "desc not found in c2f map in get_bc" );
+            bci.bc = BC::FineCoarseInterface;
+            bci.c2f = c2f->at ( desc );
+        }
+        else if ( patch->getBCType ( face ) == Patch::Neighbor )
+        {
+            bci.bc = BC::None;
+        }
+        else if ( const BCDataArray * data = patch->getBCDataArray ( face ) )
+        {
+            if ( const BoundCondBase * info = data->getBoundCondData ( material, desc, child ) )
+            {
+                if ( const BoundCond<double> * _info = dynamic_cast<const BoundCond<double> *> ( info ) )
+                {
+                    bci.bc = str_to_bc ( _info->getBCType() );
+                    bci.value = _info ->getValue();
+                }
+                delete info;
+            }
+            else if ( const BoundCondBase * info = data->getBoundCondData ( material, "Symmetric", child ) )
+            {
+                if ( info->getBCType() == "symmetry" )
+                    bci.bc = BC::Symmetry;
+                delete info;
+            }
+        }
+
+        switch ( bci.bc )
+        {
+        case BC::Unknown:
+        {
+            std::ostringstream msg;
+            msg << "\n ERROR: Unknown BC condition on patch " << *patch << " face " << face << std::endl;
+            SCI_THROW ( InvalidValue ( msg.str(), __FILE__, __LINE__ ) );
+        }
+        break;
+        case BC::None:
+            break;
+        default:
+            flag = true;
+        }
+        return bci;
+    }
+};
+
+/**
+ * @brief Get boundary conditions on one face static functor
+ * (VectorField implementation)
+ *
+ * Allows to get the boundary value for a given variable label on a given
+ * boundary face (face, child) of the given patch.
+ *
+ * @implements get_bc < Field >
+ */
+template<typename T, size_t N>
+class get_bc < VectorField<T, N> >
+{
+    using Field = VectorField<T, N>;
+
+    /**
+     * @brief Execute the functor (internal indexed implementation)
+     *
+     * For each component call the ScalarField implementation
+     *
+     * @tparam J list of components' indices
+     * @param patch grid patch to be checked
+     * @param face face to check
+     * @param child bc index (it is possible to specify multiple bc for the same variable)
+     * @param material problem material index
+     * @param label variable label to check
+     * @param c2f which fine/coarse interface conditions to use on each variable
+     * @param[in,out] flag flag to check if any bc is applied to the given face
+     * @return Retrieved boundary conditions information
+     */
+    template < size_t ... J >
+    inline static BCInfo<Field>
+    exec (
+        index_sequence<J...>,
+        Patch const * patch,
+        const Patch::FaceType & face,
+        const int & child,
+        const int & material,
+        const typename Field::label_type & label,
+        const std::map<std::string, FC> * c2f,
+        bool & flag
+    )
+    {
+        return { get_bc< ScalarField<T> >::exec ( patch, face, child, material, std::get<J> ( label ), c2f, flag )... };
+    }
+
+public:
+    /**
+     * @brief Execute the functor
+     *
+     * For each component call the internal indexed implementation
+     *
+     * @param patch grid patch to be checked
+     * @param face face to check
+     * @param child bc index (it is possible to specify multiple bc for the same variable)
+     * @param material problem material index
+     * @param label variable label to check
+     * @param c2f which fine/coarse interface conditions to use on each variable
+     * @param[in,out] flag flag to check if any bc is applied to the given face
+     * @return Retrieved boundary conditions information
+     */
+    inline static BCInfo<Field>
+    exec (
+        Patch const * patch,
+        const Patch::FaceType & face,
+        const int & child,
+        const int & material,
+        const std::array<const VarLabel *, N> & label,
+        const std::map<std::string, FC> * c2f,
+        bool & flag
+    )
+    {
+        return exec ( make_index_sequence<N> {}, patch, face, child, material, label, c2f, flag );
+    }
+};
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_get_bc_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/get_bcs.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/get_bcs.h
new file mode 100644
index 00000000..263e2c7b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/get_bcs.h
@@ -0,0 +1,117 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/get_bcs.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_get_bcs_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_get_bcs_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/Util/Expressions.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/get_bc.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Get boundary conditions on multiple faces static functor
+ *
+ * @tparam DIM problem dimension
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ */
+template<DimType DIM, typename Field>
+class get_bcs
+{
+    /**
+     * @brief Execute the functor (internal indexed implementation)
+     *
+     * For each face F call get_bc and build an array of BCInfo for the variable
+     * identified by the given label on the given patch
+     *
+     * @tparam F list of faces to check
+     * @param patch grid patch to be checked
+     * @param material problem material index
+     * @param label variable label to check
+     * @param c2f which fine/coarse interface conditions to use on each variable
+     * @param[in,out] flags array of flags to check if any bc is applied to each one of faces
+     * @return array of BCInfo
+     */
+    template < size_t... F >
+    inline static std::array < BCInfo<Field>, get_dim<DIM>::face_end >
+    exec (
+        index_sequence<F...>,
+        const Patch * patch,
+        const int & child,
+        const int & material,
+        const typename Field::label_type & label,
+        const std::map<std::string, FC> * c2f,
+        std::array<bool, get_dim<DIM>::face_end> & flags
+    )
+    {
+        return { get_bc<Field>::exec ( patch, ( Patch::FaceType ) F, child, material, label, c2f, flags[F] )... };
+    }
+
+public:
+    /**
+     * @brief Execute the functor
+     *
+     * For each face constuct the list of faces for the patch and call the
+     * internal indexed implementation
+     *
+     * @tparam F list of faces to check
+     * @param patch grid patch to be checked
+     * @param child child index of face boundary condition (as per input file)
+     * @param material problem material index
+     * @param label variable label to check
+     * @param c2f which fine/coarse interface conditions to use on each variable
+     * @param[in,out] flags array of flags to check if any bc is applied to each one of faces
+     * @return array of BCInfo
+     */
+    inline static std::array < BCInfo<Field>, get_dim<DIM>::face_end >
+    exec (
+        const Patch * patch,
+        const int & child,
+        const int & material,
+        const typename Field::label_type & label,
+        const std::map<std::string, FC> * c2f,
+        std::array<bool, get_dim<DIM>::face_end> & flags
+    )
+    {
+        return exec ( make_index_sequence < get_dim<DIM>::face_end > {}, patch, child, material, label, c2f, flags );
+    }
+};
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_get_bcs_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/partition_range.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/partition_range.h
new file mode 100644
index 00000000..e8efed56
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/partition_range.h
@@ -0,0 +1,122 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/partition_range.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_partition_range_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_partition_range_h
+
+#include <CCA/Components/PhaseField/DataTypes/Problem.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Partition range static functor
+ *
+ * @tparam DIR Direction to be partitioned
+ * @tparam GN Number of ghosts required
+ * @tparam DONE Number of directions already partitioned (for internal checks)
+ * @tparam Field list of type of fields (ScalarField < T > or VectorField < T, N >)
+ */
+template <DirType DIR, int GN, int DONE, typename... Field>
+struct partition_range
+{
+    /**
+     * @brief Execute the functor
+     *
+     * Check if boundary conditions are applied to DIR plus and minus faces and
+     * partition the range accordingly, then iterate on each partition on lower
+     * directions
+     * Problems are instantiated only on lowest direction
+     *
+     * @tparam VAR type of variable representation
+     * @tparam STN finite-difference stencil
+     * @param labels list of labels for each variable of the problem
+     * @param subproblems_label label for subproblems in the DW (required by AMR boundary Problems)
+     * @param material index of material in the DataWarehouse
+     * @param level grid level to be partitions
+     * @param low lower bound of the region to partition
+     * @param high higher bound of the region to partition
+     * @param faces list of faces on which boundary conditions are applied
+     * @param bcs list of arrays of BC info for each one of face of the patch for each one of the problem labels
+     * @param flags array of flags to check if any bc is applied to each one of faces
+     * @param[out] problems list of subproblems to populate
+     */
+    template < VarType VAR, StnType STN >
+    static void
+    exec (
+        const typename Field::label_type & ... labels,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        IntVector low,
+        IntVector high,
+        std::list<Patch::FaceType> faces,
+        const std::array < BCInfo<Field>, 2 * get_stn<STN>::dim > & ... bcs,
+        std::array < bool, 2 * get_stn<STN>::dim > & flags,
+        std::list < Problem<VAR, STN, Field...> > & problems
+    )
+    {
+        static_assert ( get_dim < ( DimType ) ( get_stn<STN>::dim - DONE ) >::highest_dir == DIR, "cannot partition along DIR if higher directions have not been processed yet" );
+
+        if ( flags [ get_dir<DIR>::plus_face ] )
+        {
+            IntVector l {low};
+            l[DIR] = high[DIR] - GN;
+            auto f = faces;
+            f.emplace_front ( get_dir<DIR>::plus_face );
+            partition_range < get_dir<DIR>::lower, GN, DONE + 1, Field... >::template exec<VAR, STN> ( labels..., subproblems_label, material, level, l, high, f, bcs..., flags, problems );
+            high[DIR] -= GN;
+        }
+
+        if ( flags [ get_dir<DIR>::minus_face ] )
+        {
+            IntVector h {high};
+            h[DIR] = low[DIR] + GN;
+            auto f = faces;
+            f.emplace_front ( get_dir<DIR>::minus_face );
+            partition_range < get_dir<DIR>::lower, GN, DONE + 1, Field... >::template exec<VAR, STN> ( labels..., subproblems_label, material, level, low, h, f, bcs..., flags, problems );
+            low[DIR] += GN;
+        }
+
+        partition_range < get_dir<DIR>::lower, GN, DONE + 1, Field... >::template exec<VAR, STN> ( labels..., subproblems_label, material, level, low, high, faces, bcs..., flags, problems );
+    }
+};
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#include <CCA/Components/PhaseField/BoundaryConditions/detail/partition_range_X.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_partition_range_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/detail/partition_range_X.h b/src/CCA/Components/PhaseField/BoundaryConditions/detail/partition_range_X.h
new file mode 100644
index 00000000..b113cab3
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/detail/partition_range_X.h
@@ -0,0 +1,162 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/BoundaryConditions/detail/partition_range_X.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_partition_range_X_h
+#define Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_partition_range_X_h
+
+#include <CCA/Components/PhaseField/DataTypes/Problem.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Partition range static functor (X direction implementation)
+ *
+ * @tparam GN Number of ghosts required
+ * @tparam DONE Number of directions already partitioned (for internal checks)
+ * @tparam Field list of type of fields (ScalarField < T > or VectorField < T, N >)
+ */
+template<int GN, int DONE, typename... Field>
+class partition_range<X, GN, DONE, Field...>
+{
+    template<typename V> using VarLabels = VarLabel;
+
+private:
+    static constexpr size_t N = sizeof... ( Field );
+
+    /**
+     * @brief Assemble BCInfo vector for one problem variable
+     *
+     * Rearrange BCInfo's for each one of the faces from the bcs array
+     *
+     * @tparam DIM problem dimension
+     * @tparam F type of field (ScalarField < T > or VectorField < T, N >)
+     * @param faces list of faces on which boundary conditions are applied
+     * @param bcs BC info for each one of face of the patch for the given variable
+     */
+    template<DimType DIM, typename F>
+    static std::vector < BCInfo<F> >
+    make_bc_vector (
+        std::list<Patch::FaceType> faces,
+        const std::array < BCInfo<F>, 2 * DIM > & bcs
+    )
+    {
+        std::vector < BCInfo<F> > vect;
+        vect.reserve ( faces.size() );
+        for ( auto face : faces )
+            vect.push_back ( bcs[face] );
+        return vect;
+    }
+
+public:
+    /**
+     * @brief Execute the functor
+     *
+     * Check if boundary conditions are applied to xplus and xminus faces and
+     * partition the range accordingly, then instantiate all problems
+     *
+     * @tparam VAR type of variable representation
+     * @tparam STN finite-difference stencil
+     * @param labels list of labels for each variable of the problem
+     * @param subproblems_label label for subproblems in the DW (required by AMR boundary Problems)
+     * @param material index of material in the DataWarehouse
+     * @param level grid level to be partitions
+     * @param low lower bound of the region to partition
+     * @param high higher bound of the region to partition
+     * @param faces list of faces on which boundary conditions are applied
+     * @param bcs list of arrays of BC info for each one of face of the patch for each one of the problem labels
+     * @param flags array of flags to check if any bc is applied to each one of faces
+     * @param[out] problems list of subproblems to populate
+     */
+    template < VarType VAR, StnType STN >
+    static void
+    exec (
+        const typename Field::label_type & ... labels,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        IntVector low,
+        IntVector high,
+        std::list<Patch::FaceType> faces,
+        const std::array < BCInfo<Field>, 2 * get_stn<STN>::dim > & ... bcs,
+        std::array<bool, 2 * get_stn<STN>::dim> & flags,
+        std::list < Problem<VAR, STN, Field...> > & problems
+    )
+    {
+        static constexpr DimType DIM = get_stn<STN>::dim;
+
+        static_assert ( get_dim < ( DimType ) ( DIM - DONE ) >::highest_dir == X, "cannot partition along X if higher directions have not been processed yet" );
+
+        if ( flags [ Patch::xplus ] )
+        {
+            IntVector l {low};
+            l[X] = high[X] - GN;
+            auto f = faces;
+            f.emplace_front ( Patch::xplus );
+
+            // create new boundary problem
+            problems.emplace_front ( labels..., subproblems_label, material, level, l, high, f, make_bc_vector<DIM, Field> ( f, bcs )... );
+            high[X] -= GN;
+        }
+
+        if ( flags [ Patch::xminus ] )
+        {
+            IntVector h {high};
+            h[X] = low[X] + GN;
+            auto f = faces;
+            f.emplace_front ( Patch::xminus );
+
+            // create new boundary problem
+            problems.emplace_front ( labels..., subproblems_label, material, level, low, h, f, make_bc_vector<DIM, Field> ( f, bcs )... );
+            low[X] += GN;
+        }
+
+        if ( faces.size() )
+        {
+            // create new boundary problem
+            problems.emplace_front ( labels..., subproblems_label, material, level, low, high, faces, make_bc_vector<DIM, Field> ( faces, bcs )... );
+        }
+        else
+        {
+            // create new inner problem
+            problems.emplace_front ( labels..., material, level, low, high );
+        }
+    }
+};
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_BoundaryConditions_detail_partition_range_X_h
diff --git a/src/CCA/Components/PhaseField/BoundaryConditions/sub.mk b/src/CCA/Components/PhaseField/BoundaryConditions/sub.mk
new file mode 100644
index 00000000..6f1aa5e7
--- /dev/null
+++ b/src/CCA/Components/PhaseField/BoundaryConditions/sub.mk
@@ -0,0 +1,38 @@
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+#
+#
+#
+#
+# Makefile fragment for this subdirectory
+
+SRCDIR := CCA/Components/PhaseField/BoundaryConditions
+
+SRCS += \
+  $(SRCDIR)/BCFDViewFactory-bld.cc \
+
+BLDDIR := $(SRCTOP)/$(SRCDIR)
+
+BLDSRCS += \
+  $(BLDDIR)/BCFDViewFactory-bld.cc \
diff --git a/src/CCA/Components/PhaseField/DataTypes/BCInfo.h b/src/CCA/Components/PhaseField/DataTypes/BCInfo.h
new file mode 100644
index 00000000..f756c701
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/BCInfo.h
@@ -0,0 +1,115 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataTypes/BCInfo.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataTypes_BCInfo_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataTypes_BCInfo_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/DataTypes/ScalarField.h>
+#include <CCA/Components/PhaseField/DataTypes/VectorField.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Boundary Condition Information
+ *
+ * Stores the type of boundary conditions, o fine coarse interpolation and the
+ * value to impose on a boundary face
+ *
+ * @tparam Field type of field of the variable on which the condition is applied
+ */
+template<typename Field> struct BCInfo;
+
+/**
+ * @brief Boundary Condition Information (ScalarField implementation)
+ *
+ * Stores the type of boundary conditions, o fine coarse interpolation and the
+ * value to impose on a boundary face
+ *
+ * @tparam T type of the field value at each point
+ */
+template<typename T>
+struct BCInfo< ScalarField<T> >
+{
+    /// value to impose on boundary
+    typename std::remove_const<T>::type value;
+
+    /// Type of boundary conditions
+    BC bc;
+
+    /// type of fine/coarse interface conditions
+    FC c2f;
+};
+
+/**
+ * @brief Boundary Condition Information (VectorField implementation)
+ *
+ * Stores the type of boundary conditions, o fine coarse interpolation and the
+ * value to impose on a boundary face
+ *
+ * @tparam T type of each component of the field at each point
+ * @tparam N number of components
+ */
+template<typename T, size_t N>
+struct BCInfo< VectorField<T, N> >
+{
+    /// array of values to impose on boundary
+    std::array < typename std::remove_const<T>::type, N > value;
+
+    /// Type of boundary conditions
+    BC bc;
+
+    /// type of fine/coarse interface conditions
+    FC c2f;
+
+    /**
+     * @brief Constructor
+     *
+     * From a list of BCInfo
+     * @tparam I0 first BCInfo type
+     * @tparam I following BCInfo types
+     * @param i0 first BCInfo
+     * @param i following BCInfo's
+     */
+    template<typename I0, typename... I>
+    BCInfo ( I0 && i0, I && ... i ) :
+        value { std::forward<T> ( i0.value ), std::forward<T> ( i.value )... },
+          bc ( i0.bc ),
+          c2f ( i0.c2f )
+    {};
+};
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataTypes_BCInfo_h
diff --git a/src/CCA/Components/PhaseField/DataTypes/Problem.h b/src/CCA/Components/PhaseField/DataTypes/Problem.h
new file mode 100644
index 00000000..902df980
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/Problem.h
@@ -0,0 +1,485 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataTypes/Problem.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Problem_h
+#define Packages_Uintah_CCA_Components_PhaseField_Problem_h
+
+#include <CCA/Components/PhaseField/DataTypes/BCInfo.h>
+#include <CCA/Components/PhaseField/Views/View.h>
+#include <CCA/Components/PhaseField/Views/FDView.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWFDView.h>
+#include <CCA/Components/PhaseField/BoundaryConditions/BCFDViewFactory.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief PhaseField Problem
+ *
+ * It represent one portion of the global problem on which all implementations
+ * required to solve a timestep are fixed (i.e: there is no need to check boundary
+ * conditions/variables extents/neighbors...)
+ * @tparam VAR type of variable representation
+ * @tparam STN finite-difference stencil
+ * @tparam Field list of type of fields (ScalarField < T > or VectorialField < T, N >)
+ */
+template <VarType VAR, StnType STN, typename... Field>
+class Problem
+{
+public: // STATIC MEMBERS
+
+    /// Problem data representation
+    static constexpr VarType Var = VAR;
+
+    /// Problem dimension
+    static constexpr DimType Dim = get_stn<STN>::dim;
+
+    /// Finite difference stencil
+    static constexpr StnType Stn = STN;
+
+
+    /// class name as used by ApplicationFactory
+    static const std::string Name;
+
+
+public: // TYPE HELPERS
+
+    /**
+     * @brief Field Type Helper
+     *
+     * Allow to get the type of the Field represented by the I-th Problem variable
+     *
+     * @tparam I index of the variable within the Problem
+     * @tparam J component indexes of the variable (used with higher dimensional fields)
+     */
+    template<size_t I, size_t... J>
+    struct get_field
+    {
+        /// Type hekpof the Field represented by the [J..]-th component of the I-th Problem variable
+        using type = typename std::tuple_element < I, std::tuple<Field...> >::type::template elem_type<J...>;
+    };
+
+    /**
+     * @brief Field Type Helper (ScalarField implementation)
+     *
+     * Allow to get the type of the Field represented by the I-th Problem variable
+     *
+     * @tparam I index of the variable within the Problem
+     */
+    template<size_t I>
+    struct get_field<I>
+    {
+        /// Type helper of the Field represented by the I-th Problem variable
+        using type = typename std::tuple_element < I, std::tuple<Field...> >::type;
+    };
+
+    /// View type for the I-th Problem variable (J-th component)
+    template<size_t I, size_t... J> using get_view_type = View < typename get_field<I, J...>::type >;
+
+    /// FDView type for the I-th Problem variable (J-th component)
+    template<size_t I, size_t... J> using get_fd_view_type = FDView < typename get_field<I, J...>::type, STN >;
+
+
+private: // MEMBERS
+
+    /// Grid Level on wich the Problem is defined
+    const Level * m_level;
+
+    /// Lower bound of the region where the problem is defined
+    IntVector m_low;
+
+    /// Higher bound of the region where the problem is defined
+    IntVector m_high;
+
+    /// Faces on which the problem is defined (empty for inner problems)
+    const std::list< Patch::FaceType > m_face;
+
+    /// Labels for problem variables
+    const std::tuple< typename Field::label_type... > m_labels;
+
+    /// Container for the finite-differences implementations for the problem variables
+    const std::tuple< std::unique_ptr< FDView<Field, STN> > ... > m_fd_view;
+
+private: // INDEXED CONSTRUCTOR
+
+    /**
+     * @brief Boundary Problem constructor
+     *
+     * Instantiate all subviews required to handle all given variables in the
+     * given region without retrieving data.
+     *
+     * @remark There is no need to recreate these
+     * views until the geometry is unchanged
+     *
+     * @tparam I indices for variables
+     * @param unused to allow template argument deduction
+     * @param labels list of the labels for the variables to handle
+     * @param subproblems_label label for subproblems in the DataWarehouse
+     * @param material index in the DataWarehouse
+     * @param level grid level
+     * @param low lower bound of the region to handle
+     * @param high higher bound of the region to handle
+     * @param faces list of faces the new (sub)problem have to handle
+     * @param bcs boundary info for each variable and face
+     */
+    template < size_t ... I >
+    Problem (
+        index_sequence<I...>,
+        const typename Field::label_type & ... labels,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        IntVector low,
+        IntVector high,
+        const std::list<Patch::FaceType> & faces,
+        std::vector< BCInfo<Field> > ... bcs
+    ) : m_level ( level ),
+        m_low ( low ),
+        m_high ( high ),
+        m_face ( faces ),
+        m_labels { labels... },
+             m_fd_view ( std::unique_ptr< FDView<Field, STN> > { BCFDViewFactory<Problem, I>::create ( labels, subproblems_label, material, level, faces, bcs ) } ... )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Inner Problem constructor
+     *
+     * Instantiate all the views required to handle all given variables in the
+     * given region without retrieving data.
+     *
+     * @remark There is no need to recreate the
+     * views until the geometry is unchanged
+     *
+     * @param labels list of the labels for the variables to handle
+     * @param material index in the DataWarehouse
+     * @param level grid level
+     * @param low lower bound of the region to handle
+     * @param high higher bound of the region to handle
+     */
+    Problem (
+        const typename Field::label_type & ... labels,
+        int material,
+        const Level * level,
+        IntVector low,
+        IntVector high
+    ) : m_level ( level ),
+        m_low ( low ),
+        m_high ( high ),
+        m_face (),
+        m_labels { labels... },
+             m_fd_view { std::unique_ptr< FDView<Field, STN> > { scinew DWFDView<Field, STN, VAR> ( labels, material, level ) } ... }
+    {}
+
+    /**
+     * @brief Boundary constructor
+     *
+     * Instantiate all subviews required to handle all given variables in the
+     * given region without retrieving data. There is no need to recreate the
+     * views until the geometry is unchanged
+     *
+     * @param labels list of the labels for the variables to handle
+     * @param subproblems_label label for subproblems in the DataWarehouse
+     * @param material index in the DataWarehouse
+     * @param level grid level
+     * @param low lower bound of the region to handle
+     * @param high higher bound of the region to handle
+     * @param faces list of faces the new (sub)problem have to handle
+     * @param bcs boundary info for each variable and face
+     */
+    Problem (
+        const typename Field::label_type & ... labels,
+        const VarLabel * subproblems_label,
+        int material,
+        const Level * level,
+        IntVector low,
+        IntVector high,
+        const std::list<Patch::FaceType> & faces,
+        std::vector< BCInfo<Field> > ... bcs
+    ) : Problem ( make_index_sequence<sizeof... ( labels ) > {}, labels..., subproblems_label, material, level, low, high, faces, bcs... )
+    {
+    }
+
+    /**
+     * @brief Get Codimension
+     *
+     * Return the codimension of the variety on which the problem is defined
+     *
+     * @return the number of faces that define the variety
+     */
+    inline int
+    get_codim()
+    const
+    {
+        return m_face.size();
+    }
+
+    /**
+     * @brief Get Problem range
+     *
+     * @return Range on which the Problem is defined
+     */
+    inline BlockRange
+    get_range()
+    const
+    {
+        return { m_low, m_high };
+    }
+
+    /**
+     * @brief Get Problem lower bound
+     *
+     * @return low index
+     */
+    inline const IntVector &
+    get_low()
+    const
+    {
+        return m_low;
+    }
+
+    /**
+     * @brief Get Problem higher bound
+     *
+     * @return high index
+     */
+    inline const IntVector &
+    get_high()
+    const
+    {
+        return m_high;
+    }
+
+    /**
+     * @brief Get problem faces
+     *
+     * @return list of faces which the problem region belongs to
+     */
+    inline
+    const std::list<Patch::FaceType> &
+    get_faces()
+    const
+    {
+        return m_face;
+    }
+
+    /**
+     * @brief Get a View
+     *
+     * Get the View of the I-th Problem variable without retrieving data
+     *
+     * @tparam I index of the variable within the Problem
+     * @return a view to the variable
+     */
+    template<size_t I>
+    inline get_view_type<I> &
+    get_view ()
+    const
+    {
+        return * std::get<I> ( m_fd_view )->get_view();
+    }
+
+    /**
+     * @brief Get a View
+     *
+     * Get the View of the I-th Problem variable and retrieve the data from dw
+     *
+     * @tparam I index of the variable within the Problem
+     * @param dw DataWarehouse to use for retrieving data
+     * @return a view to the variable
+     */
+    template<size_t I>
+    inline get_view_type<I> &
+    get_view (
+        DataWarehouse * dw
+    ) const
+    {
+        get_view_type<I> * view { std::get<I> ( m_fd_view )->get_view() };
+        view->set ( dw, m_level, m_low, m_high );
+        return *view;
+    }
+
+    /**
+     * @brief Get a View
+     *
+     * Get the View of the J-th component of the I-th Problem variable without
+     * retrieving data
+     *
+     * @tparam I index of the variable within the Problem
+     * @tparam J index of the component within the variable
+     * @return a view to the variable
+     */
+    template<size_t I, size_t J>
+    inline get_view_type<I, J> &
+    get_view (
+    ) const
+    {
+        return * std::get<I> ( m_fd_view )->operator[] ( J ).get_view();
+    }
+
+    /**
+     * @brief Get a View
+     *
+     * Get the View of the J-th component of the I-th Problem variable and
+     * retrieve the data from dw
+     *
+     * @tparam I index of the variable within the Problem
+     * @tparam J index of the component within the variable
+     * @param dw DataWarehouse to use for retrieving data
+     * @return a view to the variable
+     */
+    template<size_t I, size_t J>
+    inline get_view_type<I, J> &
+    get_view (
+        DataWarehouse * dw
+    ) const
+    {
+        get_view_type<I, J> * view = std::get<J> ( std::get<I> ( m_fd_view ) )->get_view();
+        view->set ( dw, m_level, m_low, m_high );
+        return *view;
+    }
+
+    /**
+     * @brief Get a FDView
+     *
+     * Get the FDView of the I-th Problem variable without retrieving data
+     *
+     * @tparam I index of the variable within the Problem
+     * @return a view to the variable that implements finite-differences
+     */
+    template< size_t I >
+    inline get_fd_view_type<I> &
+    get_fd_view ()
+    const
+    {
+        return * std::get<I> ( m_fd_view ).get();
+    }
+
+    /**
+     * @brief Get a FDView
+     *
+     * Get the FDView of the I-th Problem variable and retrieves the data from dw
+     *
+     * @tparam I index of the variable within the Problem
+     * @param dw DataWarehouse to use for retrieving data
+     * @return a view to the variable that implements finite-differences
+     */
+    template< size_t I >
+    inline get_fd_view_type<I> &
+    get_fd_view (
+        DataWarehouse * dw
+    ) const
+    {
+        get_fd_view_type<I> * view { std::get<I> ( m_fd_view ).get() };
+        view->set ( dw, m_level, m_low, m_high );
+        return *view;
+    }
+
+    /**
+     * @brief Get a FDView
+     *
+     * Get the FDView of the J-th component of the I-th Problem variable
+     * without retrieving data
+     *
+     * @tparam I index of the variable within the Problem
+     * @tparam J index of the component within the variable
+     * @return a view to the variable that implements finite-differences
+     */
+    template<size_t I, size_t J>
+    inline get_fd_view_type<I, J> &
+    get_fd_view ()
+    const
+    {
+        return * std::get<I> ( m_fd_view ).get();
+    }
+
+    /**
+     * @brief Get a FDView
+     *
+     * Get the FDView of the J-th component of the I-th Problem variable and
+     * retrieves the data from dw
+     *
+     * @tparam I index of the variable within the Problem
+     * @tparam J index of the component within the variable
+     * @param dw DataWarehouse to use for retrieving data
+     * @return a view to the variable that implements finite-differences
+     */
+    template<size_t I, size_t J>
+    inline get_fd_view_type<I, J> &
+    get_fd_view (
+        DataWarehouse * dw
+    ) const
+    {
+        get_fd_view_type<I> * view { std::get<I> ( m_fd_view ).get() };
+        view->set ( dw, m_level, m_low, m_high );
+        return *view;
+    }
+
+}; // class Problem
+
+/**
+ * @brief Insertion operator between Problem and std::ostream
+ *
+ * Used for debug purposes
+ *
+ * @param os output stream reference
+ * @param p problem to output
+ * @return output stream reference for concatenation
+ */
+template <PhaseField::VarType VAR, PhaseField::StnType STN, typename... T>
+std::ostream &
+operator<< (
+    std::ostream & os,
+    const PhaseField::Problem<VAR, STN, T...> & p
+)
+{
+    if ( p.get_codim() )
+    {
+        os << "Boundary Problem (";
+        auto faces = p.get_faces();
+        for ( const auto & f : faces )
+        {
+            os << f;
+            if ( f != faces.back() ) os << ",";
+        }
+        os << ") range " << p.get_range();
+    }
+    else
+        os << "Inner Problem : range " << p.get_range();
+    return os;
+}
+
+} // namespace PhaseFieldSTNSTN
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Problem_h
diff --git a/src/CCA/Components/PhaseField/DataTypes/PureMetalProblem.h b/src/CCA/Components/PhaseField/DataTypes/PureMetalProblem.h
new file mode 100644
index 00000000..544437b3
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/PureMetalProblem.h
@@ -0,0 +1,51 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataTypes/PureMetalProblem.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataTypes_PureMetalProblem_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataTypes_PureMetalProblem_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/Util/Expressions.h>
+#include <CCA/Components/PhaseField/DataTypes/Problem.h>
+#include <CCA/Components/PhaseField/DataTypes/ScalarField.h>
+#include <CCA/Components/PhaseField/DataTypes/VectorField.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/// Type of Problem used by PureMetal application
+template<VarType VAR, StnType STN> using PureMetalProblem = Problem<VAR, STN, ScalarField<const double>, ScalarField<const double>, ScalarField<const double>, VectorField < const double, combinations< get_stn<STN>::dim, 2>::value > >;
+
+} // namespace PhaseFieldSTNSTN
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataTypes_PureMetalProblem_h
diff --git a/src/CCA/Components/PhaseField/DataTypes/ScalarField.h b/src/CCA/Components/PhaseField/DataTypes/ScalarField.h
new file mode 100644
index 00000000..bc8e980b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/ScalarField.h
@@ -0,0 +1,61 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataTypes/ScalarField.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataTypes_ScalarField_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataTypes_ScalarField_h
+
+#include <Core/Grid/Variables/VarLabel.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Type for scalar spatial variables
+ * to be used as template parameter
+ *
+ * @tparam T type of the field values at each point
+ */
+template<typename T>
+struct ScalarField
+{
+    /// Type for variable label
+    using label_type = const VarLabel * ;
+
+    /// non const type of the field values at each point
+    using value_type = typename std::remove_const<T>::type;
+
+}; // struct ScalarField
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataTypes_ScalarField_h
diff --git a/src/CCA/Components/PhaseField/DataTypes/SubProblems.h b/src/CCA/Components/PhaseField/DataTypes/SubProblems.h
new file mode 100644
index 00000000..e1dc69c9
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/SubProblems.h
@@ -0,0 +1,95 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataTypes/SubProblems.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataTypes_SubProblems_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataTypes_SubProblems_h
+
+#include <CCA/Components/PhaseField/DataTypes/Problem.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+template < VarType VAR, StnType STN> class BCInterface;
+
+/**
+ * @brief PhaseField Problem Container
+ *
+ * Stores the list of all Problem's in which a Patch is partitioned
+ *
+ * @tparam Problem type of PhaseField problem
+ */
+template<typename Problem> struct SubProblems;
+
+/**
+ * @brief PhaseField Problem Container (Problem implementation)
+ *
+ * @tparam VAR type of variable representation
+ * @tparam STN finite-difference stencil
+ * @tparam Field list of type of fields (ScalarField < T> or VectorField < T, N >)
+ */
+template<VarType VAR, StnType STN, typename... Field>
+struct SubProblems < Problem<VAR, STN, Field...> >
+        : public RefCounted
+        , public std::list < Problem<VAR, STN, Field...> >
+{
+    /**
+     * @brief Constructor
+     *
+     * Instantiate the list the views required to handle all given variables
+     * over the given patch without retrieving data.
+     *
+     * @remark There is no need to recreate the
+     * views until the geometry is unchanged
+     *
+     * @param bci interface to problem for bc related funcitonalities
+     * @param labels list of the labels for the variables to handle
+     * @param subproblems_label label for subproblems in the DataWarehouse
+     * @param material index in the DataWarehouse
+     * @param patch grid level
+     * @param c2f mapping between variable names and C2F condition for amr grids
+     */
+    SubProblems (
+        const BCInterface<VAR, STN> * bci,
+        const typename Field::label_type & ...  labels,
+        const VarLabel * subproblems_label,
+        int material,
+        const Patch * patch,
+        const std::map<std::string, FC> * c2f = nullptr
+    ) : std::list<Problem<VAR, STN, Field...>> ( bci->template partition_patch <Field...> ( labels..., subproblems_label, material, patch, c2f ) )
+    {
+    };
+}; // struct SubProblems
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataTypes_SubProblems_h
diff --git a/src/CCA/Components/PhaseField/DataTypes/SubProblemsP.h b/src/CCA/Components/PhaseField/DataTypes/SubProblemsP.h
new file mode 100644
index 00000000..ad69fd4c
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/SubProblemsP.h
@@ -0,0 +1,72 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataTypes/SubProblemsP.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataTypes_SubProblemsP_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataTypes_SubProblemsP_h
+
+#include <Core/Util/Handle.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+template <typename Problem> struct SubProblems;
+
+/**
+ * @brief Handle for SubProblems
+ *
+ * @tparam Problem type of PhaseField problem
+ */
+template <typename Problem> using SubProblemsP = Handle < SubProblems<Problem> >;
+
+} // namespace PhaseField
+
+/**
+ * @brief Fix Endianess
+ *
+ * Ovverride for preventing compiler errors
+ * @remark Should never be called
+ *
+ * @tparam Problem type of PhaseField problem
+ * @param problem unused argument
+ */
+template <typename Problem>
+inline void
+swapbytes (
+    PhaseField::SubProblemsP<Problem> & _DOXYARG ( problem )
+)
+{
+    SCI_THROW ( InternalError ( "Swap bytes for ProblemsP is not implemented", __FILE__, __LINE__ ) );
+};
+
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataTypes_SubProblemsP_h
diff --git a/src/CCA/Components/PhaseField/DataTypes/Support.h b/src/CCA/Components/PhaseField/DataTypes/Support.h
new file mode 100644
index 00000000..6263725c
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/Support.h
@@ -0,0 +1,191 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Support_h
+#define Packages_Uintah_CCA_Components_PhaseField_Support_h
+
+#include <list>
+#include <Core/Grid/Region.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief View Domain
+ *
+ * It wraps a list of rectangular regions
+ */
+class Support
+    : public std::list<Region>
+{
+private: // MEMBERS
+
+public: // CONSTRUCTOR
+
+    using std::list<Region>::list;
+
+private: // METHODS
+
+    /**
+     * @brief function for sorting
+     *
+     * @param region1 first member of the comparison
+     * @param region2 second member of the comparison
+     * @return if region1 precedes region2 in lexicografic order
+     */
+    static bool
+    compare_regions (
+        Region & region1,
+        Region & region2
+    )
+    {
+        if ( region1.low().x() < region2.low().x() ) return true;
+        if ( region1.low().x() > region2.low().x() ) return false;
+        if ( region1.low().y() < region2.low().y() ) return true;
+        if ( region1.low().y() > region2.low().y() ) return false;
+        if ( region1.low().z() < region2.low().z() ) return true;
+        if ( region1.low().z() > region2.low().z() ) return false;
+        if ( region1.high().x() < region2.high().x() ) return true;
+        if ( region1.high().x() > region2.high().x() ) return false;
+        if ( region1.high().y() < region2.high().y() ) return true;
+        if ( region1.high().y() > region2.high().y() ) return false;
+        if ( region1.high().z() < region2.high().z() ) return true;
+        if ( region1.high().z() > region2.high().z() ) return false;
+        return false;
+    }
+
+public: // METHODS
+
+    /// Reduce the number of region in the list
+    void simplify()
+    {
+        size_t n;
+        do
+        {
+            n = size();
+
+            iterator it1 = begin();
+            while ( it1 != end() )
+                if ( it1->degenerate() )
+                    it1 = erase ( it1 );
+                else
+                    ++it1;
+
+            sort ( compare_regions ); // order by x, then by y, then by z
+
+            // join region with same low.x,y high.x,y
+
+            it1 = begin();
+            if ( it1 == end() ) return;
+
+            iterator it2 = std::next ( it1 );
+
+            while ( it2 != end () )
+            {
+                if ( it1->low().x() == it2->low().x() && it1->high().x() == it2->high().x() &&
+                        it1->low().y() == it2->low().y() && it1->high().y() == it2->high().y() )
+                {
+                    if ( it1->low().z() <= it2->low().z() && it2->low().z() <= it1->high().z() )
+                    {
+                        it1->high().z ( it2->high().z() );
+                        it2 = erase ( it2 );
+                    }
+                    else
+                    {
+                        it1 = it2;
+                        ++it2;
+                    }
+
+                }
+                else
+                {
+                    ++it1;
+                    ++it2;
+                }
+            }
+            //no more degenerate regions!
+
+            // join region with same low.x,z high.x,z
+            it1 = begin();
+            it2 = std::next ( it1 );
+            while ( it2 != end () )
+            {
+                if ( it1->low().x() == it2->low().x() && it1->high().x() == it2->high().x() &&
+                        it1->low().z() == it2->low().z() && it1->high().z() == it2->high().z() )
+                {
+                    if ( it1->low().y() <= it2->low().y() && it2->low().y() <= it1->high().y() )
+                    {
+                        it1->high().y ( it2->high().y() );
+                        it2 = erase ( it2 );
+                    }
+                    else
+                    {
+                        it1 = it2;
+                        ++it2;
+                    }
+                }
+                else
+                {
+                    ++it1;
+                    ++it2;
+                }
+            }
+
+            // join region with same low.y,z high.y,z
+            it1 = begin();
+            it2 = std::next ( it1 );
+            while ( it2 != end () )
+            {
+                if ( it1->low().y() == it2->low().y() && it1->high().y() == it2->high().y() &&
+                        it1->low().z() == it2->low().z() && it1->high().z() == it2->high().z() )
+                {
+                    if ( it1->low().x() <= it2->low().x() && it2->low().x() <= it1->high().x() )
+                    {
+                        it1->high().x ( it2->high().x() );
+                        it2 = erase ( it2 );
+                    }
+                    else
+                    {
+                        it1 = it2;
+                        ++it2;
+                    }
+                }
+                else
+                {
+                    ++it1;
+                    ++it2;
+                }
+            }
+        }
+        while ( size() && size() != n ); // repeat untile no simplification is made
+    };
+};
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Support_h
diff --git a/src/CCA/Components/PhaseField/DataTypes/Variable.h b/src/CCA/Components/PhaseField/DataTypes/Variable.h
new file mode 100644
index 00000000..7d003ce8
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/Variable.h
@@ -0,0 +1,81 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataTypes/Variable.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataTypes_Variable_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataTypes_Variable_h
+
+#include <Core/Grid/Variables/CCVariable.h>
+#include <Core/Grid/Variables/NCVariable.h>
+#include <Core/Grid/Variables/PerPatch.h>
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Grid variable wrapper
+ *
+ * Templetize the different grid variable implementations and allows to switch
+ * between different implementations at compile time
+ * @tparam VAR type of variable representation
+ */
+template<VarType VAR, typename T>
+struct Variable
+        : public std::conditional < std::is_const<T>::value,
+          typename std::conditional < VAR == CC, constCCVariable< typename std::remove_const<T>::type >,
+          typename std::conditional < VAR == NC, constNCVariable< typename std::remove_const<T>::type>,
+          void >::type >::type,
+          typename std::conditional < VAR == CC, CCVariable<T>,
+          typename std::conditional < VAR == NC, NCVariable<T>,
+          void >::type >::type
+          >::type
+{
+}; // struct Variable
+
+/**
+ * @brief Grid variable wrapper (PerPatch implementation)
+ *
+ * Templetize the different grid variable implementations and allows to switch
+ * between different implementations at compile time
+ * @implements Variable < VAR, T >
+ */
+template<typename T>
+struct Variable<PP, T>
+        : public PerPatch < Handle<T> >
+{
+};
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataTypes_Variable_h
diff --git a/src/CCA/Components/PhaseField/DataTypes/VectorField.h b/src/CCA/Components/PhaseField/DataTypes/VectorField.h
new file mode 100644
index 00000000..bacf2d15
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataTypes/VectorField.h
@@ -0,0 +1,62 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataTypes/VectorField.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataTypes_VectorField_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataTypes_VectorField_h
+
+#include <Core/Grid/Variables/VarLabel.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Type for vector spatial variables
+ * to be used as template
+ *
+ * @tparam T type of each component of the field at each point
+ * @tparam N number of components
+ */
+template<typename T, size_t N>
+struct VectorField
+{
+    /// Type for variable label
+    using label_type = std::array<const VarLabel *, N>;
+
+    /// non const type of the field values at each point
+    template<size_t> using elem_type = ScalarField<T>;
+}; // struct VectorField
+
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataTypes_VectorField_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/DWFDView-bld.sh b/src/CCA/Components/PhaseField/DataWarehouse/DWFDView-bld.sh
new file mode 100644
index 00000000..3e86506c
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/DWFDView-bld.sh
@@ -0,0 +1,101 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SRC=${0%.sh}.cc
+echo "generating $SRC"
+
+echo '/*' > $SRC
+echo ' * The MIT License' >> $SRC
+echo ' *' >> $SRC
+echo ' * Copyright (c) 1997-2018 The University of Utah' >> $SRC
+echo ' *' >> $SRC
+echo ' * Permission is hereby granted, free of charge, to any person obtaining a copy' >> $SRC
+echo ' * of this software and associated documentation files (the "Software"), to' >> $SRC
+echo ' * deal in the Software without restriction, including without limitation the' >> $SRC
+echo ' * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or' >> $SRC
+echo ' * sell copies of the Software, and to permit persons to whom the Software is' >> $SRC
+echo ' * furnished to do so, subject to the following conditions:' >> $SRC
+echo ' *' >> $SRC
+echo ' * The above copyright notice and this permission notice shall be included in' >> $SRC
+echo ' * all copies or substantial portions of the Software.' >> $SRC
+echo ' *' >> $SRC
+echo ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' >> $SRC
+echo ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' >> $SRC
+echo ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' >> $SRC
+echo ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' >> $SRC
+echo ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING' >> $SRC
+echo ' * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS' >> $SRC
+echo ' * IN THE SOFTWARE.' >> $SRC
+echo ' */' >> $SRC
+echo '' >> $SRC
+echo '#include <CCA/Components/PhaseField/DataWarehouse/DWFDView.h>' >> $SRC
+echo '#include <CCA/Components/PhaseField/DataWarehouse/DWFDViewFactory.h>' >> $SRC
+echo '' >> $SRC
+echo 'namespace Uintah {' >> $SRC
+echo 'namespace PhaseField {' >> $SRC
+echo '' >> $SRC
+
+Fs=(
+  "ScalarField<const double>"
+  "VectorField<const double, 1>"
+  "VectorField<const double, 3>"
+)
+STNs=(
+  "P3 P5 P7"
+  "P5"
+  "P7"
+)
+VARs=(CC NC)
+
+for ((f=0; f<${#Fs[@]}; f++)); do
+  F="${Fs[f]}";
+  for STN in ${STNs[f]}; do
+    echo "template<> DWFactoryFDView < $F, $STN >::FactoryMap DWFactoryFDView < $F, $STN >::RegisteredNames = {};" >> $SRC
+  done
+  echo "" >> $SRC
+done
+
+for ((f=0; f<${#Fs[@]}; f++)); do
+  F="${Fs[f]}";
+  for STN in ${STNs[f]}; do
+    for VAR in ${VARs[@]}; do
+      echo "template<> const std::string DWFDView < $F, $STN, $VAR >::Name = \"$VAR|$STN\";" >> $SRC
+    done
+  done
+  echo "" >> $SRC
+done
+
+for ((f=0; f<${#Fs[@]}; f++)); do
+  F="${Fs[f]}";
+  for STN in ${STNs[f]}; do
+    for VAR in ${VARs[@]}; do
+      echo "template class DWFDView < $F, $STN, $VAR >;" >> $SRC
+    done
+  done
+  echo "" >> $SRC
+done
+
+echo '} // namespace Uintah' >> $SRC
+echo '} // namespace PhaseField' >> $SRC
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/DWFDView.h b/src/CCA/Components/PhaseField/DataWarehouse/DWFDView.h
new file mode 100644
index 00000000..44969372
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/DWFDView.h
@@ -0,0 +1,118 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/DWFDView.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWFDView_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWFDView_h
+
+#include <CCA/Components/PhaseField/Factory/Implementation.h>
+#include <CCA/Components/PhaseField/Views/FDView.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dwfd_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Wrapper of DataWarehouse variables for both basic and complex
+ * differential operations
+ *
+ * Factory Implementation for dynamic instantiation
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ */
+template <typename Field, StnType STN, VarType VAR >
+class DWFDView
+    : virtual public FDView<Field, STN>
+    , public Implementation <
+    DWFDView<Field, STN, VAR>, FDView<Field, STN>,
+    const typename Field::label_type &,
+    int, const Level *
+    >
+    , public detail::dwfd_view<Field, STN, VAR>
+{
+public: // STATIC MEMBERS
+
+    /// Implementation identifier within Factory
+    static const std::string Name;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components without gathering info from the DataWarehouse
+     *
+     * @param label list of variable labels for each component
+     * @param material material index
+     * @param level grid level
+     */
+    DWFDView (
+        const typename Field::label_type & label,
+        int material,
+        const Level * level
+    ) : detail::dwfd_view<Field, STN, VAR> ( label, material, level )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label list of variable labels for each component
+     * @param material material index
+     * @param patch grid patch
+     */
+    DWFDView (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        int material,
+        const Patch * patch
+    ) : detail::dwfd_view<Field, STN, VAR> ( dw, label, material, patch )
+    {}
+
+    /// Default destructor
+    virtual ~DWFDView() = default;
+
+    /// Prevent copy (and move) constructor
+    DWFDView ( const DWFDView & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    DWFDView & operator= ( const DWFDView & ) = delete;
+
+}; // class DWFDView
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWFDView_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/DWFDViewFactory.h b/src/CCA/Components/PhaseField/DataWarehouse/DWFDViewFactory.h
new file mode 100644
index 00000000..b6caaa76
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/DWFDViewFactory.h
@@ -0,0 +1,54 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/DWFDViewFactory.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWFDViewFactory_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWFDViewFactory_h
+
+#include <CCA/Components/PhaseField/Factory/Factory.h>
+#include <CCA/Components/PhaseField/Views/FDView.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/// Factory creator for DWFDView
+template<typename Field, StnType STN> using DWFactoryFDView = Factory < FDView<Field, STN>, const typename Field::label_type &, int, const Level * >;
+
+/// Factory base for DWFDView
+template<typename Field, StnType STN> using DWBaseFDView = Base< FDView<Field, STN> >;
+
+/// Factory creator implementation for DWFDView Not implemented as there is no need yet
+template<typename Field, VarType VAR, StnType STN> struct DWFDViewFactory;
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWFDViewFactory_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/DWInterface.h b/src/CCA/Components/PhaseField/DataWarehouse/DWInterface.h
new file mode 100644
index 00000000..eed8e096
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/DWInterface.h
@@ -0,0 +1,118 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/DWInterface.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWInterface_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWInterface_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Interface for data-warehouse
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ */
+template < VarType VAR, DimType DIM >
+struct DWInterface
+{
+    template <VarType V = VAR>
+    static inline Point
+    get_position (
+        const Patch * p,
+        const IntVector & i
+    )
+    {
+        return detail::dw_interface0<V>::get_position ( p, i );
+    }
+
+    template <VarType V = VAR>
+    static inline Point
+    get_position (
+        const Level * l,
+        const IntVector & i
+    )
+    {
+        return detail::dw_interface0<V>::get_position ( l, i );
+    }
+
+    template <VarType V = VAR>
+    static inline IntVector
+    get_low (
+        const Patch * p
+    )
+    {
+        return detail::dw_interface0<V>::get_low ( p );
+    }
+
+    template <VarType V = VAR>
+    static inline IntVector
+    get_high (
+        const Patch * p
+    )
+    {
+        return detail::dw_interface0<V>::get_high ( p );
+    }
+
+    template <VarType V = VAR>
+    static inline BlockRange
+    get_range (
+        const Patch * p
+    )
+    {
+        return { detail::dw_interface0<V>::get_low ( p ), detail::dw_interface0<V>::get_high ( p ) };
+    }
+
+    template <VarType V = VAR>
+    static inline bool
+    find_point (
+        const Patch * p,
+        const Point & pt,
+        IntVector & id
+    )
+    {
+        return detail::dw_interface1<V, DIM>::find_point ( p, pt, id );
+    }
+}; // struct DWInterface
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWInterface_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/DWView-bld.sh b/src/CCA/Components/PhaseField/DataWarehouse/DWView-bld.sh
new file mode 100644
index 00000000..a485441d
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/DWView-bld.sh
@@ -0,0 +1,113 @@
+#!/bin/bash
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+
+SRC=${0%.sh}.cc
+echo "generating $SRC"
+
+echo '/*' > $SRC
+echo ' * The MIT License' >> $SRC
+echo ' *' >> $SRC
+echo ' * Copyright (c) 1997-2018 The University of Utah' >> $SRC
+echo ' *' >> $SRC
+echo ' * Permission is hereby granted, free of charge, to any person obtaining a copy' >> $SRC
+echo ' * of this software and associated documentation files (the "Software"), to' >> $SRC
+echo ' * deal in the Software without restriction, including without limitation the' >> $SRC
+echo ' * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or' >> $SRC
+echo ' * sell copies of the Software, and to permit persons to whom the Software is' >> $SRC
+echo ' * furnished to do so, subject to the following conditions:' >> $SRC
+echo ' *' >> $SRC
+echo ' * The above copyright notice and this permission notice shall be included in' >> $SRC
+echo ' * all copies or substantial portions of the Software.' >> $SRC
+echo ' *' >> $SRC
+echo ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' >> $SRC
+echo ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' >> $SRC
+echo ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' >> $SRC
+echo ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' >> $SRC
+echo ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING' >> $SRC
+echo ' * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS' >> $SRC
+echo ' * IN THE SOFTWARE.' >> $SRC
+echo ' */' >> $SRC
+echo '' >> $SRC
+echo '#include <CCA/Components/PhaseField/DataWarehouse/DWView.h>' >> $SRC
+echo '#include <CCA/Components/PhaseField/DataWarehouse/DWViewFactory.h>' >> $SRC
+echo '' >> $SRC
+echo 'namespace Uintah {' >> $SRC
+echo 'namespace PhaseField {' >> $SRC
+echo '' >> $SRC
+
+Fs=(
+  "ScalarField<int>"
+  "ScalarField<double>"
+  "ScalarField<const double>"
+  "ScalarField<Stencil7>"
+  "ScalarField<const Stencil7>"
+  "VectorField<double, 1u>"
+  "VectorField<double, 2u>"
+  "VectorField<const double, 2u>"
+  "VectorField<double, 3u>"
+  "VectorField<const double, 3u>"
+)
+VARs=(CC NC)
+DIMs=(
+  "D2 D3"
+  "D1 D2 D3"
+  "D1 D2 D3"
+  "D2 D3"
+  "D2 D3"
+  "D2"
+  "D2"
+  "D2"
+  "D3"
+  "D3"
+)
+
+for F in "${Fs[@]}"; do
+  echo "template<> DWFactoryView < $F >::FactoryMap DWFactoryView < $F >::RegisteredNames = {};" >> $SRC
+done
+
+echo '' >> $SRC
+
+for ((f=0; f<${#Fs[@]}; f++)); do
+  F="${Fs[f]}";
+  for VAR in ${VARs[@]}; do
+    for DIM in ${DIMs[f]}; do
+      echo "template<> const std::string DWView < $F, $VAR, $DIM >::Name = \"$VAR|$DIM|\";" >> $SRC
+    done
+  done
+  echo "" >> $SRC
+done
+
+for ((f=0; f<${#Fs[@]}; f++)); do
+  F="${Fs[f]}";
+  for VAR in ${VARs[@]}; do
+    for DIM in ${DIMs[f]}; do
+      echo "template class DWView < $F, $VAR, $DIM >;" >> $SRC
+    done
+  done
+  echo "" >> $SRC
+done
+
+echo '} // namespace Uintah' >> $SRC
+echo '} // namespace PhaseField' >> $SRC
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/DWView.h b/src/CCA/Components/PhaseField/DataWarehouse/DWView.h
new file mode 100644
index 00000000..941944a1
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/DWView.h
@@ -0,0 +1,116 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/DWView.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWView_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWView_h
+
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_view.h>
+#include <CCA/Components/PhaseField/Views/View.h>
+#include <CCA/Components/PhaseField/Factory/Implementation.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Wrapper of DataWarehouse variables
+ *
+ * Factory Implementation for dynamic instantiation
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ */
+template<typename Field, VarType VAR, DimType DIM >
+class DWView :
+    public Implementation < DWView<Field, VAR, DIM>, View<Field>, const typename Field::label_type &, int >,
+    virtual public View<Field>,
+    public detail::dw_view<Field, VAR, DIM, 0>
+{
+public: // STATIC MEMBERS
+
+    /// Implementation identifier within Factory
+    static const std::string Name;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components without gathering info from the DataWarehouse
+     *
+     * @param label list of variable labels for each component
+     * @param material material index
+     */
+    DWView (
+        const typename Field::label_type & label,
+        int material
+    ) : detail::dw_view<Field, VAR, DIM, 0> ( label, material )
+    {
+    }
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label list of variable labels for each component
+     * @param material material index
+     * @param patch grid patch
+     */
+    DWView (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        int material,
+        const Patch * patch
+    ) : detail::dw_view<Field, VAR, DIM, 0> ( dw, label, material, patch )
+    {
+    }
+
+    /// Default destructor
+    virtual ~DWView() = default;
+
+    /// Prevent copy (and move) constructor
+    DWView ( const DWView & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    DWView & operator= ( const DWView & ) = delete;
+
+}; // class DWView
+
+} // namespace PhaseField
+} // namespace Uintah
+
+// #include <CCA/Components/PhaseField/DataWarehouse/DWViewP5.h>
+// #include <CCA/Components/PhaseField/DataWarehouse/DWViewP7.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWView_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/DWViewFactory.h b/src/CCA/Components/PhaseField/DataWarehouse/DWViewFactory.h
new file mode 100644
index 00000000..1688e42a
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/DWViewFactory.h
@@ -0,0 +1,55 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/DWViewFactory.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWViewFactory_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWViewFactory_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/Factory/Factory.h>
+#include <CCA/Components/PhaseField/Views/View.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/// Factory creator for DWView
+template<typename Field> using DWFactoryView = Factory < View<Field>, const typename Field::label_type &, int>;
+
+/// Factory base for DWView
+template<typename Field> using DWBaseView = Base< View<Field> >;
+
+/// Factory creator implementation for DWView Not implemented as there is no need yet
+template < typename Field, VarType VAR, DimType DIM > struct DWViewFactory;
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWViewFactory_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_basic_fd_view.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_basic_fd_view.h
new file mode 100644
index 00000000..c2731d23
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_basic_fd_view.h
@@ -0,0 +1,324 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_basic_fd_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_dw_basic_fd_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_dw_basic_fd_view_h
+
+#include <CCA/Components/PhaseField/Views/detail/basic_fd_view.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of DataWarehouse variables for basic differential operations
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of basic differential operations (first and second order derivatives) at
+ * internal cells/points
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ */
+template<typename Field, StnType STN, VarType VAR> class dw_basic_fd_view;
+
+/**
+ * @brief Wrapper of DataWarehouse variables for basic differential operations
+ * (ScalarField implementation)
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of basic differential operations (first and second order derivatives) at
+ * internal cells/points
+ *
+ * @remark actual finite-differences implementations are in dw_fd
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ */
+template<typename T, StnType STN, VarType VAR>
+class dw_basic_fd_view < ScalarField<T>, STN, VAR >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+    , public dw_fd < ScalarField<T>, STN, VAR, get_stn<STN>::ghosts >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = true;
+
+private: // STATIC MEMBERS
+
+    /// Number of ghosts required by STN
+    static constexpr int GN = get_stn<STN>::ghosts;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+protected: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    dw_basic_fd_view (
+        const dw_basic_fd_view * copy,
+        bool deep
+    ) : dw_fd<Field, STN, VAR, GN> ( copy, deep )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param label variable label
+     * @param material material index
+     * @param level grid level
+     */
+    dw_basic_fd_view (
+        const typename Field::label_type & label,
+        int material,
+        const Level * level
+    ) : dw_fd<Field, STN, VAR, GN> ( label, material, level )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label variable label
+     * @param material material index
+     * @param patch grid patch
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    dw_basic_fd_view (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : dw_fd<Field, STN, VAR, GN> ( dw, label, material, patch, use_ghosts )
+    {}
+
+    /// Default destructor
+    virtual ~dw_basic_fd_view() = default;
+
+    /// Prevent copy (and move) constructor
+    dw_basic_fd_view ( const dw_basic_fd_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_basic_fd_view & operator= ( const dw_basic_fd_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    ) const override
+    {
+        return scinew dw_basic_fd_view ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    ) const override
+    {
+        return scinew virtual_view<dw_basic_fd_view, Field> ( this, deep, offset );
+    };
+
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view
+     *
+     * @return non const pointer to base view implementation
+     */
+    virtual inline view<Field> *
+    get_view()
+    override
+    {
+        return dw_fd<Field, STN, VAR, GN>::get_view();
+    };
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual const view<Field> *
+    get_view()
+    const override
+    {
+        return dw_fd<Field, STN, VAR, GN>::get_view();
+    };
+
+    /**
+     * @brief Partial x derivative
+     *
+     * First order derivative along x at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dx (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d<X> ( id );
+    }
+
+    /**
+     * @brief Partial y derivative
+     *
+     * First order derivative along y at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dy (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d<Y> ( id );
+    }
+
+    /**
+     * @brief Partial z derivative
+     *
+     * First order derivative along z at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dz (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d<Z> ( id );
+    };
+
+    /**
+     * @brief Partial x second order derivative
+     *
+     * Second order derivative along x at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dxx (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d2<X> ( id );
+    }
+
+    /**
+     * @brief Partial y second order derivative
+     *
+     * Second order derivative along y at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dyy (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d2<Y> ( id );
+    }
+
+    /**
+     * @brief Partial z second order derivative
+     *
+     * Second order derivative along z at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual inline V
+    dzz (
+        const IntVector & id
+    ) const override
+    {
+        return this->template d2<Z> ( id );
+    }
+
+}; // class dw_basic_fd_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_dw_basic_fd_view_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h
new file mode 100644
index 00000000..9bd1edb3
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h
@@ -0,0 +1,94 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_fd.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Abstract finite-differences scheme for dw variables
+ *
+ * To implement a new finite-differences scheme it should be sufficient to
+ * define a new STN and code the relevant implementations of this class
+ * (for amr simulations also the corresponding bc_fd implementation for
+ * fine/coarse interfaces must be provided)
+ *
+ * @implements basic_fd_view < Field, STN >
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ * @tparam GN Number of ghosts required
+ */
+template<typename Field, StnType STN, VarType VAR, int GN>
+class dw_fd
+    _DOXYBDY (
+        /// Non const type of the field value
+        using V;
+
+    /**
+     * @brief First order derivative
+     *
+     * First order derivative along DIR at index id
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+        template <DirType DIR> inline V d ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Second order derivative
+     *
+     * Second order derivative along DIR at index id
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+        template <DirType DIR> inline V d2 ( const IntVector & id ) const = 0;
+                 );
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+// include implementation headers
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_G1.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_G1.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_G1.h
new file mode 100644
index 00000000..284643c0
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_G1.h
@@ -0,0 +1,341 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_G1.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_G1_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_G1_h
+
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Finite-differences scheme for dw variables (1-ghost in each direction)
+ * (ScalarField implementation)
+ *
+ * Implement P3 (three-point 1D), P5 (five-point 2D) and P7 (seven-point 3D)
+ * stencils
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ */
+template<typename T, StnType STN, VarType VAR>
+class dw_fd < ScalarField<T>, STN, VAR, 1 >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+public: // STATIC MEMBERS
+
+    static constexpr bool use_ghosts_dflt = true;
+
+private: // STATIC MEMBERS
+
+    /// Problem dimension
+    static constexpr DimType DIM = get_stn<STN>::dim;
+
+    /// Number of ghosts required
+    static constexpr int GN = 1;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private:  // MEMBERS
+
+    /// Wrapper of variable in the DataWarehouse
+    dw_view<Field, VAR, DIM, GN> * m_view;
+
+    /// Grid level
+    const Level * m_level;
+
+    /// Grid spacing
+    Vector m_h;
+
+private: // METHODS
+
+    /**
+     * @brief Get const reference to value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    inline const V &
+    value (
+        const IntVector & id
+    ) const
+    {
+        return ( *m_view ) [id];
+    }
+
+protected: // COPY CONSTRUCTOR
+
+    dw_fd (
+        const dw_fd * copy,
+        bool deep
+    ) : m_view ( dynamic_cast < dw_view<Field, VAR, DIM, GN> * > ( copy->m_view->clone ( deep ) ) ),
+        m_level ( copy->m_level ),
+        m_h ( copy->m_h )
+    {}
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param label variable label
+     * @param material material index
+     * @param level grid level
+     */
+    dw_fd (
+        const VarLabel * label,
+        int material,
+        const Level * level
+    ) : m_view ( scinew dw_view<Field, VAR, DIM, GN> ( label, material ) ),
+        m_level ( level ),
+        m_h ( level->dCell() )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label variable label
+     * @param material material index
+     * @param patch grid patch
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    dw_fd (
+        DataWarehouse * dw,
+        const VarLabel * label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : m_view ( scinew dw_view<Field, VAR, DIM, GN> ( dw, label, material, patch, use_ghosts ) ),
+        m_level ( patch->getLevel() ),
+        m_h ( m_level->dCell() )
+    {}
+
+    /// Destructor
+    virtual ~dw_fd()
+    {
+        delete m_view;
+    };
+
+    /// Prevent copy (and move) constructor
+    dw_fd ( const dw_fd & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_fd & operator= ( const dw_fd & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual inline void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts
+    ) override
+    {
+        m_level = patch->getLevel();
+        m_h = m_level->dCell();
+        m_view->set ( dw, patch, use_ghosts );
+    }
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual inline void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        m_view->set ( dw, level, low, high, use_ghosts );
+    };
+
+    /**
+     * @brief Get the region for which the view has access to the DataWarehouse
+     *
+     * @return support of the view
+     */
+    virtual inline Support
+    get_support()
+    const override
+    {
+        return m_view->get_support();
+    };
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual inline bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        return m_view->is_defined_at ( id );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual inline T &
+    operator[] (
+        const IntVector & id
+    ) override
+    {
+        return ( *m_view ) [id];
+    };
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual inline V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        return value ( id );
+    };
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view
+     *
+     * @return non const pointer to base view implementation
+     */
+    virtual inline view<Field> *
+    get_view()
+    override
+    {
+        return m_view;
+    };
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual inline const view<Field> *
+    get_view()
+    const override
+    {
+        return m_view;
+    };
+
+public: // DW FD MEMBERS
+
+    /**
+     * @brief First order derivative
+     *
+     * First order derivative along DIR at index id
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template <DirType DIR>
+    inline T
+    d (
+        const IntVector & id
+    ) const
+    {
+        IntVector im ( id ), ip ( id );
+        im[DIR] -= 1;
+        ip[DIR] += 1;
+        return ( value ( ip ) - value ( im ) ) / ( 2. * m_h[DIR] );
+    }
+
+    /**
+     * @brief Second order derivative
+     *
+     * Second order derivative along DIR at index id
+     *
+     * @tparam DIR Direction along with derivative is approximated
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    template <DirType DIR>
+    inline T
+    d2 (
+        const IntVector & id
+    ) const
+    {
+        IntVector im ( id ), ip ( id );
+        im[DIR] -= 1;
+        ip[DIR] += 1;
+        return ( value ( ip ) + value ( im ) - 2. * value ( id ) ) / ( m_h[DIR] * m_h[DIR] );
+    }
+
+}; // class dw_fd_G1
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_G1_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_view.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_view.h
new file mode 100644
index 00000000..52897bec
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_view.h
@@ -0,0 +1,144 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_view_h
+
+#include <CCA/Components/PhaseField/Views/detail/fd_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of DataWarehouse variables for complex differential operations
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of complex differential operations (gradient and laplacian) at internal
+ * cells/points
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ */
+template<typename Field, StnType STN, VarType VAR> class dw_fd_view;
+
+/**
+ * @brief Wrapper of DataWarehouse variables for complex differential operations
+ * (ScalarField implementation)
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of complex differential operations (gradient and laplacian) at internal
+ * cells/points
+ *
+ * @remark actual finite-differences implementations are in dw_fd
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ */
+template<typename T, StnType STN, VarType VAR>
+class dw_fd_view < ScalarField<T>, STN, VAR >
+    : virtual public fd_view < ScalarField<T>, STN >
+{
+private: // STATIC MEMBERS
+
+    /// Problem Dimension
+    static constexpr DimType DIM = get_stn<STN>::dim;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// Default constructor
+    dw_fd_view () = default;
+
+    /// Default destructor
+    virtual ~dw_fd_view() = default;
+
+    /// Prevent copy (and move) constructor
+    dw_fd_view ( const dw_fd_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_fd_view & operator= ( const dw_fd_view & ) = delete;
+
+public: // FD VIEW METHODS
+
+    /**
+     * @brief Get gradient value at position
+     *
+     * @param id position index
+     * @return gradient value at id
+     */
+    virtual inline std::vector<V>
+    gradient (
+        const IntVector & id
+    ) const override
+    {
+        std::vector<V> res ( DIM );
+        res[X] = this->template dx ( id );
+        if ( DIM > D1 ) res[Y] = this->dy ( id );
+        if ( DIM > D2 ) res[Z] = this->dz ( id );
+        return res;
+    }
+
+    /**
+     * @brief Get laplacian at position
+     *
+     * @param id position index
+     * @return laplacian value at id
+     */
+    virtual inline typename std::remove_const<T>::type
+    laplacian (
+        const IntVector & id
+    ) const override
+    {
+        typename std::remove_const<T>::type res = this->dxx ( id );
+        if ( DIM > D1 ) res += this->dyy ( id );
+        if ( DIM > D2 ) res += this->dzz ( id );
+        return res;
+    }
+
+}; // class dw_fd_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_fd_view_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0.h
new file mode 100644
index 00000000..9f93c772
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0.h
@@ -0,0 +1,55 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (variable dependent implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @tparam VAR type of variable representation
+ */
+template < VarType VAR > class dw_interface0;
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_CC.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_NC.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_CC.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_CC.h
new file mode 100644
index 00000000..b414cd70
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_CC.h
@@ -0,0 +1,137 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_CC.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_CC_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_CC_h
+
+#include <Core/Grid/Variables/BlockRange.hpp>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (cc implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @implements dw_interface0 < VAR >
+ */
+template<>
+class dw_interface0<CC>
+{
+protected: // CONSTRUCTOR/DESTRUCTOR
+
+    /// prevent coonstruction
+    dw_interface0() = delete;
+
+    /// Prevent copy (and move) constructor
+    dw_interface0 ( const dw_interface0 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_interface0 & operator= ( const dw_interface0 & ) = delete;
+
+public:
+
+    /// type of ghost for variable in the datawarehouse
+    static constexpr Ghost::GhostType ghost_type = Ghost::AroundCells;
+
+    /**
+     * @brief get position within patch
+     *
+     * @param p grid patch
+     * @param i grid index
+     * @return coordinates of the grid element
+     */
+    static inline Point
+    get_position (
+        const Patch * p,
+        const IntVector & i
+    )
+    {
+        return p->getCellPosition ( i );
+    }
+
+    /**
+     * @brief get position within level
+     *
+     * @param l grid level
+     * @param i grid index
+     * @return coordinates of the grid element
+     */
+    static inline Point
+    get_position (
+        const Level * l,
+        const IntVector & i
+    )
+    {
+        return l->getCellPosition ( i );
+    }
+
+    /**
+     * @brief get patch first index
+     *
+     * @param p grid patch
+     * @return lower bound
+     */
+    static inline IntVector
+    get_low (
+        const Patch * p
+    )
+    {
+        return p->getCellLowIndex();
+    }
+
+    /**
+     * @brief get patch past the end index
+     *
+     * @param p grid patch
+     * @return upper bound
+     */
+    static inline IntVector
+    get_high (
+        const Patch * p
+    )
+    {
+        return p->getCellHighIndex();
+    }
+
+}; // class dw_interface0
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_CC_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_NC.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_NC.h
new file mode 100644
index 00000000..455183e8
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_NC.h
@@ -0,0 +1,135 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_interface0_NC.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_NC_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_NC_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (nc implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @implements dw_interface0 < VAR >
+ */
+template<>
+class dw_interface0<NC>
+{
+protected: // CONSTRUCTOR/DESTRUCTOR
+
+    /// prevent coonstruction
+    dw_interface0() = delete;
+
+    /// Prevent copy (and move) constructor
+    dw_interface0 ( const dw_interface0 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_interface0 & operator= ( const dw_interface0 & ) = delete;
+
+public:
+
+    /// type of ghost for variable in the datawarehouse
+    static constexpr Ghost::GhostType ghost_type = Ghost::AroundNodes;
+
+    /**
+     * @brief get position within patch
+     *
+     * @param p grid patch
+     * @param i grid index
+     * @return coordinates of the grid element
+     */
+    static inline Point
+    get_position (
+        const Patch * p,
+        const IntVector & i
+    )
+    {
+        return p->getNodePosition ( i );
+    }
+
+    /**
+     * @brief get position within level
+     *
+     * @param l grid level
+     * @param i grid index
+     * @return coordinates of the grid element
+     */
+    static inline Point
+    get_position (
+        const Level * l,
+        const IntVector & i
+    )
+    {
+        return l->getNodePosition ( i );
+    }
+
+    /**
+     * @brief get patch first index
+     *
+     * @param p grid patch
+     * @return lower bound
+     */
+    static inline IntVector
+    get_low (
+        const Patch * p
+    )
+    {
+        return p->getNodeLowIndex();
+    }
+
+    /**
+     * @brief get patch past the end index
+     *
+     * @param p grid patch
+     * @return upper bound
+     */
+    static inline IntVector
+    get_high (
+        const Patch * p
+    )
+    {
+        return p->getNodeHighIndex();
+    }
+
+}; // class dw_interface0
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface0_NC_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1.h
new file mode 100644
index 00000000..99277e1a
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1.h
@@ -0,0 +1,59 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (variable and dimension dependent implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ */
+template < VarType VAR, DimType DIM >
+class dw_interface1;
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D1.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D2.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D3.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D1.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D2.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D3.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D1.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D1.h
new file mode 100644
index 00000000..7209df06
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D1.h
@@ -0,0 +1,89 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D1.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D1_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D1_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (1D CC implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @implements dw_interface1 < VAR, DIM >
+ */
+template<>
+class dw_interface1<CC, D1>
+{
+protected: // CONSTRUCTOR/DESTRUCTOR
+
+    /// prevent coonstruction
+    dw_interface1() = delete;
+
+    /// Prevent copy (and move) constructor
+    dw_interface1 ( const dw_interface1 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_interface1 & operator= ( const dw_interface1 & ) = delete;
+
+public:
+
+    /**
+     * @brief get index from position
+     *
+     * @param p grid patch
+     * @param pt point coordinates
+     * @param[out] id grid index
+     * @return if point has been found within patch
+     */
+    static inline bool find_point ( const Patch * p, const Point & pt, IntVector & id )
+    {
+        bool res = p->findCell ( pt, id );
+        ASSERTMSG ( std::fabs ( p->getCellPosition ( id ).x() - pt.x() ) < 1e-10 ,
+                    [ = ]()->std::string { std::stringstream ss; ss << p->getCellPosition ( id ) << pt << std::endl << p->getCellPosition ( id + IntVector ( 1, 1, 1 ) ) << pt << std::endl; return ss.str(); } ().c_str()
+                  );
+        return res;
+    }
+
+}; // class dw_interface1
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D1_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D2.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D2.h
new file mode 100644
index 00000000..a895ed51
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D2.h
@@ -0,0 +1,90 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.sc
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D2.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D2_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D2_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (2D CC implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @implements dw_interface1 < VAR, DIM >
+ */
+template<>
+class dw_interface1<CC, D2>
+{
+protected: // CONSTRUCTOR/DESTRUCTOR
+
+    /// prevent coonstruction
+    dw_interface1() = delete;
+
+    /// Prevent copy (and move) constructor
+    dw_interface1 ( const dw_interface1 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_interface1 & operator= ( const dw_interface1 & ) = delete;
+
+public:
+
+    /**
+     * @brief get index from position
+     *
+     * @param p grid patch
+     * @param pt point coordinates
+     * @param[out] id grid index
+     * @return if point has been found within patch
+     */
+    static inline bool find_point ( const Patch * p, const Point & pt, IntVector & id )
+    {
+        bool res = p->findCell ( pt, id );
+
+        ASSERTMSG ( std::fabs ( p->getCellPosition ( id ).x() - pt.x() ) < 1e-10 &&
+                    std::fabs ( p->getCellPosition ( id ).y() - pt.y() ) < 1e-10 ,
+                    [ = ]()->std::string { std::stringstream ss; ss << p->getCellPosition ( id ) << pt << std::endl << p->getCellPosition ( id + IntVector ( 1, 1, 1 ) ) << pt << std::endl; return ss.str(); } ().c_str()
+                  )
+        return res;
+    }
+}; // class dw_interface1
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D2_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D3.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D3.h
new file mode 100644
index 00000000..221a9f53
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D3.h
@@ -0,0 +1,91 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_CC_D3.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D3_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D3_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (3D CC implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @implements dw_interface1 < VAR, DIM >
+ */
+template<>
+class dw_interface1<CC, D3>
+{
+protected: // CONSTRUCTOR/DESTRUCTOR
+
+    /// prevent coonstruction
+    dw_interface1() = delete;
+
+    /// Prevent copy (and move) constructor
+    dw_interface1 ( const dw_interface1 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_interface1 & operator= ( const dw_interface1 & ) = delete;
+
+public:
+
+    /**
+     * @brief get index from position
+     *
+     * @param p grid patch
+     * @param pt point coordinates
+     * @param[out] id grid index
+     * @return if point has been found within patch
+     */
+    static inline bool find_point ( const Patch * p, const Point & pt, IntVector & id )
+    {
+        bool res = p->findCell ( pt, id );
+
+        ASSERTMSG ( std::fabs ( p->getCellPosition ( id ).x() - pt.x() ) < 1e-10 &&
+                    std::fabs ( p->getCellPosition ( id ).y() - pt.y() ) < 1e-10 &&
+                    std::fabs ( p->getCellPosition ( id ).z() - pt.z() ) < 1e-10,
+                    [ = ]()->std::string { std::stringstream ss; ss << p->getCellPosition ( id ) << pt << std::endl << p->getCellPosition ( id + IntVector ( 1, 1, 1 ) ) << pt << std::endl; return ss.str(); } ().c_str()
+                  )
+        return res;
+    }
+}; // class dw_interface1
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_CC_D3_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D1.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D1.h
new file mode 100644
index 00000000..b49138e1
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D1.h
@@ -0,0 +1,90 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D1.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_NC_D1_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_NC_D1_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (1D NC implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @implements dw_interface1 < VAR, DIM >
+ */
+template<>
+class dw_interface1<NC, D1>
+{
+protected: // CONSTRUCTOR/DESTRUCTOR
+
+    /// prevent coonstruction
+    dw_interface1() = delete;
+
+    /// Prevent copy (and move) constructor
+    dw_interface1 ( const dw_interface1 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_interface1 & operator= ( const dw_interface1 & ) = delete;
+
+public:
+
+    /**
+     * @brief get index from position
+     *
+     * @param p grid patch
+     * @param pt point coordinates
+     * @param[out] id grid index
+     * @return if point has been found within patch
+     */
+    static inline bool find_point ( const Patch * p, const Point & pt, IntVector & id )
+    {
+        bool res = p->findCell ( pt, id );
+        Vector pos = 2. * ( p->getNodePosition ( id ) - pt );
+        if ( pos[0] < -p->getLevel()->dCell() [0] )
+            id[0] += 1;
+        ASSERT ( Vector ( p->getNodePosition ( id ) - pt ).length() < 1e-10 );
+        return res;
+    }
+
+}; // class dw_interface1
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_NC_D1_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D2.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D2.h
new file mode 100644
index 00000000..632a047d
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D2.h
@@ -0,0 +1,92 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D2.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_NC_D2_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_NC_D2_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (2D NC implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @implements dw_interface1 < VAR, DIM >
+ */
+template<>
+class dw_interface1<NC, D2>
+{
+protected: // CONSTRUCTOR/DESTRUCTOR
+
+    /// prevent coonstruction
+    dw_interface1() = delete;
+
+    /// Prevent copy (and move) constructor
+    dw_interface1 ( const dw_interface1 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_interface1 & operator= ( const dw_interface1 & ) = delete;
+
+public:
+
+    /**
+     * @brief get index from position
+     *
+     * @param p grid patch
+     * @param pt point coordinates
+     * @param[out] id grid index
+     * @return if point has been found within patch
+     */
+    static inline bool find_point ( const Patch * p, const Point & pt, IntVector & id )
+    {
+        bool res = p->findCell ( pt, id );
+        Vector pos = 2. * ( p->getNodePosition ( id ) - pt );
+        if ( pos[0] < -p->getLevel()->dCell() [0] )
+            id[0] += 1;
+        if ( pos[1] < -p->getLevel()->dCell() [1] )
+            id[1] += 1;
+        ASSERT ( Vector ( p->getNodePosition ( id ) - pt ).length() < 1e-10 );
+        return res;
+    }
+
+}; // class dw_interface1
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_NC_D2_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D3.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D3.h
new file mode 100644
index 00000000..87c05010
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D3.h
@@ -0,0 +1,91 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_interface1_NC_D3.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_NC_D3_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_NC_D3_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Interface for data-warehouse (3D NC implementations)
+ *
+ * groups together various methods to get info about patches and levels which
+ * depend on the different types of variable representation and problem
+ * dimensions allowing to choose the relevant implementation at compile time
+ *
+ * @implements dw_interface1 < VAR, DIM >
+ */
+template<>
+class dw_interface1<NC, D3>
+{
+protected: // CONSTRUCTOR/DESTRUCTOR
+
+    /// prevent coonstruction
+    dw_interface1() = delete;
+
+    /// Prevent copy (and move) constructor
+    dw_interface1 ( const dw_interface1 & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_interface1 & operator= ( const dw_interface1 & ) = delete;
+
+public:
+
+    /**
+     * @brief get index from position
+     *
+     * @param p grid patch
+     * @param pt point coordinates
+     * @param[out] id grid index
+     * @return if point has been found within patch
+     */
+    static inline bool find_point ( const Patch * p, const Point & pt, IntVector & id )
+    {
+        bool res = p->findCell ( pt, id );
+        Vector pos = 2. * ( p->getNodePosition ( id ) - pt );
+        if ( pos[0] < -p->getLevel()->dCell() [0] ) id[0] += 1;
+        if ( pos[1] < -p->getLevel()->dCell() [1] ) id[1] += 1;
+        if ( pos[2] < -p->getLevel()->dCell() [2] ) id[2] += 1;
+        ASSERT ( Vector ( p->getNodePosition ( id ) - pt ).length() < 1e-10 );
+        return res;
+    }
+
+}; // class dw_interface1
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_interface1_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_view.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_view.h
new file mode 100644
index 00000000..23a44a90
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dw_view.h
@@ -0,0 +1,655 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dw_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_view_h
+
+#include <CCA/Components/PhaseField/Views/detail/view.h>
+#include <CCA/Components/PhaseField/Views/detail/virtual_view.h>
+
+#include <CCA/Components/PhaseField/DataTypes/SubProblemsP.h>
+#include <CCA/Components/PhaseField/DataTypes/Variable.h>
+
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Class for accessing variables from the DataWarehouse
+ *
+ * detail implementation of DataWarehouse variable wrapping
+ *
+ * @remark constant view must use fields with const value type
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ * @tparam GN number of ghosts required
+ */
+template<typename Field, VarType VAR, DimType DIM, size_t GN> class dw_view;
+
+/**
+ * @brief Class for accessing variables from the DataWarehouse
+ * (ScalarField implementation)
+ *
+ * detail implementation of DataWarehouse variable wrapping
+ *
+ * @remark constant view must use fields with const value type
+ *
+ * @tparam T type of the field value at each point
+ * @tparam VAR type of variable representation
+ * @tparam DIM problem dimension
+ * @tparam GN number of ghosts required
+ */
+template<typename T, VarType VAR, DimType DIM, size_t GN>
+class dw_view < ScalarField<T>, VAR, DIM, GN >
+    : virtual public view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghosts when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+private: // STATIC MEMBERS
+
+    /// Type of ghosts
+    static constexpr Ghost::GhostType GT = GN ? get_var<VAR>::ghost_type : Ghost::None;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // FRIENDS
+
+    friend virtual_view<dw_view, Field>;
+
+private: // MEMBERS
+
+    /// Variable label in the DataWarehouse
+    typename Field::label_type m_label;
+
+    /// Material index in the DataWarehouse
+    const int m_material;
+
+    /// Grid Level
+    const Level * m_level;
+
+    /// Underlying Grid Variable
+    Variable<VAR, T> * m_variable;
+
+    /// View to the variable
+    /// (points the variable itself or to the kokkos view of it for gpu builds)
+#ifndef UINTAH_ENABLE_KOKKOS
+    Variable<VAR, T> * m_view;
+#else
+    KokkosView3<T> * m_view;
+#endif
+
+private: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    dw_view (
+        const dw_view * copy,
+        bool deep
+    ) : m_label ( copy->m_label ),
+        m_material ( copy->m_material ),
+        m_level ( copy->m_level ),
+        m_variable ( ( copy->m_variable && deep ) ? scinew Variable<VAR, T> ( *copy->m_variable ) : nullptr ),
+#ifndef UINTAH_ENABLE_KOKKOS
+        m_view ( m_variable )
+#else
+        m_view ( m_variable ? m_variable->getKokkosView() : nullptr )
+#endif
+    {
+    }
+
+private: // METHODS
+
+    /**
+     * @brief Create grid variable over a patch
+     *
+     * Instantiate the underlying grid variable a retrieve patch data
+     * (const implementation)
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    template<bool is_const>
+    typename std::enable_if<is_const, Variable<VAR, T> *>::type
+    create_patch_variable (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts
+    )
+    {
+        Variable<VAR, T> * var = scinew Variable<VAR, T>;
+        if ( use_ghosts )
+            dw->get ( *var, m_label, m_material, patch, GT, GN );
+        else
+            dw->get ( *var, m_label, m_material, patch, Ghost::None, 0 );
+        return var;
+    }
+
+    /**
+     * @brief Create grid variable over a patch
+     *
+     * Instantiate the underlying grid variable a retrieve patch data
+     * (non const implementation)
+     *
+     * @remark if variable does not exists in dw it is allocated therein
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     * @return new instance of Variable
+     */
+    template<bool is_const>
+    typename std::enable_if < !is_const, Variable<VAR, T> * >::type
+    create_patch_variable (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts
+    )
+    {
+        Variable<VAR, T> * var = scinew Variable<VAR, T>;
+        if ( use_ghosts )
+        {
+            if ( dw->exists ( m_label, m_material, patch ) )
+                dw->getModifiable ( *var, m_label, m_material, patch, GT, GN );
+            else
+                dw->allocateAndPut ( *var, m_label, m_material, patch, GT, GN );
+        }
+        else
+        {
+            if ( dw->exists ( m_label, m_material, patch ) )
+                dw->getModifiable ( *var, m_label, m_material, patch, Ghost::None, 0 );
+            else
+                dw->allocateAndPut ( *var, m_label, m_material, patch, Ghost::None, 0 );
+        }
+        return var;
+    }
+
+    /**
+     * @brief Create grid variable over a region
+     *
+     * Instantiate the underlying grid variable a retrieve region data
+     * (const implementation)
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     * @return new instance of Variable
+     */
+    template<bool is_const>
+    typename std::enable_if<is_const, Variable<VAR, T> *>::type
+    create_region_variable (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    )
+    {
+        Variable<VAR, T> * var = scinew Variable<VAR, T>;
+        if ( use_ghosts )
+            dw->getRegion ( *var, m_label, m_material, level, low - get_dim<DIM>::template scalar_vector<GN>(), high + get_dim<DIM>::template scalar_vector<GN>() );
+        else
+            dw->getRegion ( *var, m_label, m_material, level, low, high );
+        return var;
+    }
+
+    /**
+     * @brief Create grid variable over a region
+     *
+     * Instantiate the underlying grid variable a retrieve region data
+     * (non const implementation)
+     *
+     * @remark does nothing since views of grid variables over region must not
+     * allow data modifications
+     *
+     * @param dw unused
+     * @param level unused
+     * @param low unused
+     * @param high unused
+     * @param use_ghosts unused
+     * @return null pointer
+     */
+    template<bool is_const>
+    typename std::enable_if < !is_const, Variable<VAR, T> * >::type
+    create_region_variable (
+        DataWarehouse * _DOXYARG ( dw ),
+        const Level * /*level*/,
+        const IntVector & /*low*/,
+        const IntVector & /*high*/,
+        bool _DOXYARG ( use_ghosts )
+    )
+    {
+        ASSERTFAIL ( "cannot create non const view over region" );
+        return nullptr;
+    }
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view without gathering info from the DataWarehouse
+     *
+     * @param label variable label
+     * @param material material index
+     */
+    dw_view (
+        const typename Field::label_type & label,
+        int material
+    ) : m_label ( label ),
+        m_material ( material ),
+        m_level ( nullptr ),
+        m_variable ( nullptr ),
+        m_view ( nullptr )
+    {}
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a view and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label variable label
+     * @param material material index
+     * @param patch grid patch
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    dw_view (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = use_ghosts_dflt
+    ) : m_label ( label ),
+        m_material ( material ),
+        m_level ( patch->getLevel() ),
+        m_variable ( create_patch_variable<std::is_const<T>::value> ( dw, patch, use_ghosts ) ),
+#ifndef UINTAH_ENABLE_KOKKOS
+        m_view ( m_variable )
+#else
+        m_view ( m_variable->getKokkosView() )
+#endif
+    {}
+
+    /// Destructor
+    ~dw_view()
+    {
+        delete m_variable;
+    }
+
+    /// Prevent copy (and move) constructor
+    dw_view ( const dw_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_view & operator= ( const dw_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve values from the DataWarehouse for a given patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts
+    ) override
+    {
+        delete m_variable;
+        m_level = patch->getLevel();
+        m_variable = create_patch_variable<std::is_const<T>::value> ( dw, patch, use_ghosts );
+#ifndef UINTAH_ENABLE_KOKKOS
+        m_view = m_variable;
+#else
+        m_view = m_variable->getKokkosView();
+#endif
+    };
+
+    /**
+     * @brief Retrieve values from the DataWarehouse for a given region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        delete m_variable;
+        m_level = level;
+        m_variable = create_region_variable<std::is_const<T>::value> ( dw, level, low, high, use_ghosts );
+#ifndef UINTAH_ENABLE_KOKKOS
+        m_view = m_variable;
+#else
+        m_view = m_variable->getKokkosView();
+#endif
+    };
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual inline view<Field> *
+    clone (
+        bool deep
+    )
+    const override
+    {
+        return scinew dw_view ( this, deep );
+    };
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual inline view<Field> *
+    clone (
+        bool deep,
+        const IntVector & offset
+    )
+    const override
+    {
+        return scinew virtual_view<dw_view, Field> ( this, deep, offset );
+    };
+
+    /**
+     * @brief Get the region for which the view has access to the DataWarehouse
+     *
+     * @return support of the view
+     */
+    virtual inline Support
+    get_support()
+    const override
+    {
+        return {{ m_variable->getLowIndex(), m_variable->getHighIndex() }};
+    };
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        IntVector low { m_variable->getLowIndex() }, high { m_variable->getHighIndex() };
+
+        return ( low[X] <= id[X] && id[X] < high[X] ) &&
+               ( low[Y] <= id[Y] && id[Y] < high[Y] ) &&
+               ( low[Z] <= id[Z] && id[Z] < high[Z] );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual T &
+    operator[] (
+        const IntVector & id
+    ) override
+    {
+        return ( *m_view ) [id];
+    };
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        return ( *m_view ) [id];
+    };
+
+public: // DW METHODS
+
+    /**
+     * @brief initialize variable in the DW
+     *
+     * set the field equal to value at each point in the domain
+     *
+     * @remark T must not be const
+     *
+     * @param value initialization value
+     */
+    inline void
+    initialize (
+        const V & value
+    ) const
+    {
+        static_assert ( !std::is_const<T>::value, "cannot initialize const view" );
+        ASSERTMSG ( m_variable, "cannot initialize view of uninitialized variable" );
+        m_variable->initialize ( value );
+    }
+
+}; // dw_view
+
+template<typename T, size_t N, VarType VAR, DimType DIM, size_t GN>
+class dw_view < VectorField<T, N>, VAR, DIM, GN >
+    : virtual public view < VectorField<T, N> >
+    , virtual public view_array < dw_view < ScalarField<T>, VAR, DIM, GN >, ScalarField<T>, N >
+{
+public: // STATIC MEMBERS
+
+
+private: // TYPES
+
+    /// Type of field
+    using Field = VectorField<T, N>;
+
+    /// Type of View of each component
+    using View = dw_view < ScalarField<T>, VAR, DIM, GN >;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+    dw_view (
+        const dw_view * copy,
+        bool deep
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+        {
+            const auto & v = ( *copy ) [i];
+            this->m_view_ptr[i] = v.clone ( deep );
+        }
+    }
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components without gathering info from the DataWarehouse
+     *
+     * @param label list of variable labels for each component
+     * @param material material index
+     */
+    dw_view (
+        const typename Field::label_type & label,
+        int material
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+            this->m_view_ptr[i] = scinew View ( label[i], material );
+    }
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label list of variable labels for each component
+     * @param material material index
+     * @param patch grid patch
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    dw_view (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = View::use_ghosts_dflt
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+            this->m_view_ptr[i] = scinew View ( dw, label[i], material, patch, use_ghosts );
+    }
+
+    /// Destructor
+    virtual ~dw_view ()
+    {
+        for ( auto view : this->m_view_ptr )
+            delete view;
+    }
+
+    /// Prevent copy (and move) constructor
+    dw_view ( const dw_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dw_view & operator= ( const dw_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view<Field> *
+    clone (
+        bool deep
+    )
+    const override
+    {
+        return scinew dw_view ( this, deep );
+    };
+
+public: // DW METHODS
+
+    /**
+     * @brief initialize variable in the DW
+     *
+     * set the field equal to value at each point in the domain
+     *
+     * @remark T must not be const
+     *
+     * @param value initialization value
+     */
+    void
+    initialize (
+        const V & value
+    ) const
+    {
+        for ( auto & view : this->m_view_ptr )
+            dynamic_cast < View * > ( view )->initialize ( value );
+    }
+
+    /// Resolve ambiguous operator[]
+    using view_array < View, ScalarField<T>, N >::operator [];
+
+}; // dw_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif //Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dw_view_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/detail/dwfd_view.h b/src/CCA/Components/PhaseField/DataWarehouse/detail/dwfd_view.h
new file mode 100644
index 00000000..b57c7b88
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/detail/dwfd_view.h
@@ -0,0 +1,161 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/DataWarehouse/detail/dwfd_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dwfd_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_detail_dwfd_view_h
+
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_basic_fd_view.h>
+#include <CCA/Components/PhaseField/DataWarehouse/detail/dw_fd_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Wrapper of DataWarehouse variables for both basic and complex
+ * differential operations
+ *
+ * Adds to dw_view the possibility to compute finite-difference approximation of
+ * of differential operations at internal cells/points
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ * @tparam VAR type of variable representation
+ */
+template<typename Field, StnType STN, VarType VAR> class dwfd_view;
+
+template<typename T, StnType STN, VarType VAR>
+class dwfd_view < ScalarField<T>, STN, VAR >
+    : public dw_basic_fd_view < ScalarField<T>, STN, VAR >
+    , public dw_fd_view < ScalarField<T>, STN, VAR >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// View is constructed by dw_basic_fd_view
+    using dw_basic_fd_view<Field, STN, VAR>::dw_basic_fd_view;
+
+    /// Default destructor
+    virtual ~dwfd_view() = default;
+
+    /// Prevent copy (and move) constructor
+    dwfd_view ( const dwfd_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dwfd_view & operator= ( const dwfd_view & ) = delete;
+
+}; // class dwfd_view
+
+template<typename T, size_t N, StnType STN, VarType VAR>
+class dwfd_view < VectorField<T, N>, STN, VAR >
+    : virtual public view_array < dwfd_view < ScalarField<T>, STN, VAR >, ScalarField<T>, N >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = VectorField<T, N>;
+
+    /// Type of View of each component
+    using View = dwfd_view < ScalarField<T>, STN, VAR >;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components without gathering info from the DataWarehouse
+     *
+     * @param label list of variable labels for each component
+     * @param material material index
+     * @param level grid level
+     */
+    dwfd_view (
+        const typename Field::label_type & label,
+        int material,
+        const Level * level
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+            this->m_view_ptr[i] = scinew View ( label[i], material, level );
+    }
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate view components and gather info from dw
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param label list of variable labels for each component
+     * @param material material index
+     * @param patch grid patch
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    dwfd_view (
+        DataWarehouse * dw,
+        const typename Field::label_type & label,
+        int material,
+        const Patch * patch,
+        bool use_ghosts = View::use_ghosts_dflt
+    )
+    {
+        for ( size_t i = 0; i < N; ++i )
+            this->m_view_ptr[i] = scinew View ( dw, label[i], material, patch, use_ghosts );
+    }
+
+    /// Destructor
+    virtual ~dwfd_view()
+    {
+        for ( auto view : this->m_view_ptr )
+            delete view;
+    }
+
+    /// Prevent copy (and move) constructor
+    dwfd_view ( const dwfd_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    dwfd_view & operator= ( const dwfd_view & ) = delete;
+
+}; // dw_fd_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+// #include <CCA/Components/PhaseField/DataWarehouse/DWFDViewP5.h>
+// #include <CCA/Components/PhaseField/DataWarehouse/DWFDViewP7.h>
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_DataWarehouse_DWFDView_h
diff --git a/src/CCA/Components/PhaseField/DataWarehouse/sub.mk b/src/CCA/Components/PhaseField/DataWarehouse/sub.mk
new file mode 100644
index 00000000..7eabd628
--- /dev/null
+++ b/src/CCA/Components/PhaseField/DataWarehouse/sub.mk
@@ -0,0 +1,40 @@
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+#
+#
+#
+#
+# Makefile fragment for this subdirectory
+
+SRCDIR = CCA/Components/PhaseField/DataWarehouse
+
+SRCS += \
+   $(SRCDIR)/DWView-bld.cc \
+   $(SRCDIR)/DWFDView-bld.cc \
+
+BLDDIR := $(SRCTOP)/$(SRCDIR)
+
+BLDSRCS += \
+   $(BLDDIR)/DWView-bld.cc \
+   $(BLDDIR)/DWFDView-bld.cc \
diff --git a/src/CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.cc b/src/CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.cc
new file mode 100644
index 00000000..efc7fa4c
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.cc
@@ -0,0 +1,75 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.cc
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#include <CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.h>
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <iostream>
+#include <sstream>
+
+using namespace Uintah;
+using namespace PhaseField;
+
+IntVectorOutOfBounds::IntVectorOutOfBounds (
+    const IntVector & value,
+    const char * file,
+    int line
+) : m_value ( value )
+{
+    std::ostringstream s;
+    s << "An IntVectorOutOfBounds exception was thrown.\n"
+      << file << ":" << line << "\n"
+      << "index " << value;
+    m_msg = strdup ( s.str().c_str() );
+#ifdef EXCEPTIONS_CRASH
+    std::cout << m_msg << std::endl;
+#endif
+}
+
+IntVectorOutOfBounds::IntVectorOutOfBounds (
+    const IntVectorOutOfBounds & copy
+)
+    : m_value ( copy.m_value ),
+      m_msg ( strdup ( copy.m_msg ) )
+{
+}
+
+const char * IntVectorOutOfBounds::message() const
+{
+    return m_msg;
+}
+
+const char * IntVectorOutOfBounds::type() const
+{
+    return "ArrayIndexOutOfBounds";
+}
diff --git a/src/CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.h b/src/CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.h
new file mode 100644
index 00000000..62631e42
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.h
@@ -0,0 +1,93 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.cc
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Exceptions_IntVectorOutOfBounds_h
+#define Packages_Uintah_CCA_Components_PhaseField_Exceptions_IntVectorOutOfBounds_h
+
+#include <Core/Exceptions/Exception.h>
+#include <Core/Geometry/IntVector.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/// IntVectorOutOfBounds Exception
+class IntVectorOutOfBounds
+    : public Exception
+{
+private: // MEMBERS
+
+    /// out of bound IntVector
+    IntVector m_value;
+
+    /// error message
+    char * m_msg;
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// copy assignment
+    IntVectorOutOfBounds & operator= ( const IntVectorOutOfBounds );
+
+    /// copy constructor
+    IntVectorOutOfBounds (
+        const IntVectorOutOfBounds &
+    );
+
+    /**
+     * @brief Constuctor
+     *
+     * @param value out of bound IntVector
+     * @param file file name from which the exception is thrown
+     * @param line line number from which the exception is thrown
+     */
+    IntVectorOutOfBounds (
+        const IntVector & value,
+        const char * file,
+        int line
+    );
+
+    /// default destructor
+    virtual ~IntVectorOutOfBounds() = default;
+
+public: // METHODS
+
+    /// get error message
+    virtual const char * message() const;
+
+    /// get exception name
+    virtual const char * type() const;
+
+}; // class IntVectorOutOfBounds
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Exceptions_IntVectorOutOfBounds_h
diff --git a/src/CCA/Components/PhaseField/Exceptions/sub.mk b/src/CCA/Components/PhaseField/Exceptions/sub.mk
new file mode 100644
index 00000000..15bc5809
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Exceptions/sub.mk
@@ -0,0 +1,33 @@
+#
+#  The MIT License
+#
+#  Copyright (c) 1997-2018 The University of Utah
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+#  IN THE SOFTWARE.
+#
+#
+#
+#
+#
+# Makefile fragment for this subdirectory
+
+SRCDIR = CCA/Components/PhaseField/Exceptions
+
+SRCS += \
+   $(SRCDIR)/IntVectorOutOfBounds.cc \
diff --git a/src/CCA/Components/PhaseField/Factory/Base.h b/src/CCA/Components/PhaseField/Factory/Base.h
new file mode 100644
index 00000000..c93a2a39
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Factory/Base.h
@@ -0,0 +1,108 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Factory/Base.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Factory_Base_h
+#define Packages_Uintah_CCA_Components_PhaseField_Factory_Base_h
+
+#include <string>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Generic factory base class
+ *
+ * Make possible to create a new instance of a virtual class choosing which
+ * derived class implementation to create according to a string
+ *
+ * @tparam B virtual base class type
+ */
+template<typename B>
+class Base
+{
+private:
+    /// Determine if the class definition is registered
+    const bool m_isRegistered;
+
+protected:
+    /**
+    * @brief Default constructor
+    *
+    * Virtual class is not registered
+    */
+    Base() :
+        m_isRegistered ( false )
+    { };
+
+    /**
+    * @brief Constructor for Implementation
+    *
+    * This constructor is called by the constructor of any Implementation of B
+    *
+    * @param isRegistered whether the Implementation is registered
+    */
+    Base ( bool isRegistered ) :
+        m_isRegistered ( isRegistered )
+    { };
+
+    /**
+     * @brief Default destructor
+     */
+    virtual ~Base() = default;
+
+    /**
+     * @brief Get registered status
+     *
+     * Determine if this is an instance of an Implementation registered to the
+     * factory.
+     *
+     * @return whether the Implementation is registered
+     */
+    bool isRegistered() const
+    {
+        return m_isRegistered;
+    };
+
+    /**
+     * @brief Get Implementation name
+     *
+     * Provide a way for derived classes to identify themselves
+     *
+     * @return string identifying a derived class
+     */
+    virtual std::string getName() = 0;
+};
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif
diff --git a/src/CCA/Components/PhaseField/Factory/Factory.h b/src/CCA/Components/PhaseField/Factory/Factory.h
new file mode 100644
index 00000000..cf0faf41
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Factory/Factory.h
@@ -0,0 +1,115 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Factory/Factory.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Factory_Factory_h
+#define Packages_Uintah_CCA_Components_PhaseField_Factory_Factory_h
+
+#include <functional>
+#include <map>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Generic factory creator class
+ *
+ * Make possible to create a new instance of a virtual class choosing which
+ * derived class implementation to create according to a string
+ *
+ * @tparam B virtual base class type
+ * @tparam Args types of the arguments for the derived classes constructors
+ */
+template<typename B, typename ... Args>
+class Factory
+{
+protected:
+    /// Pointer type of the derived classes constructors
+    using FactoryMethod = std::function< Base<B> * ( Args... ) >;
+
+    /// Type of the map between strings and derived classes constructors
+    using FactoryMap = std::map<std::string, FactoryMethod>;
+
+    /// Mapping between strings and derived classes constructors
+    static FactoryMap RegisteredNames;
+
+public:
+    /**
+     * @brief Register to the factory
+     *
+     * Register a string with a particular derived class constructor
+     *
+     * @param name string to be registered
+     * @param constructor pointer to the derived class constructor
+     * @return whether it was added or updated
+     */
+    static bool
+    Register (
+        std::string name,
+        FactoryMethod constructor
+    )
+    {
+        // add the pair to the map
+        auto registeredPair = Factory::RegisteredNames.insert ( std::make_pair ( name.c_str(), constructor ) );
+        // return whether it was added or updated
+        return registeredPair.second;
+    }
+
+    /**
+     * @brief Factory create
+     *
+     * Create a derived class given a string
+     *
+     * @param name string identifying a registered derived class
+     * @param args parameters forwarded to the constructor
+     * @return new instance of derived class
+     */
+    static Base<B> *
+    Create (
+        std::string name,
+        Args ... args
+    )
+    {
+        // attempt to get the pair from the map
+        auto registeredPair = Factory::RegisteredNames.find ( name );
+        // did we find one?
+        if ( registeredPair == Factory::RegisteredNames.end() )
+            return nullptr; // return NULL
+        // return a new instance of derived class
+        return registeredPair->second ( args... );
+    }
+
+}; // class typename
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif
diff --git a/src/CCA/Components/PhaseField/Factory/Implementation.h b/src/CCA/Components/PhaseField/Factory/Implementation.h
new file mode 100644
index 00000000..b39ed0d2
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Factory/Implementation.h
@@ -0,0 +1,109 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Factory/Implementation.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Factory_Implementation_h
+#define Packages_Uintah_CCA_Components_PhaseField_Factory_Implementation_h
+
+#include <Core/Malloc/Allocator.h>
+#include <CCA/Components/PhaseField/Factory/Base.h>
+#include <CCA/Components/PhaseField/Factory/Factory.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Generic factory implementation class
+ *
+ * Make possible to create a new instance of a virtual class choosing which
+ * derived class implementation to create according to a string
+ *
+ * @tparam I derived class type
+ * @tparam B virtual base class type
+ * @tparam Args types of the arguments for the derived classes constructors
+ */
+template<typename I, typename B, typename ... Args>
+class Implementation : public Base<B>
+{
+protected:
+    /// Determine if the class definition is registered
+    static const bool m_isRegistered;
+
+protected:
+    /**
+     * @brief Factory create
+     *
+     * Give derived classes the ability to create themselves
+     *
+     * @param args parameters forwarded to the constructor
+     * @return new instance of derived class
+     */
+    static Base<B> *
+    Create (
+        Args ... args
+    )
+    {
+        return scinew I ( args... );
+    }
+
+    /**
+     * @brief Get Implementation name
+     *
+     * Get the identifier of the derived class
+     *
+     * @return string identifying a derived class
+     */
+    virtual std::string
+    getName()
+    override
+    {
+        return I::Name;
+    }
+
+    /**
+    * @brief Default constructor
+    *
+    * Initialize derived class and register it to the factory
+    */
+    Implementation()
+        : Base<B> ( m_isRegistered )
+    {}
+};
+
+// attempt to initialize the IsRegistered variable of derived classes
+// whilst registering them to the factory
+template<typename I, typename B, typename ... Args>
+const bool Implementation<I, B, Args ...>::m_isRegistered = Factory<B, Args ...>::Register ( I::Name, &Implementation<I, B, Args ... >::Create );
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif
diff --git a/src/CCA/Components/PhaseField/PhaseField.h b/src/CCA/Components/PhaseField/PhaseField.h
deleted file mode 100644
index 26ef9210..00000000
--- a/src/CCA/Components/PhaseField/PhaseField.h
+++ /dev/null
@@ -1,1062 +0,0 @@
-/*
- * The MIT License
- *
- * Copyright (c) 1997-2018 The University of Utah
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef Packages_Uintah_CCA_Components_PhaseField_PhaseField_h
-#define Packages_Uintah_CCA_Components_PhaseField_PhaseField_h
-
-#include <CCA/Components/Application/ApplicationCommon.h>
-
-#include <Core/Grid/Ghost.h>
-#include <Core/Grid/Patch.h>
-#include <Core/Grid/SimpleMaterial.h>
-#include <Core/Grid/Task.h>
-#include <Core/Grid/Variables/BlockRange.hpp>
-#include <Core/Grid/Variables/CCVariable.h>
-#include <Core/Grid/Variables/NCVariable.h>
-#include <Core/Grid/Variables/VarLabel.h>
-#include <Core/Util/DebugStream.h>
-#include <CCA/Ports/Scheduler.h>
-
-#include <sci_defs/kokkos_defs.h>
-
-namespace Uintah
-{
-
-class TypeDescription;
-
-namespace PF
-{
-enum VariableType { CellCentered = Ghost::AroundCells, NodeCentered = Ghost::AroundNodes };
-
-template<VariableType VariableType>
-using ConstVariable = typename std::conditional< VariableType == PF::CellCentered, constCCVariable<double>, constNCVariable<double> >::type;
-
-template<VariableType VariableType>
-using Variable = typename std::conditional < VariableType == PF::CellCentered, CCVariable<double>, NCVariable<double> >::type;
-
-#ifdef UINTAH_ENABLE_KOKKOS
-
-template<VariableType VariableType>
-using ConstView = KokkosView3<double const>;
-
-template<VariableType VariableType>
-using View = KokkosView3<double>;
-
-#else
-
-template<VariableType VariableType>
-using ConstView = ConstVariable<VariableType> & ;
-
-template<VariableType VariableType>
-using View = Variable<VariableType> & ;
-
-#endif
-
-template <int n>
-struct static_false
-{
-    enum { value = n != n };
-};
-
-template<VariableType VariableType>
-Point get_position ( Patch const * patch, IntVector const & i )
-{
-    static_assert ( static_false<VariableType>::value, "get_position<VariableType> not implemented" );
-    return { NAN, NAN, NAN };
-}
-
-template<>
-Point get_position<CellCentered> ( Patch const * patch, IntVector const & i )
-{
-    return patch->getCellPosition ( i );
-}
-
-template<>
-Point get_position<NodeCentered> ( Patch const * patch, IntVector const & i )
-{
-    return patch->getNodePosition ( i );
-}
-
-template<VariableType VariableType>
-IntVector get_low ( Patch const * patch )
-{
-    static_assert ( static_false<VariableType>::value, "get_low<VariableType> not implemented" );
-    return { 0, 0, 0 };
-}
-
-template<>
-IntVector get_low<CellCentered> ( Patch const * patch )
-{
-    return patch->getCellLowIndex();
-}
-
-template<>
-IntVector get_low<NodeCentered> ( Patch const * patch )
-{
-    return patch->getNodeLowIndex();
-}
-
-template<VariableType VariableType>
-IntVector get_high ( Patch const * patch )
-{
-    static_assert ( static_false<VariableType>::value, "get_high<VariableType> not implemented" );
-    return { 0, 0, 0 };
-}
-
-template<>
-IntVector get_high<CellCentered> ( Patch const * patch )
-{
-    return patch->getCellHighIndex();
-}
-
-template<>
-IntVector get_high<NodeCentered> ( Patch const * patch )
-{
-    return patch->getNodeHighIndex();
-}
-
-template<VariableType VariableType>
-BlockRange get_range ( Patch const * patch )
-{
-    return { get_low<VariableType> ( patch ), get_high<VariableType> ( patch ) };
-}
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-typename std::enable_if < NumGhosts != 1 || ( Dimension != 2 && Dimension != 3 ), BlockRange >::type get_inner_range ( Patch const * patch )
-{
-    static_assert ( static_false<VariableType>::value, "get_inner_range<VariableType, NumGhosts, Dimension> not implemented" );
-    return { IntVector ( 0, 0, 0 ), IntVector ( 0, 0, 0 ) };
-}
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-typename std::enable_if < NumGhosts == 1 && Dimension == 2, BlockRange >::type get_inner_range ( Patch const * patch )
-{
-    return { get_low<VariableType> ( patch ) + IntVector (
-                 patch->getBCType ( Patch::xminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yminus ) == Patch::Neighbor ? 0 : 1,
-                 0
-             ),
-             get_high<VariableType> ( patch ) - IntVector (
-                 patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 0 : 1,
-                 0
-             )
-           };
-}
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-typename std::enable_if < NumGhosts == 1 && Dimension == 3, BlockRange >::type get_inner_range ( Patch const * patch )
-{
-    return { get_low<VariableType> ( patch ) + IntVector (
-                 patch->getBCType ( Patch::xminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yminus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::zminus ) == Patch::Neighbor ? 0 : 1
-             ),
-             get_high<VariableType> ( patch ) - IntVector (
-                 patch->getBCType ( Patch::xplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::yplus ) == Patch::Neighbor ? 0 : 1,
-                 patch->getBCType ( Patch::zplus ) == Patch::Neighbor ? 0 : 1
-             )
-           };
-}
-
-template<VariableType VariableType>
-BlockRange get_face_range ( Patch const * patch, Patch::FaceType face )
-{
-    static_assert ( static_false<VariableType>::value, "get_face_range<VariableType> not implemented" );
-    return { IntVector ( 0, 0, 0 ), IntVector ( 0, 0, 0 ) };
-}
-
-template<>
-BlockRange get_face_range<CellCentered> ( Patch const * patch, Patch::FaceType face )
-{
-    IntVector l, h;
-    patch->getFaceCells ( face, 0, l, h );
-    return { l, h };
-}
-
-template<>
-BlockRange get_face_range<NodeCentered> ( Patch const * patch, Patch::FaceType face )
-{
-    IntVector l, h;
-    patch->getFaceNodes ( face, 0, l, h );
-    return { l, h };
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if < NumGhosts != 1, double >::type dx ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    static_assert ( static_false<VariableType>::value, "dx<VariableType, NumGhosts> not implemented" );
-    return NAN;
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if<NumGhosts == 1, double>::type dx ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) - psi ( i - 1, j, k ) ) / ( 2. * d.x() );
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if < NumGhosts != 1, double >::type dy ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    static_assert ( static_false<VariableType>::value, "dy<VariableType, NumGhosts> not implemented" );
-    return NAN;
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if<NumGhosts == 1, double>::type dy ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) - psi ( i, j - 1, k ) ) / ( 2. * d.y() );
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if < NumGhosts != 1, double >::type dz ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    static_assert ( static_false<VariableType>::value, "dz<VariableType, NumGhosts> not implemented" );
-    return NAN;
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if<NumGhosts == 1, double>::type dz ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j, k + 1 ) - psi ( i, j, k - 1 ) ) / ( 2. * d.z() );
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if < NumGhosts != 1, double >::type dxx ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    static_assert ( static_false<VariableType>::value, "dxx<VariableType, NumGhosts> not implemented" );
-    return NAN;
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if<NumGhosts == 1, double>::type dxx ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i + 1, j, k ) + psi ( i - 1, j, k ) - 2. * psi ( i, j, k ) ) / ( d.x() * d.x() );
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if < NumGhosts != 1, double >::type dyy ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    static_assert ( static_false<VariableType>::value, "dyy<VariableType, NumGhosts> not implemented" );
-    return NAN;
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if<NumGhosts == 1, double>::type dyy ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j + 1, k ) + psi ( i, j - 1, k ) - 2. * psi ( i, j, k ) ) / ( d.y() * d.y() );
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if < NumGhosts != 1, double >::type dzz ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    static_assert ( static_false<VariableType>::value, "dzz<VariableType, NumGhosts> not implemented" );
-    return NAN;
-}
-
-template<VariableType VariableType, int NumGhosts>
-typename std::enable_if<NumGhosts == 1, double>::type dzz ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    Vector const d ( patch->getLevel()->dCell() );
-    return ( psi ( i, j, k + 1 ) + psi ( i, j, k - 1 ) - 2. * psi ( i, j, k ) ) / ( d.z() * d.z() );
-}
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-typename std::enable_if < NumGhosts == 1 && Dimension == 2, double >::type laplacian ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    return dxx<VariableType, NumGhosts> ( i, j, k, patch, psi ) + dyy<VariableType, NumGhosts> ( i, j, k, patch, psi );
-}
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-typename std::enable_if < NumGhosts == 1 && Dimension == 3, double >::type laplacian ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    return dxx<VariableType, NumGhosts> ( i, j, k, patch, psi ) + dyy<VariableType, NumGhosts> ( i, j, k, patch, psi ) + dzz<VariableType, NumGhosts> ( i, j, k, patch, psi );
-}
-
-template<VariableType VariableType, int NumGhosts, int Dimension>
-typename std::enable_if < NumGhosts != 1 || ( Dimension != 2 && Dimension != 3 ), double >::type laplacian ( int i, int j, int k, Patch const * patch, ConstView<VariableType> psi )
-{
-    static_assert ( static_false<VariableType>::value, "laplacian<VariableType, NumGhosts, Dimension> not implemented" );
-    return NAN;
-}
-
-}
-
-template<int N> struct factorial
-{
-    enum { value = N * factorial < N - 1 >::value };
-};
-
-template<> struct factorial<0>
-{
-    enum { value = 1 };
-};
-
-template<int N, int R> struct combinations
-{
-    enum { value = factorial<N>::value / ( factorial<R>::value * factorial < N - R >::value ) };
-};
-
-std::ostream& operator << ( std::ostream& stream, const BlockRange& range )
-{
-    return stream << "(" << range.begin ( 0 ) << "," <<  range.begin ( 1 ) <<"," <<  range.begin ( 2 ) <<") - (" << range.end ( 0 ) <<"," << range.end ( 1 ) <<"," << range.end ( 2 ) << ")";
-}
-
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-class PhaseField :
-    public ApplicationCommon
-{
-protected:
-    constexpr static Patch::FaceType start_face = static_cast<Patch::FaceType> ( 0 );
-    constexpr static Patch::FaceType end_face = static_cast<Patch::FaceType> ( Dimension * 2 );
-    constexpr static int b_size = combinations<Dimension, 2>::value;
-    constexpr static int xy = 0;
-    constexpr static int xz = 1;
-    constexpr static int yz = 2;
-
-    using ConstVariable = PF::ConstVariable<VariableType>;
-    using Variable = PF::Variable<VariableType>;
-    using ConstView = PF::ConstView<VariableType>;
-    using View = PF::View<VariableType>;
-    template < int N > using ConstVariables = std::array < ConstVariable, N >;
-    template < int N > using Variables = std::array < Variable, N >;
-
-#ifdef UINTAH_ENABLE_KOKKOS
-    template < int N > using ConstViews = std::array < ConstView, N >;
-    template < int N > using Views = std::array < View, N >;
-
-    static constexpr ConstView get_view ( ConstVariable & var )
-    {
-        return var.getKokkosView();
-    }
-
-    static constexpr View get_view ( Variable & var )
-    {
-        return var.getKokkosView();
-    }
-
-    template < int N >6
-    static constexpr ConstViews<N> get_views ( ConstVariables<N> & vars )
-    {
-        ConstViews<N> views;
-        for ( int d = 0; d < N; ++d )
-            views[d] = get_view ( vars[d] );
-        return views;
-    }
-
-    template < int N >
-    static constexpr Views<N> get_views ( Variables<N> & vars )
-    {
-        Views<N> views;
-        for ( int d = 0; d < N; ++d )
-            views[d] = get_view ( vars[d] );
-        return views;
-    }
-#else
-    template < int N > using ConstViews = ConstVariables<N> & ;
-    template < int N > using Views = Variables<N> & ;
-
-    static constexpr ConstView get_view ( ConstVariable & var )
-    {
-        return var;
-    }
-    static constexpr View get_view ( Variable & var )
-    {
-        return var;
-    }
-
-    template < int N >
-    static constexpr ConstViews<N> get_views ( ConstVariables<N> & vars )
-    {
-        return vars;
-    }
-
-    template < int N >
-    static constexpr Views<N> get_views ( Variables<N> & vars )
-    {
-        return vars;
-    }
-#endif
-
-
-    template <typename... Args>
-    static Point get_position ( Args && ... args )
-    {
-        return PF::get_position<VariableType> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static IntVector get_low ( Args && ... args )
-    {
-        return PF::get_low<VariableType> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static IntVector get_high ( Args && ... args )
-    {
-        return PF::get_high<VariableType> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static BlockRange get_range ( Args && ... args )
-    {
-        return PF::get_range<VariableType> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static BlockRange get_inner_range ( Args && ... args )
-    {
-        return PF::get_inner_range<VariableType, NumGhosts, Dimension> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static BlockRange get_face_range ( Args && ... args )
-    {
-        return PF::get_face_range<VariableType> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static double dx ( Args && ... args )
-    {
-        return PF::dx<VariableType, NumGhosts> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static double dy ( Args && ... args )
-    {
-        return PF::dy<VariableType, NumGhosts> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static double dz ( Args && ... args )
-    {
-        return PF::dz<VariableType, NumGhosts> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static double dxx ( Args && ... args )
-    {
-        return PF::dxx<VariableType, NumGhosts> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static double dyy ( Args && ... args )
-    {
-        return PF::dyy<VariableType, NumGhosts> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static double dzz ( Args && ... args )
-    {
-        return PF::dzz<VariableType, NumGhosts> ( std::forward<Args> ( args )... );
-    }
-
-    template <typename... Args>
-    static double laplacian ( Args && ... args )
-    {
-        return PF::laplacian<VariableType, NumGhosts, Dimension> ( std::forward<Args> ( args )... );
-    }
-
-    static const Ghost::GhostType GhostType = static_cast<Ghost::GhostType> ( VariableType );
-
-    double const tol = 1.e-6;
-
-    DebugStream dbg_out1, dbg_out2, dbg_out3, dbg_out4;
-
-    double delt, alpha, r0, delta, epsilon, phi0, lambda, gamma_psi, gamma_u;
-    VarLabel const * psi_label, * u_label;
-    VarLabel const * grad_psi_norm2_label, * grad_psi_label[Dimension];
-    VarLabel const * a_label, * a2_label, * b_label[b_size];
-
-public:
-    PhaseField ( const ProcessorGroup * myworld,
-		 const MaterialManagerP materialManager,
-		 int verbosity = 0 );
-  
-    virtual ~PhaseField();
-
-protected:
-    PhaseField ( PhaseField const & ) = delete;
-    PhaseField & operator= ( PhaseField const & ) = delete;
-
-    virtual void problemSetup ( ProblemSpecP const & params, ProblemSpecP const & restart_prob_spec, GridP & grid ) override;
-    virtual void scheduleInitialize ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleRestartInitialize ( LevelP const & level, SchedulerP & sched )
-    {
-        /*TODO*/
-    };
-    virtual void scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched ) override;
-    virtual void scheduleTimeAdvance ( LevelP const & level, SchedulerP & ) override;
-
-protected:
-    virtual void task_time_advance_grad_psi_requires ( LevelP const & level, Task * task );
-    virtual void task_time_advance_grad_psi_computes ( Task * task );
-    virtual void task_time_advance_anisotropy_terms_requires ( LevelP const & level, Task * task );
-    virtual void task_time_advance_anisotropy_terms_computes ( Task * task );
-    virtual void task_time_advance_current_solution_requires ( LevelP const & level, Task * task );
-    virtual void task_time_advance_current_solution_computes ( Task * task );
-
-    void task_initialize ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_compute_stable_timestep ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_time_advance_grad_psi ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_time_advance_anisotropy_terms ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-    void task_time_advance_current_solution ( ProcessorGroup const * myworld, PatchSubset const * patches, MaterialSubset const * matls, DataWarehouse * dw_old, DataWarehouse * dw_new );
-
-    void initialize_current_solution ( int i, int j, int k, Patch const * patch, View psi, View u );
-    void time_advance_grad_psi ( int i, int j, int k, Patch const * patch, ConstView psi, Views<Dimension> grad_psi, View grad_psi_norm2 );
-    void time_advance_grad_psi ( int i, int j, int k, Patch::FaceType face, Patch const * patch, ConstView psi, Views<Dimension> grad_psi, View grad_psi_norm2 );
-    void time_advance_anisotropy_terms ( int i, int j, int k, Patch const * patch, ConstViews<Dimension> grad_psi, ConstView grad_psi_norm2, View a, View a2, Views<b_size> b );
-    void time_advance_solution ( int i, int j, int k, Patch const * patch, ConstView psi_old, ConstView u_old, ConstViews<Dimension> grad_psi, ConstView grad_psi_norm2, ConstView a, ConstView a2, ConstViews<b_size> b, View psi_new, View u_new );
-    void time_advance_solution ( int i, int j, int k, Patch::FaceType face, Patch const * patch, ConstView psi_old, ConstView u_old, ConstViews<Dimension> grad_psi, ConstView grad_psi_norm2, ConstView a, ConstView a2, ConstViews<b_size> b6, View psi_new, View u_new );
-};
-
-extern template class PhaseField <PF::CellCentered, 1, 2>;
-extern template class PhaseField <PF::NodeCentered, 1, 2>;
-extern template class PhaseField <PF::CellCentered, 1, 3>;
-extern template class PhaseField <PF::NodeCentered, 1, 3>;
-
-using CCPhaseField2D = PhaseField <PF::CellCentered, 1, 2>;
-using NCPhaseField2D = PhaseField <PF::NodeCentered, 1, 2>;
-using CCPhaseField3D = PhaseField <PF::CellCentered, 1, 3>;
-using NCPhaseField3D = PhaseField <PF::NodeCentered, 1, 3>;
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-PhaseField<VariableType, NumGhosts, Dimension>::PhaseField ( ProcessorGroup const * myworld, const MaterialManagerP materialManager, int verbosity )
-  : ApplicationCommon ( myworld, materialManager )
-    , dbg_out1 ( "PhaseField", verbosity > 0 )
-    , dbg_out2 ( "PhaseField", verbosity > 1 )
-    , dbg_out3 ( "PhaseField", verbosity > 2 )
-    , dbg_out4 ( "PhaseField", verbosity > 3 )
-{
-    psi_label = VarLabel::create ( "psi", Variable::getTypeDescription() );
-    u_label = VarLabel::create ( "u", Variable::getTypeDescription() );
-    grad_psi_norm2_label = VarLabel::create ( "grad_psi_norm2", Variable::getTypeDescription() );
-    grad_psi_label[0] = VarLabel::create ( "psi_x", Variable::getTypeDescription() );
-    grad_psi_label[1] = VarLabel::create ( "psi_y", Variable::getTypeDescription() );
-    a_label = VarLabel::create ( "A", Variable::getTypeDescription() );
-    a2_label = VarLabel::create ( "A2", Variable::getTypeDescription() );
-    b_label[xy] = VarLabel::create ( "Bxy", Variable::getTypeDescription() );
-    if ( Dimension > 2 )
-    {
-        grad_psi_label[2] = VarLabel::create ( "psi_z", Variable::getTypeDescription() );
-        b_label[xz] = VarLabel::create ( "Bxz", Variable::getTypeDescription() );
-        b_label[yz] = VarLabel::create ( "Byz", Variable::getTypeDescription() );
-    }
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-PhaseField<VariableType, NumGhosts, Dimension>::~PhaseField()
-{
-    VarLabel::destroy ( psi_label );
-    VarLabel::destroy ( u_label );
-    VarLabel::destroy ( grad_psi_norm2_label );
-    VarLabel::destroy ( a_label );
-    VarLabel::destroy ( a2_label );
-    for ( int d = 0; d < Dimension; ++d )
-        VarLabel::destroy ( grad_psi_label[d] );
-    for ( int d = 0; d < b_size; ++d )
-        VarLabel::destroy ( b_label[d] );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::problemSetup ( ProblemSpecP const & params, ProblemSpecP const & /*restart_prob_spec*/, GridP & /*grid*/ )
-{
-    setLockstepAMR( true );
-
-    m_materialManager->registerSimpleMaterial ( scinew SimpleMaterial() );
-
-    ProblemSpecP phase_field = params->findBlock ( "PhaseField" );
-    phase_field->require ( "delt", delt );
-    phase_field->require ( "alpha", alpha );
-    phase_field->require ( "R0", r0 );
-    phase_field->require ( "Delta", delta );
-    phase_field->require ( "epsilon", epsilon );
-    phase_field->getWithDefault ( "gamma_psi", gamma_psi, 1. );
-    phase_field->getWithDefault ( "gamma_u", gamma_u, 1. );
-
-    lambda = alpha / 0.6267;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::scheduleInitialize ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "PhaseField::task_initialize", this, &PhaseField::task_initialize );
-    task->computes ( psi_label );
-    task->computes ( u_label );
-    task->computes ( grad_psi_norm2_label );
-    task->computes ( a_label );
-    task->computes ( a2_label );
-    for ( int d = 0; d < Dimension; ++d )
-        task->computes ( grad_psi_label[d] );
-    for ( int d = 0; d < b_size; ++d )
-        task->computes ( b_label[d] );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::scheduleComputeStableTimeStep ( LevelP const & level, SchedulerP & sched )
-{
-    Task * task = scinew Task ( "PhaseField::task_compute_stable_timestep", this, &PhaseField::task_compute_stable_timestep );
-    task->computes ( getDelTLabel(), level.get_rep() );
-    sched->addTask ( task, level->eachPatch(), m_materialManager->allMaterials() );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::scheduleTimeAdvance ( LevelP const & level, SchedulerP & sched )
-{
-    dbg_out1 << "*** PhaseField::scheduleTimeAdvance " << * ( level.get_rep() ) << " " << sched << std::endl;
-
-    Task * task_psi_grad = scinew Task ( "PhaseField::task_time_advance_grad_psi", this, &PhaseField::task_time_advance_grad_psi );
-    Task * task_anisotropy_terms = scinew Task ( "PhaseField::task_time_advance_anisotropy_terms", this, &PhaseField::task_time_advance_anisotropy_terms );
-    Task * task_current_solution = scinew Task ( "PhaseField::task_time_advance_current_solution", this, &PhaseField::task_time_advance_current_solution );
-
-    task_time_advance_grad_psi_requires ( level, task_psi_grad );
-    task_time_advance_grad_psi_computes ( task_psi_grad );
-
-    task_time_advance_anisotropy_terms_requires ( level, task_anisotropy_terms );
-    task_time_advance_anisotropy_terms_computes ( task_anisotropy_terms );
-
-    task_time_advance_current_solution_requires ( level, task_current_solution );
-    task_time_advance_current_solution_computes ( task_current_solution );
-
-    sched->addTask ( task_psi_grad, level->eachPatch(), m_materialManager->allMaterials() );
-    sched->addTask ( task_anisotropy_terms, level->eachPatch(), m_materialManager->allMaterials() );
-    sched->addTask ( task_current_solution, level->eachPatch(), m_materialManager->allMaterials() );
-
-    dbg_out2 << std::endl;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_grad_psi_requires ( LevelP const & level, Task * task )
-{
-    task->requires ( Task::OldDW, psi_label, GhostType, NumGhosts );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_grad_psi_computes ( Task * task )
-{
-    task->computes ( grad_psi_norm2_label );
-    for ( int d = 0; d < Dimension; ++d )
-        task->computes ( grad_psi_label[d] );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_anisotropy_terms_requires ( LevelP const & level, Task * task )
-{
-    task->requires ( Task::NewDW, grad_psi_norm2_label, Ghost::None, 0 );
-    for ( int d = 0; d < Dimension; ++d )
-        task->requires ( Task::NewDW, grad_psi_label[d], Ghost::None, 0 );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_anisotropy_terms_computes ( Task * task )
-{
-    task->computes ( a_label );
-    task->computes ( a2_label );
-    for ( int d = 0; d < b_size; ++d )
-        task->computes ( b_label[d] );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_current_solution_requires ( LevelP const & level, Task * task )
-{
-    task->requires ( Task::OldDW, psi_label, GhostType, NumGhosts );
-    task->requires ( Task::OldDW, u_label, GhostType, NumGhosts );
-    task->requires ( Task::NewDW, grad_psi_norm2_label, GhostType, NumGhosts );
-    task->requires ( Task::NewDW, a_label, Ghost::Ghost::None, 0 );
-    task->requires ( Task::NewDW, a2_label, GhostType, NumGhosts );
-    for ( int d = 0; d < Dimension; ++d )
-        task->requires ( Task::NewDW, grad_psi_label[d], GhostType, NumGhosts );
-    for ( int d = 0; d < b_size; ++d )
-        task->requires ( Task::NewDW, b_label[d], GhostType, NumGhosts );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_current_solution_computes ( Task * task )
-{
-    task->computes ( psi_label );
-    task->computes ( u_label );
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_initialize ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== PhaseField::task_initialize ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        Variable psi, u, grad_psi_norm2, a, a2;
-        Variables<Dimension> grad_psi;
-        Variables<b_size> b;
-        dw_new->allocateAndPut ( psi, psi_label, 0, patch );
-        dw_new->allocateAndPut ( u, u_label, 0, patch );
-        dw_new->allocateAndPut ( grad_psi_norm2, grad_psi_norm2_label, 0, patch );
-        dw_new->allocateAndPut ( a, a_label, 0, patch );
-        dw_new->allocateAndPut ( a2, a2_label, 0, patch );
-        dbg_out4 << "psi \t range " << psi.getLowIndex() << psi.getHighIndex() << std::endl;
-        dbg_out4 << "u \t range " << u.getLowIndex() << u.getHighIndex() << std::endl;
-        dbg_out4 << "grad_psi_norm2 \t range " << grad_psi_norm2.getLowIndex() << grad_psi_norm2.getHighIndex() << std::endl;
-        dbg_out4 << "a \t range " << a.getLowIndex() << a.getHighIndex() << std::endl;
-        dbg_out4 << "a2 \t range " << a2.getLowIndex() << a2.getHighIndex() << std::endl;
-
-        for ( int d = 0; d < Dimension; ++d )
-        {
-            dw_new->allocateAndPut ( grad_psi[d], grad_psi_label[d], 0, patch );
-            dbg_out4 << grad_psi_label[d]->getName() << "\t range " << grad_psi[d].getLowIndex() << grad_psi[d].getHighIndex() << std::endl;
-        }
-
-        for ( int d = 0; d < b_size; ++d )
-        {
-            dw_new->allocateAndPut ( b[d], b_label[d], 0, patch );
-            dbg_out4 << b_label[d]->getName() << "\t range " << b[d].getLowIndex() <<  b[d].getHighIndex() << std::endl;
-        }
-
-        BlockRange range ( get_range ( patch ) );
-
-        dbg_out3 << "= Iterating over range " << range << std::endl;
-        parallel_for ( range, [patch, &psi, &u, this] ( int i, int j, int k )->void { initialize_current_solution ( i, j, k, patch, get_view ( psi ), get_view ( u ) ); } );
-
-        a.initialize ( 0. );
-        a2.initialize ( 0. );
-        grad_psi_norm2.initialize ( 0. );
-        for ( int d = 0; d < Dimension; ++d )
-            grad_psi[d].initialize ( 0. );
-        for ( int d = 0; d < b_size; ++d )
-            b[d].initialize ( 0. );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_compute_stable_timestep ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== PhaseField::task_compute_stable_timestep ====" << std::endl;
-    dw_new->put ( delt_vartype ( delt ), getDelTLabel(), getLevel ( patches ) );
-    dbg_out2 << std::endl;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_grad_psi ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== PhaseField::task_time_advance_grad_psi ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << ")" << std::endl;
-
-        ConstVariable psi;
-        dw_old->get ( psi, psi_label, 0, patch, GhostType, NumGhosts );
-        dbg_out4 << "psi \t range " << psi.getLowIndex() << psi.getHighIndex() << std::endl;
-
-        Variable grad_psi_norm2;
-        dw_new->allocateAndPut ( grad_psi_norm2, grad_psi_norm2_label, 0, patch );
-        dbg_out4 << "grad_psi_norm2 \t range " << grad_psi_norm2.getLowIndex() << grad_psi_norm2.getHighIndex() << std::endl;
-
-        Variables<Dimension> grad_psi;
-        for ( int d = 0; d < Dimension; ++d )
-        {
-            dw_new->allocateAndPut ( grad_psi[d], grad_psi_label[d], 0, patch );
-            dbg_out4 << grad_psi_label[d]->getName() << "\t range " << grad_psi[d].getLowIndex() << grad_psi[d].getHighIndex() << std::endl;
-        }
-
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range" << range << std::endl;
-        parallel_for ( range, [patch, &psi, &grad_psi, &grad_psi_norm2, this] ( int i, int j, int k )->void { time_advance_grad_psi ( i, j, k, patch, get_view ( psi ), get_views<Dimension> ( grad_psi ), get_view ( grad_psi_norm2 ) ); } );
-
-        for ( auto face = start_face; face < end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                BlockRange range ( get_face_range ( patch, face ) );
-
-                dbg_out3 << "= Iterating over " << face << " face range " << range << std::endl;
-                parallel_for ( range, [face, patch, &psi, &grad_psi, &grad_psi_norm2, this] ( int i, int j, int k )->void { time_advance_grad_psi ( i, j, k, face, patch, get_view ( psi ), get_views<Dimension> ( grad_psi ), get_view ( grad_psi_norm2 ) ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_anisotropy_terms ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * /*dw_old*/, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== PhaseField::task_time_advance_anisotropy_terms ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable grad_psi_norm2;
-        dw_new->get ( grad_psi_norm2, grad_psi_norm2_label, 0, patch, Ghost::None, 0 );
-        dbg_out4 << "grad_psi_norm2 \t range " << grad_psi_norm2.getLowIndex() << grad_psi_norm2.getHighIndex() << std::endl;
-
-        ConstVariables<Dimension> grad_psi;
-        for ( int d = 0; d < Dimension; ++d )
-        {
-            dw_new->get ( grad_psi[d], grad_psi_label[d], 0, patch, Ghost::None, 0 );
-            dbg_out4 << grad_psi_label[d]->getName() << "\t range " << grad_psi[d].getLowIndex() << grad_psi[d].getHighIndex() << std::endl;
-        }
-
-        Variable a, a2;
-        dw_new->allocateAndPut ( a, a_label, 0, patch );
-        dw_new->allocateAndPut ( a2, a2_label, 0, patch );
-        dbg_out4 << "a \t range " << a.getLowIndex() << a.getHighIndex() << std::endl;
-        dbg_out4 << "a2 \t range " << a2.getLowIndex() << a2.getHighIndex() << std::endl;
-
-        Variables<b_size> b;
-        for ( int d = 0; d < b_size; ++d )
-        {
-            dw_new->allocateAndPut ( b[d], b_label[d], 0, patch );
-            dbg_out4 << b_label[d]->getName() << "\t range " << b[d].getLowIndex() << b[d].getHighIndex() << std::endl;
-        }
-
-        BlockRange range ( get_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        parallel_for ( range, [patch, &grad_psi, &grad_psi_norm2, &a, &a2, &b, this] ( int i, int j, int k )->void { time_advance_anisotropy_terms ( i, j, k, patch, get_views<Dimension> ( grad_psi ), get_view ( grad_psi_norm2 ), get_view ( a ), get_view ( a2 ), get_views<b_size> ( b ) ); } );
-    }
-
-    dbg_out2 << std::endl;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::task_time_advance_current_solution ( ProcessorGroup const * /*myworld*/, PatchSubset const * patches, MaterialSubset const * /*matls*/, DataWarehouse * dw_old, DataWarehouse * dw_new )
-{
-    dbg_out1 << "==== PhaseField::task_time_advance_current_solution ====" << std::endl;
-
-    for ( int p = 0; p < patches->size(); ++p )
-    {
-        const Patch * patch = patches->get ( p );
-        dbg_out2 << "== Patch: " << *patch << std::endl;
-
-        ConstVariable psi_old, u_old, grad_psi_norm2, a, a2;
-        dw_old->get ( psi_old, psi_label, 0, patch, GhostType, NumGhosts );
-        dw_old->get ( u_old, u_label, 0, patch, GhostType, NumGhosts );
-        dw_new->get ( grad_psi_norm2, grad_psi_norm2_label, 0, patch, GhostType, NumGhosts );
-        dw_new->get ( a, a_label, 0, patch, Ghost::None, 0 );
-        dw_new->get ( a2, a2_label, 0, patch, GhostType, NumGhosts );
-        dbg_out4 << "psi_old \t range " << psi_old.getLowIndex() << psi_old.getHighIndex() << std::endl;
-        dbg_out4 << "u_old \t range " << u_old.getLowIndex() << u_old.getHighIndex() << std::endl;
-        dbg_out4 << "grad_psi_norm2 \t range " << grad_psi_norm2.getLowIndex() << grad_psi_norm2.getHighIndex() << std::endl;
-        dbg_out4 << "a \t range " << a.getLowIndex() << a.getHighIndex() << std::endl;
-        dbg_out4 << "a2 \t range " << a2.getLowIndex() << a2.getHighIndex() << std::endl;
-
-        ConstVariables<Dimension> grad_psi;
-        ConstVariables<b_size> b;
-        for ( int d = 0; d < Dimension; ++d )
-        {
-            dw_new->get ( grad_psi[d], grad_psi_label[d], 0, patch, GhostType, NumGhosts );
-            dbg_out4 << grad_psi_label[d]->getName() << "\t range " << grad_psi[d].getLowIndex() << grad_psi[d].getHighIndex() << std::endl;
-        }
-        for ( int d = 0; d < b_size; ++d )
-        {
-            dw_new->get ( b[d], b_label[d], 0, patch, GhostType, NumGhosts );
-            dbg_out4 << b_label[d]->getName() << "\t range " << b[d].getLowIndex() << b[d].getHighIndex() << std::endl;
-        }
-
-        Variable psi_new, u_new;
-        dw_new->allocateAndPut ( psi_new, psi_label, 0, patch );
-        dw_new->allocateAndPut ( u_new, u_label, 0, patch );
-        dbg_out4 << "psi_new \t range " << psi_new.getLowIndex() << psi_new.getHighIndex() << std::endl;
-        dbg_out4 << "u_new \t range " << u_new.getLowIndex() << u_new.getHighIndex() << std::endl;
-
-        psi_new.copyPatch ( psi_old, psi_new.getLowIndex(), psi_new.getHighIndex() );
-        u_new.copyPatch ( u_old, u_new.getLowIndex(), u_new.getHighIndex() );
-
-        BlockRange range ( get_inner_range ( patch ) );
-
-        dbg_out3 << "= Iterating over inner range " << range << std::endl;
-        parallel_for ( range, [patch, &psi_old, &u_old, &grad_psi, &grad_psi_norm2, &a, &a2, &b, &psi_new, &u_new, this] ( int i, int j, int k )->void { time_advance_solution ( i, j, k, patch, psi_old, get_view ( u_old ), get_views<Dimension> ( grad_psi ), get_view ( grad_psi_norm2 ), get_view ( a ), get_view ( a2 ), get_views<b_size> ( b ), get_view ( psi_new ), get_view ( u_new ) ); } );
-
-        for ( auto face = start_face; face < end_face; face = Patch::nextFace ( face ) )
-            if ( patch->getBCType ( face ) != Patch::Neighbor )
-            {
-                BlockRange range ( get_face_range ( patch, face ) );
-
-                dbg_out3 << "= Iterating over " << face << " face range " << range << std::endl;
-                parallel_for ( range, [face, patch, &psi_old, &u_old, &grad_psi, &grad_psi_norm2, &a, &a2, &b, &psi_new, &u_new, this] ( int i, int j, int k )->void { time_advance_solution ( i, j, k, face, patch, ( psi_old ), get_view ( u_old ), get_views<Dimension> ( grad_psi ), get_view ( grad_psi_norm2 ), get_view ( a ), get_view ( a2 ), get_views<b_size> ( b ), get_view ( psi_new ), get_view ( u_new ) ); } );
-            }
-    }
-
-    dbg_out2 << std::endl;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::initialize_current_solution ( int i, int j, int k, Patch const * patch, View psi, View u )
-{
-    IntVector n ( i, j, k );
-    Point p = get_position ( patch, n );
-    double r2 = p.x() * p.x() + p.y() * p.y();
-    if ( Dimension > 2 )
-        r2 += p.z() * p.z();
-    double tmp = r2 - r0 * r0;
-    psi[n] = - tanh ( gamma_psi * tmp );
-    u[n] = -delta * ( 1. + tanh ( gamma_u * tmp ) ) / 2.;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::time_advance_grad_psi ( int i, int j, int k, const Patch * patch, ConstView psi, Views<Dimension> grad_psi, View grad_psi_norm2 )
-{
-    static_assert ( Dimension == 2 || Dimension == 3, "time_advance_grad_psi not implemented" );
-
-    double psi_x = dx ( i, j, k, patch, psi );
-    double psi_y = dy ( i, j, k, patch, psi );
-    grad_psi[0] ( i, j, k ) = psi_x;
-    grad_psi[1] ( i, j, k ) = psi_y;
-
-    if ( Dimension == 2 )
-    {
-        grad_psi_norm2 ( i, j, k ) = psi_x * psi_x + psi_y * psi_y;
-    }
-    if ( Dimension == 3 )
-    {
-        double psi_z = dz ( i, j, k, patch, psi );
-        grad_psi[2] ( i, j, k ) = psi_z;
-        grad_psi_norm2 ( i, j, k ) = psi_x * psi_x + psi_y * psi_y + psi_z * psi_z;
-    }
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::time_advance_grad_psi ( int i, int j, int k, Patch::FaceType face, Patch const * patch, ConstView psi, Views<Dimension> grad_psi, View grad_psi_norm2 )
-{
-    static_assert ( Dimension == 2 || Dimension == 3, "time_advance_grad_psi not implemented" );
-
-    IntVector l ( psi.getLowIndex() ), h ( psi.getHighIndex() );
-    Vector d ( patch->dCell() );
-
-    int im = ( i > l.x() ) ? i - 1 : i, ip = ( i < h.x() - 1 ) ? i + 1 : i;
-    int jm = ( j > l.y() ) ? j - 1 : j, jp = ( j < h.y() - 1 ) ? j + 1 : j;
-    double psi_x = ( psi ( ip, j, k ) - psi ( im, j, k ) ) / ( d.x() * ( ip - im ) );
-    double psi_y = ( psi ( i, jp, k ) - psi ( i, jm, k ) ) / ( d.y() * ( jp - jm ) );
-    grad_psi[0] ( i, j, k ) = psi_x;
-    grad_psi[1] ( i, j, k ) = psi_y;
-
-    if ( Dimension == 2 )
-    {
-        grad_psi_norm2 ( i, j, k ) = psi_x * psi_x + psi_y * psi_y;
-    }
-    if ( Dimension == 3 )
-    {
-        int km = ( k > l.z() ) ? k - 1 : k, kp = ( k < h.z() - 1 ) ? k + 1 : k;
-        double psi_z = ( psi ( i, j, kp ) - psi ( i, j, km ) ) / ( d.z() * ( kp - km ) );
-        grad_psi[2] ( i, j, k ) = psi_z;
-        grad_psi_norm2 ( i, j, k ) = psi_x * psi_x + psi_y * psi_y + psi_z * psi_z;
-    }
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::time_advance_anisotropy_terms ( int i, int j, int k, Patch const * patch, ConstViews<Dimension> grad_psi, ConstView grad_psi_norm2, View a, View a2, Views<b_size> b )
-{
-    double tmp = 1. + epsilon;
-    double n2 = grad_psi_norm2 ( i, j, k );
-    if ( n2 < tol )
-    {
-        a ( i, j, k ) = tmp;
-        a2 ( i, j, k ) = tmp * tmp;
-        for ( int d = 0; d < b_size; ++d )
-            b[d] ( i, j, k ) = 0.;
-    }
-    else
-    {
-        double psi_x = grad_psi[0] ( i, j, k );
-        double psi_y = grad_psi[1] ( i, j, k );
-        double n4 = n2 * n2;
-        double psi_x2= psi_x * psi_x;
-        double psi_y2= psi_y * psi_y;
-
-        double psi_z, psi_z2, tmp4;
-        if ( Dimension == 2 ) // Compile time if
-            tmp4 = 4. * ( psi_x * psi_x * psi_x * psi_x + psi_y * psi_y * psi_y * psi_y ) / n4;
-        if ( Dimension == 3 )   // Compile time if
-        {
-            psi_z = grad_psi[2] ( i, j, k );
-            psi_z2 = psi_z * psi_z;
-            tmp4 = 4. * ( psi_x2 * psi_x2 + psi_y2 * psi_y2 + psi_z2 * psi_z2 ) / n4;
-        }
-        double tmp = 1. + epsilon * ( tmp4 - 3. );
-        a ( i, j, k ) = tmp;
-        a2 ( i, j, k ) = tmp * tmp;
-        b[xy] ( i, j, k ) = 16. * epsilon * tmp * ( psi_x * psi_y )  * ( psi_x2 - psi_y2 ) / n4;
-        if ( Dimension == 3 )   // Compile time if
-        {
-            b[xz] ( i, j, k ) = 16. * epsilon * tmp * ( psi_x * psi_z ) * ( psi_x2 - psi_z2 ) / n4;
-            b[yz] ( i, j, k ) = 16. * epsilon * tmp * ( psi_y * psi_z ) * ( psi_y2 - psi_z2 ) / n4;
-        }
-    }
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::time_advance_solution ( int i, int j, int k, Patch const * patch, ConstView psi_old, ConstView u_old, ConstViews<Dimension> grad_psi, ConstView grad_psi_norm2, ConstView a, ConstView a2, ConstViews<b_size> b, View psi_new, View u_new )
-{
-    double source = 1. - psi_old ( i, j, k ) * psi_old ( i, j, k );
-    source *= ( psi_old ( i, j, k ) - lambda * u_old ( i, j, k ) * source );
-
-    double delta_psi = 0;
-    if ( Dimension == 2 )
-        delta_psi = delt * ( laplacian ( i, j, k, patch, psi_old ) * a2 ( i, j, k )
-                             + ( dx ( i, j, k, patch, a2 ) - dy ( i,j,k, patch, b[xy] ) ) * grad_psi[0] ( i, j, k )
-                             + ( dx ( i,j,k, patch, b[xy] ) + dy ( i, j, k, patch, a2 ) ) * grad_psi[1] ( i, j, k )
-                             + source ) / a ( i, j, k );
-    if ( Dimension == 3 )
-        delta_psi = delt * ( laplacian ( i, j, k, patch, psi_old ) * a2 ( i, j, k )
-                             + ( dx ( i, j, k, patch, a2 ) - dy ( i,j,k, patch, b[xy] ) - dz ( i,j,k, patch, b[xz] ) ) * grad_psi[0] ( i, j, k )
-                             + ( dx ( i,j,k, patch, b[xy] ) + dy ( i, j, k, patch, a2 ) - dz ( i,j,k, patch, b[yz] ) ) * grad_psi[1] ( i, j, k )
-                             + ( dx ( i,j,k, patch, b[xz] ) + dy ( i,j,k, patch, b[yz] ) + dz ( i, j, k, patch, a2 ) ) * grad_psi[1] ( i, j, k )
-                             + source ) / a ( i, j, k );
-
-    double delta_u = delt * laplacian ( i, j, k, patch, u_old ) * alpha + delta_psi / 2.;
-
-    psi_new ( i, j, k ) = psi_old ( i, j, k ) + delta_psi;
-    u_new ( i, j, k ) = u_old ( i, j, k ) + delta_u;
-}
-
-template<PF::VariableType VariableType, int NumGhosts, int Dimension>
-void PhaseField<VariableType, NumGhosts, Dimension>::time_advance_solution ( int i, int j, int k, Patch::FaceType face, Patch const * patch, ConstView psi_old, ConstView u_old, ConstViews<Dimension> grad_psi, ConstView grad_psi_norm2, ConstView a, ConstView a2, ConstViews<b_size> b, View psi_new, View u_new )
-{
-    psi_new ( i, j, k ) = psi_old ( i, j, k );
-    u_new ( i, j, k ) = u_old ( i, j, k );
-}
-
-}
-
-#endif
-
-
-
-
-
diff --git a/src/CCA/Components/PhaseField/Util/BlockRangeIO.h b/src/CCA/Components/PhaseField/Util/BlockRangeIO.h
new file mode 100644
index 00000000..d721ad73
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Util/BlockRangeIO.h
@@ -0,0 +1,62 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Util/BlockRangeIO.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Applications_Util_BlockRangeIO_h
+#define Packages_Uintah_CCA_Components_PhaseField_Applications_Util_BlockRangeIO_h
+
+#include <Core/Grid/Variables/BlockRange.hpp>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Insertion operator between BlockRange and std::ostream
+ *
+ * Used for debug purposes
+ *
+ * @param stream output stream reference
+ * @param range range to output
+ * @return output stream reference for concatenation
+ */
+inline std::ostream &
+operator << (
+    std::ostream & stream,
+    const BlockRange & range
+)
+{
+    return stream << "(" << range.begin ( 0 ) << "," <<  range.begin ( 1 ) << "," <<  range.begin ( 2 ) << ") - (" << range.end ( 0 ) << "," << range.end ( 1 ) << "," << range.end ( 2 ) << ")";
+}
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Applications_Util_BlockRangeIO_h
diff --git a/src/CCA/Components/PhaseField/Util/Definitions.h b/src/CCA/Components/PhaseField/Util/Definitions.h
new file mode 100644
index 00000000..aad1a53b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Util/Definitions.h
@@ -0,0 +1,764 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Util/Definitions.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Util_Definitions_h
+#define Packages_Uintah_CCA_Components_PhaseField_Util_Definitions_h
+
+#define _DOXYBDY(x)
+#define _DOXYARG(x)
+#define _DOXYIGN(x)
+
+#include <sci_defs/kokkos_defs.h>
+
+#include <Core/Grid/Patch.h>
+#include <Core/Grid/Ghost.h>
+
+#define TODO { ASSERTFAIL ( "TO BE IMPLEMENTED" ); }
+#define VIRT { ASSERTFAIL ( "VIRTUAL METHOD" ); }
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Variable Type
+ *
+ * Enumeration for different types of variable representation
+ */
+enum VarType : size_t
+{
+    CC, ///< Cell Centered Variable
+    NC, ///< Node Centered Variable
+    PP  ///< PerPatch Variable ( used for Problems )
+};
+
+/**
+ * @brief Dimension Type
+ *
+ * Enumeration for different problem dimensions
+ */
+enum DimType : size_t
+{
+    D1 = 1, ///< 1D Problem
+    D2 = 2, ///< 2D Problem
+    D3 = 3  ///< 3D Problem
+};
+
+/**
+ * @brief Stencil Type
+ *
+ * Enumeration for different finite-difference stencils
+ */
+enum StnType : size_t
+{
+    P3, ///< 3 Point stencil for 1D finite-differences
+    P5, ///< 5 Point stencil for 2D finite-differences
+    P7, ///< 7 Point stencil for 3D finite-differences
+    EU  ///< 5 Point stencil for 2D finite-differences as used in campfire
+};
+
+/**
+ * @brief Direction Type
+ *
+ * Enumeration for coordinate directions
+ */
+enum DirType : size_t
+{
+    X = 0, ///< x Direction
+    Y = 1, ///< y Direction
+    Z = 2  ///< z Direction
+};
+
+/**
+ * @brief Interpolation Type
+ *
+ * Enumeration for different order of interpolations
+ */
+enum FCIType : size_t
+{
+    I0 = 1, ///< Piece-wise Interpolation (0th order: 1 point stencil
+    I1 = 2  ///< Linear Interpolation in each direction (1st order: 2 DIM points stencil)
+};
+
+/// Constant to be used as template parameter to enable adptive mesh refinement
+static constexpr bool AMR = true;
+
+/**
+ * @brief Boundary Conditions
+ *
+ * Enumeration for different types of boundary conditions.
+ * @remark They are intended to be used as masks together with FC
+ */
+enum class BC : size_t
+{
+    Unknown             = 0x00000000, ///< Unknown condition
+    None                = 0x00000100, ///< No condition imposed to the solution \f$ u:\Omega\to\mathbb K^N \f$ over the boundary \f$ \partial\Omega \f$
+    Dirichlet           = 0x00000200, ///< Given \f$ a\in\mathbb R \f$ we impose \f$ u = a, u\in\partial\Omega \f$.
+    Neumann             = 0x00000300, ///< Given \f$ a\in\mathbb R \f$ we impose \f$ \nabla u \cdot \mathbb n = a, u\in\partial\Omega \f$.
+    Symmetry            = 0x00000400, ///< Ghost values for \f$ u \f$ are taken to be equal to the corresponding value within the domain \f$ \Omega \f$
+    FineCoarseInterface = 0x00000500  ///< The boundary is an artificial one over a fine level \f$\Omega_k\f$ and continuity has to be imposed across it
+};
+
+/**
+ * @brief Fine/Coarse Interface Conditions
+ *
+ * Enumeration for different types of fine/coarse interface conditions.
+ * @remark They are intended to be used as masks together with BC
+ *
+ * Multiple interpolation methods are provided; the following figures show the
+ * differences between them in terms of cell used (solid blue) on the fine
+ * (diamonds) and coarse (square) levels when computing the value on a ghost
+ * cell (red) required by the approximation of the laplacian in 2D with a
+ * 5-points stencil across different geometries of fine-coarse interfaces
+ *
+ * @image latex fc0.eps "FC0"
+ * @image html  fc0.png "FC0"
+ * @image latex fc1.eps "FC1"
+ * @image html  fc1.png "FC1"
+ * @image latex fcsimple.eps "FCSimple"
+ * @image html  fcsimple.png "FCSimple"
+ * @image latex fclinear.eps "FCLinear"
+ * @image html  fclinear.png "FCLinear"
+ * @image latex fcbilinear.eps "FCBilinear"
+ * @image html  fcbilinear.png "FCBilinear"
+ */
+enum class FC : size_t
+{
+    None        = 0x00000000,       ///< Continuity across interfaces is not enforced
+    FC0         = I0 * 0x00100000,  ///< Piece-wise interpolation is used to compute the value on fine levels ghosts from the old solution at coarser levels @remark to be used with HypreFACSolver @remark should be used with NC variables since no interpolation is required
+    FC1         = I1 * 0x00100000,  ///< Linear interpolation in each direction is used to compute the value on fine levels ghosts from the old solution at coarser levels @remark to be used with HypreFACSolver @remark should be used with CC variables since interpolation reduces the approximation error of solution derivatives
+    FCSimple    = FC0 + 0x00020000, ///< 2 elements interpolation for 2D problems and CC variables
+    FCLinear    = FC0 + 0x00030000, ///< 3 elements extrapolation for 2D problems and CC variables
+    FCBilinear  = FC0 + 0x00040000  ///< 4 elements interpolation for 2D problems and CC variables
+};
+
+/**
+ * @brief Type for packing BC, FC, and Patch::Face together
+ *
+ * BCF are used to identify different implementations over patches boundaries
+ * which may depend on the type of boundary conditions BC, the type of
+ * fine/coarse interface conditions FC and on the actual face on which the
+ * implementation is meant to work
+ */
+using BCF = size_t;
+
+/**
+ * @brief VarType Helper
+ *
+ * Helper struct to get expressions dependent on the given type of variable
+ * representation
+ * @tparam VAR type of variable representation
+ */
+template<VarType VAR> struct get_var
+_DOXYBDY (
+    /// GhostType to be used with given VarType VAR
+    static constexpr Ghost::GhostType ghost_type;
+);
+
+/**
+ * @brief VarType Helper (CC Implementation)
+ *
+ * CC Implementation of the helper struct to get expressions dependent on the
+ * given type of variable representation
+ * @implements get_var < VAR >
+ */
+template<>
+struct get_var<CC>
+{
+    /// GhostType to be used with VAR = CC
+    static constexpr Ghost::GhostType ghost_type = Ghost::AroundCells;
+};
+
+/**
+ * @brief VarType Helper (NC Implementation)
+ *
+ * NC Implementation of the helper struct to get expressions dependent on the
+ * given type of variable representation
+ * @implements get_var < VAR >
+ */
+template<>
+struct get_var<NC>
+{
+    /// GhostType to be used with VAR = NC
+    static constexpr Ghost::GhostType ghost_type = Ghost::AroundNodes;
+};
+
+/**
+ * @brief DimType Helper
+ *
+ * Helper struct to get expressions dependent on the given problem dimension
+ * @tparam DIM problem dimension
+ */
+template <DimType DIM>
+struct get_dim
+{
+    /// FaceType to be used as first value when forward-iterating over faces
+    static constexpr Patch::FaceType face_start = Patch::xminus;
+
+    /// FaceType to be used as lest value when forward-iterating over faces
+    static constexpr Patch::FaceType face_end = Patch::FaceType ( 2 * DIM );
+
+    /// Highest valid direction for the given DIM
+    static constexpr DirType highest_dir = ( DirType ) ( DIM - 1 );
+
+    /// Unit vector for the given DIM
+    /// @return IntVector with relevant entries set to 1 (entries with index greater than DIM are set to 0)
+    static IntVector unit_vector()
+    {
+        return IntVector ( 1, ( DIM > D1 ) ? 1 : 0, ( DIM > D2 ) ? 1 : 0 );
+    }
+
+    /// Scalar vector in the given DIM
+    /// @tparam V scalar value
+    /// @return IntVector with relevant entries set to V (entries with index greater than DIM are set to 0)
+    template<int V>
+    static IntVector scalar_vector()
+    {
+        return IntVector ( V, ( DIM > D1 ) ? V : 0, ( DIM > D2 ) ? V : 0 );
+    }
+};
+
+/**
+ * @brief StnType Helper
+ *
+ * Helper struct to get expressions dependent on the given finite-differences
+ * stencil
+ * @tparam STN finite-differences stencil
+ */
+template<StnType STN> struct get_stn
+_DOXYBDY (
+    /// DimType corresponding to the given stencil
+    static constexpr DimType dim;
+
+    /// ghosts required by the  given stencil
+    static constexpr int ghosts;
+
+    /// type of the stencil to be used as template parameter for Variable
+    template<typename T> using type;
+            );
+
+/**
+ * @brief StnType Helper (P3 implementation)
+ *
+ * P3 Implementation of the helper struct to get expressions dependent on the
+ * given finite-differences stencil
+ * @implements get_stn < STN >
+ */
+template<>
+struct get_stn<P3>
+{
+    /// DimType to be used with STN = P3
+    static constexpr DimType dim = D1;
+
+    /// number of ghosts to be used with STN = P3
+    static constexpr int ghosts = 1;
+};
+
+/**
+ * @brief StnType Helper (P5 implementation)
+ *
+ * P5 Implementation of the helper struct to get expressions dependent on the
+ * given finite-differences stencil
+ * @implements get_stn < STN >
+ */
+template<>
+struct get_stn<P5>
+{
+    /// DimType to be used with STN = P5
+    static constexpr DimType dim = D2;
+
+    /// number of ghosts to be used with STN = P5
+    static constexpr int ghosts = 1;
+};
+
+/**
+ * @brief StnType Helper (P7 implementation)
+ *
+ * P7 Implementation of the helper struct to get expressions dependent on the
+ * given finite-differences stencil
+ * @implements get_stn < STN >
+ */
+template<>
+struct get_stn<P7>
+{
+    /// DimType to be used with STN = P7
+    static constexpr DimType dim = D3;
+
+    /// number of ghosts to be used with STN = P7
+    static constexpr int ghosts = 1;
+};
+
+/**
+ * @brief StnType Helper (EU implementation)
+ *
+ * EU Implementation of the helper struct to get expressions dependent on the
+ * given finite-differences stencil
+ * @implements get_stn < STN >
+ */
+template<>
+struct get_stn<EU>
+{
+    /// DimType to be used with STN = EU
+    static constexpr DimType dim = D2;
+
+    /// number of ghosts to be used with STN = EU
+    static constexpr int ghosts = 1;
+};
+
+/**
+ * @brief DirType Helper
+ *
+ * Helper struct to get expressions dependent on the given coordinate direction
+ */
+template <DirType DIR>
+struct get_dir
+{
+    /// DirType corresponding to the coordinate direction whose index precedes DIR
+    static constexpr DirType lower = ( DirType ) ( DIR - 1 );
+
+    /// DirType corresponding to the coordinate direction whose index follows DIR
+    static constexpr DirType higher = ( DirType ) ( DIR + 1 );
+
+    /// Patch::FaceType orthogonal to DIR (lower face)
+    static constexpr Patch::FaceType minus_face = ( Patch::FaceType ) ( 2 * DIR );
+
+    /// Patch::FaceType orthogonal to DIR (upper face)
+    static constexpr Patch::FaceType plus_face = ( Patch::FaceType ) ( 2 * DIR + 1 );
+};
+
+template <DirType DIR> constexpr Patch::FaceType get_dir<DIR>::minus_face;
+template <DirType DIR> constexpr Patch::FaceType get_dir<DIR>::plus_face;
+
+/**
+ * @brief FCIType Helper
+ *
+ * Helper struct to get expressions dependent on the given order of
+ * interpolation
+ * @tparam FCI order of interpolation
+ */
+template <FCIType FCI> struct get_fci
+_DOXYBDY (
+    /// number of cells/nodes required for interpolation
+    static constexpr int elems;
+);
+
+/**
+ * @brief FCIType Helper (I0 Implementation)
+ *
+ * I0 Implementation of the helper struct to get expressions dependent on the
+ * given order of interpolation
+ * @implements get_fci < FCI >
+ */
+template <>
+struct get_fci<I0>
+{
+    /// number of cells/nodes required for interpolation
+    static constexpr int elems = 1;
+};
+
+/**
+ * @brief FCIType Helper (I1 Implementation)
+ *
+ * I1 Implementation of the helper struct to get expressions dependent on the
+ * given order of interpolation
+ * @implements get_fci < FCI >
+ */
+template <>
+struct get_fci<I1>
+{
+    /// number of cells/nodes required for interpolation/restriction
+    static constexpr int elems = 2;
+};
+
+/**
+ * @brief Patch::FaceType Helper
+ *
+ * Helper struct to get expressions dependent on the given face
+ * @tparam Patch::FaceType face
+ */
+template <Patch::FaceType F>
+struct get_face
+{
+    /// face direction
+    static constexpr DirType dir = ( DirType ) ( F / 2 );
+
+    /// face sign (int)
+    static constexpr int sgn = 2 * ( F % 2 ) - 1;
+
+    /// face sign (double)
+    static constexpr double dsgn = static_cast<double> ( sgn );
+};
+
+/**
+ * @brief BC Helper
+ *
+ * Helper struct to get expressions dependent on the given type of boundary
+ * conditions
+ *
+ * @tparam B type of boundary conditions
+ */
+template<BC B> struct get_bc
+_DOXYBDY (
+    /// @brief type of bc rhs for the given type of boundary conditions
+    /// Is the type used for handling the rhs in the boundary condition equation
+    /// @tparam Field field type of the variable on which the condition is applied
+    template<typename Filed> using value_type;
+            );
+
+/**
+ * @brief BC Helper (Dirichlet implementation)
+ *
+ * Dirichlet implementation of the helper struct to get expressions dependent on
+ * the given type of boundary conditions
+ * @implements get_bc < BC >
+ */
+template<>
+struct get_bc<BC::Dirichlet>
+{
+    /// @brief type of bc rhs for Dirichlet boundary conditions
+    /// for Dirichlet condition on a scalar variable (T=double, const double)
+    /// value_type = double; otherwise value_type = void * (undefined)
+    /// @tparam Field field type of the variable on which the condition is applied
+    template<typename Field> using value_type = typename Field::value_type;
+};
+
+/**
+ * @brief BC Helper (Neumann implementation)
+ *
+ * Neumann implementation of the helper struct to get expressions dependent on
+ * the given type of boundary conditions
+ * @implements get_bc < BC >
+ */
+template<>
+struct get_bc<BC::Neumann>
+{
+    /// @brief type of bc rhs for Neumann boundary conditions
+    /// for Neumann condition on a scalar variable (T=double, const double)
+    /// value_type = double; otherwise value_type = void * (undefined)
+    /// @tparam Field field type of the variable on which the condition is applied
+    template<typename Field> using value_type = typename Field::value_type;
+};
+
+namespace detail
+{
+template <typename Field> class view;
+}
+
+template<>
+struct get_bc<BC::FineCoarseInterface>
+{
+    /// @brief type of bc rhs for FineCoarseInterface boundary conditions
+    /// for FineCoarseInterface condition on a scalar variable (T=double,
+    /// const double) value_type = V *; otherwise value_type = void *
+    /// (undefined)
+    /// @tparam Field field type of the variable on which the condition is applied
+    template<typename Field> using value_type = detail::view<Field> * ;
+};
+
+/**
+ * @brief FC Helper
+ *
+ * Helper struct to get expressions dependent on the given type of fine/coarse
+ * interface conditions
+ *
+ * @tparam F type of fine/coarse interface conditions
+ */
+template < FC F > struct get_fc
+{
+    /// order of interpolation
+    static constexpr FCIType fci = ( FCIType ) ( ( size_t ) F / 0x00100000 );
+};
+
+/**
+ * @brief BCF Helper
+ *
+ * Helper struct to get expressions dependent on the given BC, FC, and
+ * Patch::Face pack
+ *
+ * @tparam P BC, FC, and Patch::Face pack
+ */
+template < BCF P >
+struct get_bcf
+{
+    /// type of boundary conditions
+    static constexpr BC bc = ( BC ) ( P & 0x0000FF00 );
+
+    /// type of fine/coarse interface conditions
+    static constexpr FC c2f = ( FC ) ( P & 0x00FF0000 );
+
+    /// patch face
+    static constexpr Patch::FaceType face = ( Patch::FaceType ) ( P & 0x000000FF );
+};
+
+/**
+ * @brief VarType to std::string
+ *
+ * Converts the type of variable representation to the corresponding string as
+ * used by factory constructors
+ */
+inline std::string
+var_to_str (
+    VarType var
+)
+{
+    switch ( var )
+    {
+    case CC:
+        return "CC";
+        break;
+    case NC:
+        return "NC";
+        break;
+    default:
+        return "Unknown";
+    }
+}
+
+/**
+ * @brief DimType to std::string
+ *
+ * Converts the problem dimension to the corresponding string as used by factory
+ * constructors
+ */
+inline std::string
+dim_to_str (
+    DimType dim
+)
+{
+    switch ( dim )
+    {
+    case D1:
+        return "D1";
+    case D2:
+        return "D2";
+    case D3:
+        return "D3";
+    default:
+        return "Unknown";
+    }
+}
+
+/**
+ * @brief StnType to std::string
+ *
+ * Converts the finite-difference stencil to the corresponding string as used by
+ * factory constructors
+ */
+inline std::string
+stn_to_str (
+    StnType stn
+)
+{
+    switch ( stn )
+    {
+    case P3:
+        return "P3";
+    case P5:
+        return "P5";
+    case P7:
+        return "P7";
+    case EU:
+        return "EU";
+    default:
+        return "Unknown";
+
+    }
+}
+
+/**
+ * @brief DirType to std::string
+ *
+ * Converts the type of variable representation to the corresponding string as
+ * used by factory constructors
+ */
+inline std::string
+dir_to_str (
+    DirType dir
+)
+{
+    switch ( dir )
+    {
+    case X:
+        return "X";
+    case Y:
+        return "Y";
+    case Z:
+        return "Z";
+    default:
+        return "Unknown";
+    }
+}
+
+/**
+ * @brief BC to std::string
+ *
+ * Converts the type of boundary conditions to the corresponding string as
+ * used by factory constructors
+ */
+inline std::string
+bc_to_str (
+    BC value
+)
+{
+    switch ( value )
+    {
+    case BC::None:
+        return "None";
+    case BC::Dirichlet:
+        return "Dirichlet";
+    case BC::Neumann:
+        return "Neumann";
+    case BC::Symmetry:
+        return "Symmetry";
+    case BC::FineCoarseInterface:
+        return "FineCoarseInterface";
+    default:
+        return "Unknown";
+    }
+}
+
+/**
+ * @brief FC to std::string
+ *
+ * Converts the type of fine/coarse interface conditions to the corresponding
+ * string as used by factory constructors
+ */
+inline std::string
+fc_to_str (
+    FC value
+)
+{
+    switch ( value )
+    {
+    case FC::None:
+        return "None";
+    case FC::FC0:
+        return "FC0";
+    case FC::FCSimple:
+        return "FCSimple";
+    case FC::FCLinear:
+        return "FCLinear";
+    case FC::FCBilinear:
+        return "FCBilinear";
+    case FC::FC1:
+        return "FC1";
+    default:
+        return "Unknown";
+    }
+}
+
+/**
+ * @brief std::string to BC
+ *
+ * Converts the string as used in input files to the corresponding type of
+ * boundary conditions
+ */
+inline BC
+str_to_bc (
+    const std::string & value
+)
+{
+    if ( value == "Dirichlet" ) return BC::Dirichlet;
+    if ( value == "Neumann" ) return BC::Neumann;
+    return BC::Unknown;
+}
+
+/**
+ * @brief std::string to FC
+ *
+ * Converts the string as used in input files to the corresponding type of
+ * fine/coarse interface condition
+ */
+inline FC
+str_to_fc (
+    const std::string & value
+)
+{
+    if ( value == "FC0" ) return FC::FC0;
+    if ( value == "FCSimple" ) return FC::FCSimple;
+    if ( value == "FCLinear" ) return FC::FCLinear;
+    if ( value == "FCBilinear" ) return FC::FCBilinear;
+    if ( value == "FC1" ) return FC::FC1;
+    return FC::None;
+}
+
+/**
+ * @brief Check FC masks
+ *
+ * Evaluate if a given FC matches a required type (or category) of fine/coarse
+ * interface conditions
+ * @param a TS to check
+ * @param b TS required type or category of fine/coarse interface conditions
+ * @return check result
+ */
+constexpr bool
+operator & (
+    FC a,
+    FC b
+)
+{
+    return ( size_t ) a & size_t ( b );
+}
+
+template<typename A>
+constexpr BCF
+operator | (
+    A a,
+    FC b
+)
+{
+    return ( BCF ) a | ( BCF ) ( b );
+}
+
+template<typename A>
+constexpr BCF
+operator | (
+    A a,
+    BC b
+)
+{
+    return ( BCF ) a | ( BCF ) ( b );
+}
+
+template<typename A>
+constexpr BCF
+operator | (
+    A a,
+    Patch::FaceType b
+)
+{
+    return ( BCF ) a | ( BCF ) ( b );
+}
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Util_Definitions_h
diff --git a/src/CCA/Components/PhaseField/Util/Expressions.h b/src/CCA/Components/PhaseField/Util/Expressions.h
new file mode 100644
index 00000000..484350e3
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Util/Expressions.h
@@ -0,0 +1,165 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Util/Expressions.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Util_Expressions_h
+#define Packages_Uintah_CCA_Components_PhaseField_Util_Expressions_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+#if __cplusplus < 201402L
+/**
+ * @brief C++11 implementation of C++14 integer sequence
+ *
+ * The class template integer_sequence represents a compile-time sequence of
+ * integers. When used as an argument to a function template, the parameter
+ * pack I can be deduced and used in pack expansion.
+ *
+ * @tparam T an integer type to use for the elements of the sequence
+ * @tparam I a non-type parameter pack representing the sequence
+ */
+template<typename T, T... I>
+struct integer_sequence
+{
+    typedef T value_type;
+
+    /**
+     * @brief Returns the number of elements in I
+     *
+     * Returns the number of elements in Ints. Equivalent to sizeof...(I)
+     *
+     * @return The number of elements in I
+     */
+    static constexpr size_t size() noexcept
+    {
+        return sizeof... ( I );
+    }
+};
+
+/**
+ * A helper alias template index_sequence is defined for the common case where T
+ * is std::size_t.
+ *
+ * @tparam I a non-type parameter pack representing the sequence
+ */
+template<size_t... I>
+using index_sequence = integer_sequence<size_t, I...>;
+
+/**
+ * A helper alias template make_integer_sequence is defined to simplify
+ * creation of integer_sequence types with 0, 1, 2, ..., N-1 as I.
+ *
+ * @tparam T an integer type to use for the elements of the sequence
+ * @tparam N size of the sequence to create
+ * @tparam I a non-type parameter pack representing the sequence
+ */
+template<typename T, size_t N, T... I>
+struct make_integer_sequence _DOXYIGN ( : make_integer_sequence < T, N - 1, N - 1, I... > {} );
+
+/**
+ * A helper alias template make_integer_sequence is defined to simplify
+ * creation of integer_sequence types with 0, 1, 2, ..., N-1 as I.
+ * (N=0 implementation)
+ *
+ * @tparam T an integer type to use for the elements of the sequence
+ * @tparam I a non-type parameter pack representing the sequence
+ */
+template<typename T, T... I>
+struct make_integer_sequence<T, 0, I...> : integer_sequence<T, I...> {};
+
+/**
+ * A helper alias template make_index_sequence is defined to simplify
+ * creation of index_sequence types with 0, 1, 2, ..., N-1 as I.
+ * @tparam N size of the sequence to create
+ */
+template<size_t N>
+using make_index_sequence = make_integer_sequence<size_t, N>;
+
+/**
+ * A helper alias template index_sequence_for is defined to convert any type
+ * parameter pack into an index sequence of the same length
+ *
+ * @tparam T a type parameter pack for witch to create the sequence
+ */
+template<typename... T>
+using index_sequence_for = make_index_sequence<sizeof... ( T ) >;
+#else
+using std::index_sequence;
+using std::make_integer_sequence;
+using std::make_index_sequence;
+using std::index_sequence_for;
+#endif
+
+/**
+ * @brief Compile time factorial
+ *
+ * expression template for computing the factorial \f$ N! \f$ at compile time
+ * @tparam N integer argument \f$ N \f$
+ */
+template<size_t N>
+struct factorial
+{
+    /// value of \f$ N! \f$
+    static constexpr size_t value = N * factorial < N - 1 >::value;
+};
+
+/**
+ * @brief Compile time factorial (O case)
+ *
+ * expression template for computing the factorial \f$ N! \f$ at compile time
+ * for \f$ N=0 \f$
+ */
+template<>
+struct factorial<0>
+{
+    /// value of \f$ 0! \f$
+    static constexpr size_t value = 1;
+};
+
+/**
+ * @brief Compile time combinations
+ *
+ * Expression template for computing the binomial coefficient \f$ N\choose R \f$
+ * at compile time
+ * @tparam N set size
+ * @tparam R combinations size
+ */
+template<size_t N, size_t R>
+struct combinations
+{
+    /// value of \f$ N\choose R \f$
+    static constexpr size_t value = factorial<N>::value / ( factorial<R>::value * factorial < N - R >::value );
+};
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Util_Expressions_h
diff --git a/src/CCA/Components/PhaseField/PhaseField.cc b/src/CCA/Components/PhaseField/Views/FDView.h
similarity index 60%
rename from src/CCA/Components/PhaseField/PhaseField.cc
rename to src/CCA/Components/PhaseField/Views/FDView.h
index b2bc36a8..297cdfc1 100644
--- a/src/CCA/Components/PhaseField/PhaseField.cc
+++ b/src/CCA/Components/PhaseField/Views/FDView.h
@@ -22,20 +22,31 @@
  * IN THE SOFTWARE.
  */
 
-#include <CCA/Components/PhaseField/PhaseField.h>
-#include <CCA/Components/PhaseField/AMRPhaseField.h>
+/**
+ * @file CCA/Components/PhaseField/Views/FDView.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Views_FDView_h
+#define Packages_Uintah_CCA_Components_PhaseField_Views_FDView_h
+
+#include <CCA/Components/PhaseField/Views/detail/fd_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Public wrapper of grid variables that implement finite-differences
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ */
+template <typename Field, StnType STN> using FDView = detail::fd_view<Field, STN>;
 
-using namespace Uintah;
+} // namespace PhaseField
+} // namespace Uintah
 
-template class PhaseField <PF::NodeCentered,1,2>;
-template class PhaseField <PF::CellCentered,1,2>;
-template class PhaseField <PF::NodeCentered,1,3>;
-template class PhaseField <PF::CellCentered,1,3>;
-template class AMRPhaseField <PF::NodeCentered,1,2>;
-template class AMRPhaseField <PF::CellCentered,1,2>;
-template class AMRPhaseField <PF::NodeCentered,1,3>;
-template class AMRPhaseField <PF::CellCentered,1,3>;
-template class AMRPhaseFieldTest <PF::NodeCentered,1,2>;
-template class AMRPhaseFieldTest <PF::CellCentered,1,2>;
-template class AMRPhaseFieldTest <PF::NodeCentered,1,3>;
-template class AMRPhaseFieldTest <PF::CellCentered,1,3>;
+#endif // Packages_Uintah_CCA_Components_PhaseField_Views_FDView_h
diff --git a/src/CCA/Components/PhaseField/Views/View.h b/src/CCA/Components/PhaseField/Views/View.h
new file mode 100644
index 00000000..b40ab582
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Views/View.h
@@ -0,0 +1,53 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Views/View.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Views_View_h
+#define Packages_Uintah_CCA_Components_PhaseField_Views_View_h
+
+#include <CCA/Components/PhaseField/Views/detail/view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+
+/**
+ * @brief Public wrapper for accessing grid variables
+ *
+ * @remark constant views must use fields with const value type
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ */
+template <typename Field> using View = detail::view<Field>;
+
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Views_View_h
diff --git a/src/CCA/Components/PhaseField/Views/detail/basic_fd_view.h b/src/CCA/Components/PhaseField/Views/detail/basic_fd_view.h
new file mode 100644
index 00000000..b14b3608
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Views/detail/basic_fd_view.h
@@ -0,0 +1,216 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Views/detail/basic_fd_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Views_detail_basic_fd_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_Views_detail_basic_fd_view_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/Views/detail/view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Abstract wrapper of grid variables for basic finite-difference operations
+ *
+ * detail implementation of view (variable wrapping) which include also
+ * finite difference approximation of basic differential operations (first and
+ * second oreder derivatives)
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ */
+template<typename Field, StnType STN> class basic_fd_view;
+
+/**
+ * @brief Abstract class for basic finite-difference operations on variables
+ * (ScalarField implementation)
+ *
+ * detail implementation of view (variable wrapping) which include also
+ * finite difference approximation on basic differential operations (first and
+ * second oreder derivatives)
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ */
+template<typename T, StnType STN>
+class basic_fd_view < ScalarField<T>, STN >
+    : virtual public view < ScalarField<T> >
+{
+public: // STATIC MEMBERS
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = true;
+
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+public: // DESTRUCTOR
+
+    /// Default destructor
+    virtual ~basic_fd_view() = default;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void set ( DataWarehouse * dw, const Patch * patch, bool use_ghosts = use_ghosts_dflt ) = 0;
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void set ( DataWarehouse * dw, const Level * level, const IntVector & low, const IntVector & high, bool use_ghosts = use_ghosts_dflt ) = 0;
+
+public: // BASIC FD VIEW METHODS
+
+    /**
+     * @brief Get base view
+     *
+     * @return non const pointer to base view implementation
+     */
+    virtual view<Field> * get_view() = 0;
+
+    /**
+     * @brief Get base view
+     *
+     * @return const pointer to base view implementation
+     */
+    virtual const view<Field> * get_view() const = 0;
+
+    /**
+     * @brief Partial x derivative
+     *
+     * First order derivative along x at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V dx ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Partial y derivative
+     *
+     * First order derivative along y at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V dy ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Partial z derivative
+     *
+     * First order derivative along z at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V dz ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Partial x second order derivative
+     *
+     * Second order derivative along x at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V dxx ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Partial y second order derivative
+     *
+     * Second order derivative along y at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V dyy ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Partial z second order derivative
+     *
+     * Second order derivative along z at index id
+     *
+     * @param id index where to evaluate the finite-difference
+     * @return approximated value at id
+     */
+    virtual V dzz ( const IntVector & id ) const = 0;
+
+}; // class basic_fd_view
+
+/**
+ * @brief Abstract class for basic finite-difference operations on variables
+ * (VectorField implementation)
+ *
+ * detail implementation of view (variable wrapping) which include also
+ * finite difference approximation on basic differential operations (first and
+ * second order derivatives)
+ *
+ * @tparam T type of each component of the field at each point
+ * @tparam N number of components
+ * @tparam STN finite-difference stencil
+ */
+template <typename T, size_t N, StnType STN>
+class basic_fd_view < VectorField<T, N>, STN >
+    : virtual public view_array < basic_fd_view < ScalarField<T>, STN >, ScalarField<T>, N >
+{
+public: // DESTRUCTOR
+
+    /// Default destructor
+    virtual ~basic_fd_view() = default;
+
+}; // class basic_fd_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Views_detail_basic_fd_view_h
diff --git a/src/CCA/Components/PhaseField/Views/detail/fd_view.h b/src/CCA/Components/PhaseField/Views/detail/fd_view.h
new file mode 100644
index 00000000..f2b6ca8e
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Views/detail/fd_view.h
@@ -0,0 +1,130 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Views/detail/fd_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Views_detail_fd_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_Views_detail_fd_view_h
+
+#include <CCA/Components/PhaseField/Views/detail/basic_fd_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Abstract wrapper of grid variables for complex differential operations
+ *
+ * Adds to view the possibility to compute finite-difference approximation of
+ * of complex differential operations (gradient and laplacian) at internal
+ * internal cells/points
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ * @tparam STN finite-difference stencil
+ */
+template<typename Field, StnType STN> class fd_view;
+
+/**
+ * @brief Abstract wrapper of grid variables for complex differential operations
+ * (ScalarField implementation)
+ *
+ * Adds to view the possibility to compute finite-difference approximation of
+ * of complex differential operations (gradient and laplacian) at internal
+ * internal cells/points
+ *
+ * @tparam T type of the field value at each point
+ * @tparam STN finite-difference stencil
+ */
+template<typename T, StnType STN>
+class fd_view < ScalarField<T>, STN >
+    : virtual public basic_fd_view < ScalarField<T>, STN >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+public: // DESTRUCTOR
+
+    /// Default destructor
+    virtual ~fd_view() = default;
+
+public: // FD VIEW METHODS
+
+    /**
+     * @brief Get gradient value at position
+     *
+     * @param id position index
+     * @return gradient value at id
+     */
+    virtual std::vector<V> gradient ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Get laplacian at position
+     *
+     * @param id position index
+     * @return laplacian value at id
+     */
+    virtual V laplacian ( const IntVector & id ) const = 0;
+
+};
+
+/**
+ * @brief Abstract wrapper of grid variables for complex differential operations
+ * (VectorField implementation)
+ *
+ * Adds to view the possibility to compute finite-difference approximation of
+ * of complex differential operations (gradient and laplacian) at internal
+ * internal cells/points
+ *
+ * @tparam T type of each component of the field at each point
+ * @tparam N number of components
+ * @tparam STN finite-difference stencil
+ */
+template <typename T, size_t N, StnType STN >
+class fd_view < VectorField<T, N>, STN >
+    : virtual public view_array < fd_view < ScalarField<T>, STN >, ScalarField<T>, N >
+{
+public: // DESTRUCTOR
+
+    /// Default destructor
+    virtual ~fd_view () = default;
+
+}; // class fd_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Views_detail_fd_view_h
diff --git a/src/CCA/Components/PhaseField/Views/detail/piecewise_view.h b/src/CCA/Components/PhaseField/Views/detail/piecewise_view.h
new file mode 100644
index 00000000..d4ea2586
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Views/detail/piecewise_view.h
@@ -0,0 +1,213 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Views/detail/piecewise_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_detail_piecewise_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_detail_piecewise_view_h
+
+#include <CCA/Components/PhaseField/Views/detail/view.h>
+#include <CCA/Components/PhaseField/Exceptions/IntVectorOutOfBounds.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Container for collecting multiple views as a unique composite view
+ *
+ * It is used as abase class for views that are defined across multiple sub-problems
+ * (i.e. bcs views and amr coarser and finer views)
+ *
+ * @remark no instantiation must be performed here
+ *
+ * @tparam Field type of Field (should be only ScalarField)
+ */
+template<typename Field> class piecewise_view;
+
+/**
+ * @brief Container for collecting multiple views as a unique composite view
+ * (ScalarField implementation)
+ *
+ * It is used as abase class for views that are defined across multiple sub-problems
+ * (i.e. bcs views and amr coarser and finer views)
+ *
+ * @remark no instantiation must be performed here
+ *
+ * @tparam T type of the field value at each point
+ */
+template<typename T>
+class piecewise_view< ScalarField<T> >
+    : virtual public view< ScalarField<T> >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+protected: // MEMBERS
+
+    /// Container for each sub views
+    std::list < view<Field> * > m_views;
+
+private: // METHODS
+
+    /**
+     * @brief Get view reference
+     *
+     * Get the view whose support includes id
+     *
+     * @param id position index
+     * @return required view
+     * @throw IntVectorOutOfBounds if no view is found
+     */
+    view<Field> &
+    get_view (
+        const IntVector & id
+    )
+    {
+        for ( auto * view : m_views )
+            if ( view->is_defined_at ( id ) )
+                return *view;
+        SCI_THROW ( IntVectorOutOfBounds ( id,  __FILE__, __LINE__ ) );
+    }
+
+    /**
+     * @brief Get view const reference
+     *
+     * Get the view whose support includes id
+     *
+     * @param id position index
+     * @return required view
+     * @throw IntVectorOutOfBounds if no view is found
+     */
+    const view<Field> &
+    get_view (
+        const IntVector & id
+    ) const
+    {
+        for ( const auto * view : m_views )
+            if ( view->is_defined_at ( id ) )
+                return *view;
+        SCI_THROW ( IntVectorOutOfBounds ( id,  __FILE__, __LINE__ ) );
+    }
+
+protected: // CONSTRUCTORS
+
+    /// Default constructor
+    piecewise_view () = default;
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     */
+
+    piecewise_view (
+        const piecewise_view * copy,
+        bool deep
+    )
+    {
+        for ( const auto * view : copy->m_views )
+            m_views.emplace_back ( view->clone ( deep ) );
+    }
+
+public: // CONSTRUCTORS/DESTRUCTOR
+
+    /// Default destructor
+    virtual ~piecewise_view () = default;
+
+    /// Prevent copy (and move) constructor
+    piecewise_view ( const piecewise_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    piecewise_view & operator= ( const piecewise_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        for ( const auto * view : m_views )
+            if ( view->is_defined_at ( id ) ) return true;
+        return false;
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual inline T &
+    operator[] (
+        const IntVector & id
+    ) override
+    {
+        return get_view ( id ) [id];
+    };
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual inline V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        return get_view ( id ) [id];
+    };
+
+}; // class view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_detail_piecewise_view_h
diff --git a/src/CCA/Components/PhaseField/Views/detail/view.h b/src/CCA/Components/PhaseField/Views/detail/view.h
new file mode 100644
index 00000000..07eb0608
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Views/detail/view.h
@@ -0,0 +1,203 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Views/detail/view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Views_detail_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_Views_detail_view_h
+
+#include <CCA/Components/PhaseField/Util/Definitions.h>
+#include <CCA/Components/PhaseField/DataTypes/Support.h>
+#include <CCA/Components/PhaseField/DataTypes/ScalarField.h>
+#include <CCA/Components/PhaseField/DataTypes/VectorField.h>
+#include <CCA/Components/PhaseField/Views/detail/view_array.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Abstract wrapper for accessing grid variables
+ *
+ * detail implementation of variable wrapping
+ *
+ * @remark constant view must use fields with const value type
+ *
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ */
+template <typename Field> class view;
+
+/**
+ * @brief Abstract class for accessing variables (ScalarField implementation)
+ *
+ * detail implementation of variable wrapping
+ *
+ * @remark constant view must use fields with const value type
+ *
+ * @tparam T type of the field value at each point
+ */
+template <typename T>
+class view < ScalarField<T> >
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+public: // TYPES
+
+    /// Type of field
+    using field_type = ScalarField<T>;
+
+    /// Default value for use_ghost when retrieving data
+    static constexpr bool use_ghosts_dflt = false;
+
+public: // DESTRUCTOR
+
+    /// Default destructor
+    virtual ~view() = default;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void set ( DataWarehouse * dw, const Patch * patch, bool use_ghosts = use_ghosts_dflt ) = 0;
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void set ( DataWarehouse * dw, const Level * level, const IntVector & low, const IntVector & high, bool use_ghosts = use_ghosts_dflt ) = 0;
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view * clone ( bool deep ) const = 0;
+
+    /**
+     * @brief Get a copy of the view and apply translate the support
+     *
+     * @remark It is meant to be used for virtual patches (i.e. periodic boundaries)
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     * @return new view instance
+     */
+    virtual view * clone ( bool deep, const IntVector & offset ) const = 0;
+
+    /**
+     * @brief Get the region for which the view has access to the DataWarehouse
+     *
+     * @return support of the view
+     */
+    virtual Support get_support() const = 0;
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual bool is_defined_at ( const IntVector & id ) const = 0;
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual T & operator[] ( const IntVector & id ) = 0;
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual V operator[] ( const IntVector & id ) const = 0;
+
+}; // class view
+
+/**
+ * @brief Abstract class for accessing variables (VectorField implementation)
+ *
+ * detail implementation of variable wrapping
+ *
+ * @remark constant view must use fields with const value type
+ *
+ * @tparam T type of each component of the field at each point
+ * @tparam N number of components
+ */
+template <typename T, size_t N >
+class view < VectorField<T, N> >
+    : virtual public view_array < view < ScalarField<T> >, ScalarField<T>, N >
+{
+public: // DESTRUCTOR
+
+    /// Default destructor
+    virtual ~view() = default;
+
+    /**
+     * @brief Get a copy of the view
+     *
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     *
+     * @return new view instance
+     */
+    virtual view * clone ( bool deep ) const = 0;
+
+}; // class view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_detail_view_h
diff --git a/src/CCA/Components/PhaseField/Views/detail/view_array.h b/src/CCA/Components/PhaseField/Views/detail/view_array.h
new file mode 100644
index 00000000..6767185b
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Views/detail/view_array.h
@@ -0,0 +1,133 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Views/detail/view_array.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Views_detail_view_array_h
+#define Packages_Uintah_CCA_Components_PhaseField_Views_detail_view_array_h
+
+#include <CCA/Ports/DataWarehouse.h>
+#include <CCA/Components/PhaseField/Views/detail/view_array_view.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Container for collecting multiple generic views as an array
+ *
+ * @remark no instantiation must be performed here
+ *
+ * @tparam View type of Views in the array
+ * @tparam Field type of Fields in the array
+ * @tparam N size of the array
+ */
+template<typename View, typename Field, size_t N>
+class view_array
+    : virtual protected view_array_view<Field, N>
+{
+public: // VIEW ARRAY METHODS
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    inline void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts = View::use_ghosts_dflt
+    )
+    {
+        for ( auto * view : this->m_view_ptr )
+            dynamic_cast<View *> ( view )->set ( dw, patch, use_ghosts );
+    };
+
+    /**
+     * @brief Retrieve value from the DataWarehouse for a given region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts = View::use_ghosts_dflt
+    )
+    {
+        for ( auto * view : this->m_view_ptr )
+            dynamic_cast<View *> ( view )->set ( dw, level, low, high, use_ghosts );
+    };
+
+    /**
+     * @brief Get reference to field component
+     *
+     * @param pos component index
+     * @return reference to the view of the component
+     */
+    View &
+    operator [] (
+        size_t pos
+    )
+    {
+        return dynamic_cast<View &> ( *this->m_view_ptr[pos] );
+    }
+
+    /**
+     * @brief Get reference to field component
+     *
+     * @param pos component index
+     * @return reference to the view of the component
+     */
+    const View &
+    operator [] (
+        size_t pos
+    ) const
+    {
+        return dynamic_cast<const View &> ( *this->m_view_ptr[pos] );
+    }
+
+}; // class view_array
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_detail_view_array_h
diff --git a/src/CCA/Components/PhaseField/Views/detail/view_array_view.h b/src/CCA/Components/PhaseField/Views/detail/view_array_view.h
new file mode 100644
index 00000000..580e7ea8
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Views/detail/view_array_view.h
@@ -0,0 +1,79 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Views/detail/view_array_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Views_detail_view_array_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_Views_detail_view_array_view_h
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+template <typename Field> class view;
+
+/**
+ * @brief Container for collecting multiple views as an array
+ *
+ * It is used as base class for view_array in order to provide a unique container
+ * across all view_array derived classes implementations
+ *
+ * @remark no instantiation must be performed here
+ *
+ * @tparam Field type of Field
+ * @tparam N size of the array
+ */
+template <typename Field, size_t N >
+class view_array_view
+{
+protected: // MEMBERS
+
+    std::array < view<Field> *, N > m_view_ptr;
+
+protected: // CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Initialize the array without instantiating component views
+     */
+    view_array_view ()
+    {
+        m_view_ptr.fill ( nullptr );
+    }
+
+}; // class view_array_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif // Packages_Uintah_CCA_Components_PhaseField_Views_detail_view_array_view_h
diff --git a/src/CCA/Components/PhaseField/Views/detail/virtual_view.h b/src/CCA/Components/PhaseField/Views/detail/virtual_view.h
new file mode 100644
index 00000000..740b90de
--- /dev/null
+++ b/src/CCA/Components/PhaseField/Views/detail/virtual_view.h
@@ -0,0 +1,231 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 1997-2018 The University of Utah
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file CCA/Components/PhaseField/Views/detail/virtual_view.h
+ * @author Jon Matteo Church [j.m.church@leeds.ac.uk]
+ * @date 2018/12
+ */
+
+#ifndef Packages_Uintah_CCA_Components_PhaseField_Views_detail_virtual_view_h
+#define Packages_Uintah_CCA_Components_PhaseField_Views_detail_virtual_view_h
+
+#include <CCA/Components/PhaseField/DataTypes/SubProblemsP.h>
+#include <CCA/Components/PhaseField/DataTypes/Variable.h> // must be included after handles where swapbytes override is defined
+#include <CCA/Components/PhaseField/Views/detail/view.h>
+#include <CCA/Components/PhaseField/DataWarehouse/DWInterface.h>
+
+namespace Uintah
+{
+namespace PhaseField
+{
+namespace detail
+{
+
+/**
+ * @brief Abstract class for accessing variables on virtual patches
+ *
+ * detail implementation of variable wrapping
+ *
+ * @remark constant view must be used
+ *
+ * @tparam View type of underlying view
+ * @tparam Field type of field (ScalarField < T > or VectorField < T, N >)
+ */
+template<typename View, typename Field> class virtual_view;
+
+/**
+ * @brief Abstract class for accessing variables on virtual patches
+ * (ScalarField implementation)
+ *
+ * detail implementation of variable wrapping
+ *
+ * @remark constant view must be used
+ *
+ * @tparam View type of underlying view
+ * @tparam T type of the field value at each point
+ */
+template<typename View, typename T>
+class virtual_view < View, ScalarField<T> > :
+    public View
+{
+private: // TYPES
+
+    /// Type of field
+    using Field = ScalarField<T>;
+
+    /// Non const type of the field value
+    using V = typename std::remove_const<T>::type;
+
+private: // FRIENDS
+
+    friend View;
+
+private: // MEMBERS
+
+    /// Translation vector
+    IntVector m_offset;
+
+private: // COPY CONSTRUCTOR
+
+    /**
+     * @brief Constructor
+     *
+     * Instantiate a copy of a given view
+     *
+     * @remark only View can call this constructor
+     *
+     * @param copy source view for copying
+     * @param deep if true inner grid variable is copied as well otherwise the
+     * same grid variable is referenced
+     * @param offset vector specifying the translation of the support
+     */
+    virtual_view (
+        const View * copy,
+        bool deep,
+        const IntVector & offset
+    ) : View ( copy, deep ),
+        m_offset ( offset )
+    {
+        ASSERTMSG ( std::is_const<T>::value, "Only constant views are allowed on virtual patches" );
+    }
+
+public: // DESTRUCTOR
+
+    virtual ~virtual_view() = default;
+
+    /// Prevent copy (and move) constructor
+    virtual_view ( const virtual_view & ) = delete;
+
+    /// Prevent copy (and move) assignment
+    virtual_view & operator= ( const virtual_view & ) = delete;
+
+public: // VIEW METHODS
+
+    /**
+     * @brief Retrieve values from the DataWarehouse for a given patch
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param patch grid patch to retrieve data for
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Patch * patch,
+        bool use_ghosts
+    ) override
+    {
+        View::set ( dw, patch, use_ghosts );
+        m_offset = patch->getVirtualOffset();
+    };
+
+    /**
+     * @brief Retrieve values from the DataWarehouse for a given region
+     *
+     * @param dw DataWarehouse from which data is retrieved
+     * @param level grid level from which retrieve data
+     * @param low lower bound of the region to retrieve
+     * @param high higher bound of the region to retrieve
+     * @param use_ghosts if ghosts value are to be retrieved
+     */
+    virtual void
+    set (
+        DataWarehouse * dw,
+        const Level * level,
+        const IntVector & low,
+        const IntVector & high,
+        bool use_ghosts
+    ) override
+    {
+        View::set ( dw, level, low - m_offset, high - m_offset, use_ghosts );
+    };
+
+    /**
+     * @brief Get the region for which the view has access to the DataWarehouse
+     *
+     * @return support of the view
+     */
+    virtual Support
+    get_support()
+    const override
+    {
+        Support support = View::get_support();
+        for ( auto & region : support )
+        {
+            region.low() += m_offset;
+            region.high() += m_offset;
+        }
+        return support;
+    };
+
+    /**
+     * @brief Check if the view has access to the position with index id
+     *
+     * @param id position index
+     * @return check result
+     */
+    virtual inline bool
+    is_defined_at (
+        const IntVector & id
+    ) const override
+    {
+        return View::is_defined_at ( id - m_offset );
+    };
+
+    /**
+     * @brief Get/Modify value at position with index id (modifications are allowed if T is non const)
+     *
+     * @param id position index
+     * @return reference to field value at id
+     */
+    virtual inline T &
+    operator[] (
+        const IntVector & id
+    ) override
+    {
+        return View::operator[] ( id - m_offset );
+    };
+
+    /**
+     * @brief Get value at position
+     *
+     * @param id position index
+     * @return field value at id
+     */
+    virtual inline V
+    operator[] (
+        const IntVector & id
+    ) const override
+    {
+        return View::operator[] ( id - m_offset );
+    };
+
+}; // dw_virtual_view
+
+} // namespace detail
+} // namespace PhaseField
+} // namespace Uintah
+
+#endif //Packages_Uintah_CCA_Components_PhaseField_Views_detail_virtual_view_h
diff --git a/src/CCA/Components/PhaseField/sub.mk b/src/CCA/Components/PhaseField/sub.mk
index ea00af22..c7da6ad9 100644
--- a/src/CCA/Components/PhaseField/sub.mk
+++ b/src/CCA/Components/PhaseField/sub.mk
@@ -2,17 +2,17 @@
 #  The MIT License
 #
 #  Copyright (c) 1997-2018 The University of Utah
-# 
+#
 #  Permission is hereby granted, free of charge, to any person obtaining a copy
 #  of this software and associated documentation files (the "Software"), to
 #  deal in the Software without restriction, including without limitation the
 #  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 #  sell copies of the Software, and to permit persons to whom the Software is
 #  furnished to do so, subject to the following conditions:
-# 
+#
 #  The above copyright notice and this permission notice shall be included in
 #  all copies or substantial portions of the Software.
-# 
+#
 #  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 #  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 #  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -20,49 +20,50 @@
 #  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 #  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 #  IN THE SOFTWARE.
-# 
-# 
-# 
-# 
-# 
-# Makefile fragment for this subdirectory 
+#
+#
+#
+#
+#
+# Makefile fragment for this subdirectory
 
 include $(SCIRUN_SCRIPTS)/smallso_prologue.mk
 
 SRCDIR := CCA/Components/PhaseField
 
-SRCS += $(SRCDIR)/PhaseField.cc
+SUBDIRS := \
+  $(SRCDIR)/DataWarehouse \
+  $(SRCDIR)/BoundaryConditions \
+  $(SRCDIR)/AMR \
+  $(SRCDIR)/Applications \
+  $(SRCDIR)/Exceptions \
+
+SRCS += \
+
+BLDSRCS := \
 
-PSELIBS :=                         \
-        CCA/Components/Application \
-        CCA/Components/Schedulers  \
-        CCA/Ports                  \
-        Core/Disclosure            \
-        Core/Exceptions            \
-        Core/Geometry              \
-        Core/GeometryPiece         \
-        Core/Grid                  \
-        Core/IO                    \
-        Core/Math                  \
-        Core/Parallel              \
-        Core/ProblemSpec           \
-        Core/Util
+PSELIBS :=                   \
+  CCA/Components/Application \
+  CCA/Components/Schedulers  \
+  CCA/Ports                  \
+  Core/Disclosure            \
+  Core/Exceptions            \
+  Core/Geometry              \
+  Core/GeometryPiece         \
+  Core/Grid                  \
+  Core/IO                    \
+  Core/Math                  \
+  Core/Parallel              \
+  Core/ProblemSpec           \
+  Core/Util
 
-LIBS :=                                                              \
-#        $(Z_LIBRARY) $(XML2_LIBRARY) $(MPI_LIBRARY) $(M_LIBRARY)    \
-#        $(EXPRLIB_LIBRARY) $(SPATIALOPS_LIBRARY)                    \
-#        $(RADPROPS_LIBRARY) $(TABPROPS_LIBRARY)                     \
-#        $(NSCBC_LIBRARY)                                            \
-#        $(POKITT_LIBRARY)                                           \
-#        $(BOOST_LIBRARY) $(LAPACK_LIBRARY) $(BLAS_LIBRARY)
+LIBS := $(M_LIBRARY)
 
-INCLUDES :=                                                           \
-             $(INCLUDES)                                              \
-#            $(SPATIALOPS_INCLUDE) $(EXPRLIB_INCLUDE)                 \
-#            $(TABPROPS_INCLUDE) $(RADPROPS_INCLUDE) $(NSCBC_INCLUDE) \
-#            $(POKITT_INCLUDE) $(BOOST_INCLUDE) $(LAPACK_INCLUDE)
+INCLUDES := $(INCLUDES)
 
-#include $(SCIRUN_SCRIPTS)/recurse.mk
+include $(SCIRUN_SCRIPTS)/recurse.mk
 
 include $(SCIRUN_SCRIPTS)/smallso_epilogue.mk
 
+$(BLDSRCS): %-bld.cc: %-bld.sh
+	bash $<
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0024_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0024_00_6G.ups
deleted file mode 100644
index 283e370a..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0024_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_0024_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[6,4,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0096_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0096_00_6G.ups
deleted file mode 100644
index 0e7f01dd..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0096_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_096_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[12,8,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0096_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0096_02_4G.ups
deleted file mode 100644
index 1af6d70e..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0096_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_096_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[12,8,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_00_6G.ups
deleted file mode 100644
index ba149d9e..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_0384_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_02_4G.ups
deleted file mode 100644
index a43e2d00..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_0384_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_09_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_09_6G.ups
deleted file mode 100644
index 55c49853..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_0384_09_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_0384_09_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.00625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[.25,.25,.25]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_00_6G.ups
deleted file mode 100644
index 49efa701..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_1536_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_02_4G.ups
deleted file mode 100644
index 9a6698c0..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_1536_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_09_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_09_6G.ups
deleted file mode 100644
index 6cd17de6..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_09_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_1536_09_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.00625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.25,.25,.25]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_38_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_38_4G.ups
deleted file mode 100644
index 8bad067f..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_DynamicMPI_1536_38_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="DynamicMPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_DynamicMPI_1536_38_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.0015625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.125,.125,.125]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0024_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0024_00_6G.ups
deleted file mode 100644
index 7629887b..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0024_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_0024_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[6,4,1]</patches>
-            </Box>
-            <spacing>[2.,2.,2.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0096_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0096_00_6G.ups
deleted file mode 100644
index feaef82a..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0096_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_096_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[12,8,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0096_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0096_02_4G.ups
deleted file mode 100644
index f7a8594f..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0096_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_096_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[12,8,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_00_6G.ups
deleted file mode 100644
index 60738fca..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_0384_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_02_4G.ups
deleted file mode 100644
index e9080422..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_0384_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_09_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_09_6G.ups
deleted file mode 100644
index faf24619..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_0384_09_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_0384_09_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.00625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[.25,.25,.25]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_00_6G.ups
deleted file mode 100644
index c48730df..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_1536_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_02_4G.ups
deleted file mode 100644
index 95c06430..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_1536_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_09_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_09_6G.ups
deleted file mode 100644
index 8a2fa2ed..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_09_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_1536_09_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.00625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.25,.25,.25]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_38_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_38_4G.ups
deleted file mode 100644
index c5ecc3a5..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_MPI_1536_38_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_MPI_1536_38_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.0015625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.125,.125,.125]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0024_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0024_00_6G.ups
deleted file mode 100644
index c01553cd..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0024_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_0024_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[6,4,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0096_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0096_00_6G.ups
deleted file mode 100644
index 24d721c4..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0096_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_096_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[12,8,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0096_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0096_02_4G.ups
deleted file mode 100644
index 4151ec7f..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0096_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_096_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[12,8,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_00_6G.ups
deleted file mode 100644
index f2e4f7b2..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_0384_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_02_4G.ups
deleted file mode 100644
index ff42b925..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_0384_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_09_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_09_6G.ups
deleted file mode 100644
index 92638d4a..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_0384_09_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_0384_09_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.00625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[24,16,1]</patches>
-            </Box>
-            <spacing>[.25,.25,.25]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_00_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_00_6G.ups
deleted file mode 100644
index 9bf62e31..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_00_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_1536_00_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.1</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[1.,1.,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_02_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_02_4G.ups
deleted file mode 100644
index 1092e1bd..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_02_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_1536_02_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.025</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.5,.5,.5]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_09_6G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_09_6G.ups
deleted file mode 100644
index 938771d2..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_09_6G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_1536_09_6G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.00625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.25,.25,.25]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_38_4G.ups b/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_38_4G.ups
deleted file mode 100644
index f1065020..00000000
--- a/src/StandAlone/inputs/PhaseField/amr_scalability/cc_Unified_1536_38_4G.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField amr scalability test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>1000.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_Unified_1536_38_4G.uda</filebase>
-        <outputTimestepInterval>0</outputTimestepInterval>
-    </DataArchiver>
-<!--__________________________________-->
-    <PureMetal>
-        <delt>0.0015625</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <psi0>0.</psi0>
-    </PureMetal>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-15000.,-10000., 0.]</lower>
-                <upper>[ 15000., 10000., 1.]</upper>
-                <patches>[48,32,1]</patches>
-            </Box>
-            <spacing>[.125,.125,.125]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/comparison/amr_cc_comparison.ups b/src/StandAlone/inputs/PhaseField/comparison/amr_cc_comparison.ups
deleted file mode 100644
index 7d981b88..00000000
--- a/src/StandAlone/inputs/PhaseField/comparison/amr_cc_comparison.ups
+++ /dev/null
@@ -1,52 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>AMR PhaseField CC comparison test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>3750.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>output/amr_cc_comparison.uda</filebase>
-        <outputTimestepInterval>20</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-    </DataArchiver>
-<!--__________________________________-->
-    <AMR>
-        <Regridder type="Tiled">
-            <max_levels>4</max_levels>
-            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
-            <cell_stability_dilation>[2,2,0]</cell_stability_dilation>
-            <min_boundary_cells>[0,0,0]</min_boundary_cells>
-            <min_patch_size>[[10,10,1]]</min_patch_size>
-        </Regridder>
-   </AMR>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.015</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <refine_threshold>1e-6</refine_threshold>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-560,-560, 0.]</lower>
-                <upper>[ 560, 560, 1.]</upper>
-                <patches>[4,4,1]</patches>
-            </Box>
-            <spacing>[3.2,3.2,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/comparison/amr_nc_comparison.ups b/src/StandAlone/inputs/PhaseField/comparison/amr_nc_comparison.ups
deleted file mode 100644
index 1f098210..00000000
--- a/src/StandAlone/inputs/PhaseField/comparison/amr_nc_comparison.ups
+++ /dev/null
@@ -1,53 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>AMR PhaseField NC comparison test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-    <Scheduler type="Unified" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>3750.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>output/amr_nc_comparison.uda</filebase>
-        <outputTimestepInterval>20</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-    </DataArchiver>
-<!--__________________________________-->
-    <AMR>
-        <Regridder type="Tiled">
-            <max_levels>4</max_levels>
-            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
-            <cell_stability_dilation>[2,2,0]</cell_stability_dilation>
-            <min_boundary_cells>[0,0,0]</min_boundary_cells>
-            <min_patch_size>[[10,10,1]]</min_patch_size>
-        </Regridder>
-   </AMR>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.015</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <node_centered>true</node_centered>
-        <refine_threshold>1e-6</refine_threshold>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-560,-560, 0.]</lower>
-                <upper>[ 560, 560, 1.]</upper>
-                <patches>[4,4,1]</patches>
-            </Box>
-            <spacing>[3.2,3.2,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/comparison/cc_comparison.ups b/src/StandAlone/inputs/PhaseField/comparison/cc_comparison.ups
deleted file mode 100644
index 76bd1e98..00000000
--- a/src/StandAlone/inputs/PhaseField/comparison/cc_comparison.ups
+++ /dev/null
@@ -1,41 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField CC comparison test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>3750.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>output/cc_comparison.uda</filebase>
-        <outputTimestepInterval>20</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-    </DataArchiver>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.015</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-560,-560, 0.]</lower>
-                <upper>[ 560, 560, 1.]</upper>
-                <patches>[4,4,1]</patches>
-            </Box>
-            <spacing>[0.4,0.4,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/comparison/nc_comparison.ups b/src/StandAlone/inputs/PhaseField/comparison/nc_comparison.ups
deleted file mode 100644
index d0afe81f..00000000
--- a/src/StandAlone/inputs/PhaseField/comparison/nc_comparison.ups
+++ /dev/null
@@ -1,42 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>PhaseField NC comparison test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-    <Scheduler type="MPI" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>3750.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>output/nc_comparison.uda</filebase>
-        <outputTimestepInterval>20</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-    </DataArchiver>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.015</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <node_centered>true</node_centered>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-560,-560, 0.]</lower>
-                <upper>[ 560, 560, 1.]</upper>
-                <patches>[4,4,1]</patches>
-            </Box>
-            <spacing>[0.4,0.4,1.]</spacing>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_2d.ups b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_2d.ups
new file mode 100644
index 00000000..83898bb3
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_2d.ups
@@ -0,0 +1,46 @@
+<Uintah_specification>
+  <Meta>
+    <title>pure_metal_cc_2d</title>
+  </Meta>
+  <SimulationComponent type="phasefield" />
+  <PhaseField type="pure_metal">
+    <var>cc</var>
+    <dim>2</dim>
+    <verbosity>0</verbosity>
+    <delt>0.075</delt>
+    <alpha>1.</alpha>
+    <R0>5.</R0>
+    <Delta>0.65</Delta>
+    <epsilon>0.05</epsilon>
+  </PhaseField>
+  <Time>
+    <maxTime>40.0</maxTime>
+    <initTime>0.</initTime>
+    <delt_min>0.</delt_min>
+    <delt_max>1.</delt_max>
+    <timestep_multiplier>1.</timestep_multiplier>
+  </Time>
+  <Grid>
+    <Level>
+      <Box label="1">
+        <lower>[-40.,-40.,-1.]</lower>
+        <upper>[ 40., 40., 1.]</upper>
+        <resolution>[80,80,1]</resolution>
+        <patches>[2,2,1]</patches>
+      </Box>
+      <periodic>[1,1,0]</periodic>
+    </Level>
+  </Grid>
+  <DataArchiver>
+    <filebase>pure_metal_cc_2d.uda</filebase>
+    <outputTimestepInterval>1</outputTimestepInterval>
+    <save label="psi" />
+    <save label="u" />
+    <save label="psi_x" />
+    <save label="psi_y" />
+    <save label="grad_psi_norm2" />
+    <save label="A" />
+    <save label="A2" />
+    <save label="Bxy" />
+  </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_2d_amr.ups b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_2d_amr.ups
new file mode 100644
index 00000000..6a935f34
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_2d_amr.ups
@@ -0,0 +1,63 @@
+<Uintah_specification>
+  <Meta>
+    <title>pure_metal_cc_2d_amr</title>
+  </Meta>
+  <SimulationComponent type="phasefield" />
+  <PhaseField type="pure_metal">
+    <var>cc</var>
+    <dim>2</dim>
+    <verbosity>0</verbosity>
+    <delt>0.075</delt>
+    <alpha>1.</alpha>
+    <R0>5.</R0>
+    <Delta>0.65</Delta>
+    <epsilon>0.05</epsilon>
+    <refine_threshold>0.03</refine_threshold>
+  </PhaseField>
+  <Time>
+    <maxTime>40.0</maxTime>
+    <initTime>0.</initTime>
+    <delt_min>0.</delt_min>
+    <delt_max>1.</delt_max>
+    <timestep_multiplier>1.</timestep_multiplier>
+  </Time>
+  <Grid>
+    <Level>
+      <Box label="1">
+        <lower>[-40.,-40.,-1.]</lower>
+        <upper>[ 40., 40., 1.]</upper>
+        <resolution>[40,40,1]</resolution>
+        <patches>[2,2,1]</patches>
+      </Box>
+      <periodic>[1,1,0]</periodic>
+    </Level>
+  </Grid>
+    <AMR>
+        <Regridder type="Tiled">
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
+            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
+            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
+            <min_boundary_cells>[1,1,0]</min_boundary_cells>
+            <min_patch_size>[[8,8,1]]</min_patch_size>
+        </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="psi" var="FC1" />
+            <FCIType id="1" label="u"   var="FC1" />
+            <FCIType id="2" label="A2"  var="FC1" />
+            <FCIType id="3" label="Bxy" var="FC1" />
+        </FineCoarseInterfaces>
+    </AMR>
+  <DataArchiver>
+    <filebase>pure_metal_cc_2d_amr.uda</filebase>
+    <outputTimestepInterval>1</outputTimestepInterval>
+    <save label="psi" />
+    <save label="u" />
+    <save label="psi_x" />
+    <save label="psi_y" />
+    <save label="grad_psi_norm2" />
+    <save label="A" />
+    <save label="A2" />
+    <save label="Bxy" />
+  </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_3d.ups b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_3d.ups
new file mode 100644
index 00000000..63ff4440
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_3d.ups
@@ -0,0 +1,46 @@
+<Uintah_specification>
+  <Meta>
+    <title>pure_metal_cc_3d</title>
+  </Meta>
+  <SimulationComponent type="phasefield" />
+  <PhaseField type="pure_metal">
+    <var>cc</var>
+    <dim>3</dim>
+    <verbosity>0</verbosity>
+    <delt>0.075</delt>
+    <alpha>1.</alpha>
+    <R0>5.</R0>
+    <Delta>0.65</Delta>
+    <epsilon>0.05</epsilon>
+  </PhaseField>
+  <Time>
+    <maxTime>40.0</maxTime>
+    <initTime>0.</initTime>
+    <delt_min>0.</delt_min>
+    <delt_max>1.</delt_max>
+    <timestep_multiplier>1.</timestep_multiplier>
+  </Time>
+  <Grid>
+    <Level>
+      <Box label="1">
+        <lower>[-40.,-40.,-40.]</lower>
+        <upper>[ 40., 40., 40.]</upper>
+        <resolution>[80,80,80]</resolution>
+        <patches>[2,2,2]</patches>
+      </Box>
+      <periodic>[1,1,1]</periodic>
+    </Level>
+  </Grid>
+  <DataArchiver>
+    <filebase>pure_metal_cc_3d.uda</filebase>
+    <outputTimestepInterval>1</outputTimestepInterval>
+    <save label="psi" />
+    <save label="u" />
+    <save label="psi_x" />
+    <save label="psi_y" />
+    <save label="grad_psi_norm2" />
+    <save label="A" />
+    <save label="A2" />
+    <save label="Bxy" />
+  </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_3d_amr.ups b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_3d_amr.ups
new file mode 100644
index 00000000..ca4cddf2
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_cc_3d_amr.ups
@@ -0,0 +1,68 @@
+<Uintah_specification>
+  <Meta>
+    <title>pure_metal_cc_3d_amr</title>
+  </Meta>
+  <SimulationComponent type="phasefield" />
+  <PhaseField type="pure_metal">
+    <var>cc</var>
+    <dim>3</dim>
+    <verbosity>0</verbosity>
+    <delt>0.075</delt>
+    <alpha>1.</alpha>
+    <R0>5.</R0>
+    <Delta>0.65</Delta>
+    <epsilon>0.05</epsilon>
+    <refine_threshold>0.04</refine_threshold>
+  </PhaseField>
+  <Time>
+    <maxTime>40.0</maxTime>
+    <initTime>0.</initTime>
+    <delt_min>0.</delt_min>
+    <delt_max>1.</delt_max>
+    <timestep_multiplier>1.</timestep_multiplier>
+  </Time>
+  <Grid>
+    <Level>
+      <Box label="1">
+        <lower>[-40.,-40.,-40.]</lower>
+        <upper>[ 40., 40., 40.]</upper>
+        <resolution>[40,40,40]</resolution>
+        <patches>[2,2,2]</patches>
+      </Box>
+      <periodic>[1,1,1]</periodic>
+    </Level>
+  </Grid>
+    <AMR>
+        <Regridder type="Tiled">
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
+            <cell_refinement_ratio>[[2,2,2]]</cell_refinement_ratio>
+            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
+            <min_boundary_cells>[1,1,1]</min_boundary_cells>
+            <min_patch_size>[[8,8,8]]</min_patch_size>
+        </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="psi" var="FC1" />
+            <FCIType id="1" label="u"   var="FC1" />
+            <FCIType id="2" label="A2"  var="FC1" />
+            <FCIType id="3" label="Bxy" var="FC1" />
+            <FCIType id="4" label="Bxz" var="FC1" />
+            <FCIType id="5" label="Byz" var="FC1" />
+        </FineCoarseInterfaces>
+    </AMR>
+  <DataArchiver>
+    <filebase>pure_metal_cc_2d_amr.uda</filebase>
+    <outputTimestepInterval>1</outputTimestepInterval>
+    <save label="psi" />
+    <save label="u" />
+    <save label="psi_x" />
+    <save label="psi_y" />
+    <save label="psi_z" />
+    <save label="grad_psi_norm2" />
+    <save label="A" />
+    <save label="A2" />
+    <save label="Bxy" />
+    <save label="Bxz" />
+    <save label="Byz" />
+  </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_2d.ups b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_2d.ups
new file mode 100644
index 00000000..6e3fa99a
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_2d.ups
@@ -0,0 +1,46 @@
+<Uintah_specification>
+  <Meta>
+    <title>pure_metal_nc_2d</title>
+  </Meta>
+  <SimulationComponent type="phasefield" />
+  <PhaseField type="pure_metal">
+    <var>nc</var>
+    <dim>2</dim>
+    <verbosity>0</verbosity>
+    <delt>0.075</delt>
+    <alpha>1.</alpha>
+    <R0>5.</R0>
+    <Delta>0.65</Delta>
+    <epsilon>0.05</epsilon>
+  </PhaseField>
+  <Time>
+    <maxTime>40.0</maxTime>
+    <initTime>0.</initTime>
+    <delt_min>0.</delt_min>
+    <delt_max>1.</delt_max>
+    <timestep_multiplier>1.</timestep_multiplier>
+  </Time>
+  <Grid>
+    <Level>
+      <Box label="1">
+        <lower>[-40.,-40.,-1.]</lower>
+        <upper>[ 40., 40., 1.]</upper>
+        <resolution>[80,80,1]</resolution>
+        <patches>[2,2,1]</patches>
+      </Box>
+      <periodic>[1,1,0]</periodic>
+    </Level>
+  </Grid>
+  <DataArchiver>
+    <filebase>pure_metal_nc_2d.uda</filebase>
+    <outputTimestepInterval>1</outputTimestepInterval>
+    <save label="psi" />
+    <save label="u" />
+    <save label="psi_x" />
+    <save label="psi_y" />
+    <save label="grad_psi_norm2" />
+    <save label="A" />
+    <save label="A2" />
+    <save label="Bxy" />
+  </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_2d_amr.ups b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_2d_amr.ups
new file mode 100644
index 00000000..de901e42
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_2d_amr.ups
@@ -0,0 +1,63 @@
+<Uintah_specification>
+  <Meta>
+    <title>pure_metal_nc_2d_amr</title>
+  </Meta>
+  <SimulationComponent type="phasefield" />
+  <PhaseField type="pure_metal">
+    <var>nc</var>
+    <dim>2</dim>
+    <verbosity>0</verbosity>
+    <delt>0.075</delt>
+    <alpha>1.</alpha>
+    <R0>5.</R0>
+    <Delta>0.65</Delta>
+    <epsilon>0.05</epsilon>
+    <refine_threshold>0.03</refine_threshold>
+  </PhaseField>
+  <Time>
+    <maxTime>40.0</maxTime>
+    <initTime>0.</initTime>
+    <delt_min>0.</delt_min>
+    <delt_max>1.</delt_max>
+    <timestep_multiplier>1.</timestep_multiplier>
+  </Time>
+  <Grid>
+    <Level>
+      <Box label="1">
+        <lower>[-40.,-40.,-1.]</lower>
+        <upper>[ 40., 40., 1.]</upper>
+        <resolution>[40,40,1]</resolution>
+        <patches>[2,2,1]</patches>
+      </Box>
+      <periodic>[1,1,0]</periodic>
+    </Level>
+  </Grid>
+    <AMR>
+        <Regridder type="Tiled">
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
+            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
+            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
+            <min_boundary_cells>[1,1,0]</min_boundary_cells>
+            <min_patch_size>[[8,8,1]]</min_patch_size>
+        </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="psi" var="FC1" />
+            <FCIType id="1" label="u"   var="FC1" />
+            <FCIType id="2" label="A2"  var="FC1" />
+            <FCIType id="3" label="Bxy" var="FC1" />
+        </FineCoarseInterfaces>
+    </AMR>
+  <DataArchiver>
+    <filebase>pure_metal_nc_2d_amr.uda</filebase>
+    <outputTimestepInterval>1</outputTimestepInterval>
+    <save label="psi" />
+    <save label="u" />
+    <save label="psi_x" />
+    <save label="psi_y" />
+    <save label="grad_psi_norm2" />
+    <save label="A" />
+    <save label="A2" />
+    <save label="Bxy" />
+  </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_3d.ups b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_3d.ups
new file mode 100644
index 00000000..ea24ebe1
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_3d.ups
@@ -0,0 +1,46 @@
+<Uintah_specification>
+  <Meta>
+    <title>pure_metal_nc_3d</title>
+  </Meta>
+  <SimulationComponent type="phasefield" />
+  <PhaseField type="pure_metal">
+    <var>nc</var>
+    <dim>3</dim>
+    <verbosity>0</verbosity>
+    <delt>0.075</delt>
+    <alpha>1.</alpha>
+    <R0>5.</R0>
+    <Delta>0.65</Delta>
+    <epsilon>0.05</epsilon>
+  </PhaseField>
+  <Time>
+    <maxTime>40.0</maxTime>
+    <initTime>0.</initTime>
+    <delt_min>0.</delt_min>
+    <delt_max>1.</delt_max>
+    <timestep_multiplier>1.</timestep_multiplier>
+  </Time>
+  <Grid>
+    <Level>
+      <Box label="1">
+        <lower>[-40.,-40.,-40.]</lower>
+        <upper>[ 40., 40., 40.]</upper>
+        <resolution>[80,80,80]</resolution>
+        <patches>[2,2,2]</patches>
+      </Box>
+      <periodic>[1,1,1]</periodic>
+    </Level>
+  </Grid>
+  <DataArchiver>
+    <filebase>pure_metal_nc_3d.uda</filebase>
+    <outputTimestepInterval>1</outputTimestepInterval>
+    <save label="psi" />
+    <save label="u" />
+    <save label="psi_x" />
+    <save label="psi_y" />
+    <save label="grad_psi_norm2" />
+    <save label="A" />
+    <save label="A2" />
+    <save label="Bxy" />
+  </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_3d_amr.ups b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_3d_amr.ups
new file mode 100644
index 00000000..bc6bda2d
--- /dev/null
+++ b/src/StandAlone/inputs/PhaseField/pure_metal/pure_metal_nc_3d_amr.ups
@@ -0,0 +1,68 @@
+<Uintah_specification>
+  <Meta>
+    <title>pure_metal_nc_3d_amr</title>
+  </Meta>
+  <SimulationComponent type="phasefield" />
+  <PhaseField type="pure_metal">
+    <var>nc</var>
+    <dim>3</dim>
+    <verbosity>0</verbosity>
+    <delt>0.075</delt>
+    <alpha>1.</alpha>
+    <R0>5.</R0>
+    <Delta>0.65</Delta>
+    <epsilon>0.05</epsilon>
+    <refine_threshold>0.04</refine_threshold>
+  </PhaseField>
+  <Time>
+    <maxTime>40.0</maxTime>
+    <initTime>0.</initTime>
+    <delt_min>0.</delt_min>
+    <delt_max>1.</delt_max>
+    <timestep_multiplier>1.</timestep_multiplier>
+  </Time>
+  <Grid>
+    <Level>
+      <Box label="1">
+        <lower>[-40.,-40.,-40.]</lower>
+        <upper>[ 40., 40., 40.]</upper>
+        <resolution>[40,40,40]</resolution>
+        <patches>[2,2,2]</patches>
+      </Box>
+      <periodic>[1,1,1]</periodic>
+    </Level>
+  </Grid>
+    <AMR>
+        <Regridder type="Tiled">
+            <adaptive>true</adaptive>
+            <max_levels>2</max_levels>
+            <cell_refinement_ratio>[[2,2,2]]</cell_refinement_ratio>
+            <cell_stability_dilation>[0,0,0]</cell_stability_dilation>
+            <min_boundary_cells>[1,1,1]</min_boundary_cells>
+            <min_patch_size>[[8,8,8]]</min_patch_size>
+        </Regridder>
+        <FineCoarseInterfaces>
+            <FCIType id="0" label="psi" var="FC1" />
+            <FCIType id="1" label="u"   var="FC1" />
+            <FCIType id="2" label="A2"  var="FC1" />
+            <FCIType id="3" label="Bxy" var="FC1" />
+            <FCIType id="4" label="Bxz" var="FC1" />
+            <FCIType id="5" label="Byz" var="FC1" />
+        </FineCoarseInterfaces>
+    </AMR>
+  <DataArchiver>
+    <filebase>pure_metal_nc_2d_amr.uda</filebase>
+    <outputTimestepInterval>1</outputTimestepInterval>
+    <save label="psi" />
+    <save label="u" />
+    <save label="psi_x" />
+    <save label="psi_y" />
+    <save label="psi_z" />
+    <save label="grad_psi_norm2" />
+    <save label="A" />
+    <save label="A2" />
+    <save label="Bxy" />
+    <save label="Bxz" />
+    <save label="Byz" />
+  </DataArchiver>
+</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/test/amr_cc_phase_field_2d.ups b/src/StandAlone/inputs/PhaseField/test/amr_cc_phase_field_2d.ups
deleted file mode 100644
index 47b36155..00000000
--- a/src/StandAlone/inputs/PhaseField/test/amr_cc_phase_field_2d.ups
+++ /dev/null
@@ -1,58 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>AMR CC PhaseField test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>40.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>amr_cc_phasefield_2d.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-        <save label="psi_x" />
-        <save label="psi_y" />
-        <save label="grad_psi_norm2" />
-        <save label="A" />
-        <save label="A2" />
-        <save label="Bxy" />
-        <save label="refineFlag" />
-    </DataArchiver>
-<!--__________________________________-->
-    <AMR>
-        <Regridder type="Tiled">
-            <max_levels>3</max_levels>
-            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
-            <cell_stability_dilation>[2,2,0]</cell_stability_dilation>
-            <min_boundary_cells>[0,0,0]</min_boundary_cells>
-            <min_patch_size>[[4,4,1]]</min_patch_size>
-        </Regridder>
-   </AMR>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.075</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <refine_threshold>1e-7</refine_threshold>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-40.,-40.,-1.]</lower>
-                <upper>[ 40., 40., 1.]</upper>
-                <resolution>[20,20,1]</resolution>
-                <patches>[2,2,1]</patches>
-            </Box>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/test/amr_cc_phase_field_3d.ups b/src/StandAlone/inputs/PhaseField/test/amr_cc_phase_field_3d.ups
deleted file mode 100644
index 5574837f..00000000
--- a/src/StandAlone/inputs/PhaseField/test/amr_cc_phase_field_3d.ups
+++ /dev/null
@@ -1,62 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>AMR CC PhaseField test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>40.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>amr_cc_phasefield_3d.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-        <save label="psi_x" />
-        <save label="psi_y" />
-        <save label="psi_z" />
-        <save label="grad_psi_norm2" />
-        <save label="A" />
-        <save label="A2" />
-        <save label="Bxy" />
-        <save label="Bxz" />
-        <save label="Byz" />
-        <save label="refineFlag" />
-    </DataArchiver>
-<!--__________________________________-->
-    <AMR>
-        <Regridder type="Tiled">
-            <max_levels>3</max_levels>
-            <cell_refinement_ratio>[[2,2,2]]</cell_refinement_ratio>
-            <cell_stability_dilation>[2,2,2]</cell_stability_dilation>
-            <min_boundary_cells>[0,0,0]</min_boundary_cells>
-            <min_patch_size>[[4,4,4]]</min_patch_size>
-        </Regridder>
-   </AMR>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.075</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <refine_threshold>1e-7</refine_threshold>
-        <dimension>3</dimension>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-40.,-40.,-40.]</lower>
-                <upper>[ 40., 40., 40.]</upper>
-                <resolution>[20,20,20]</resolution>
-                <patches>[2,2,2]</patches>
-            </Box>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/test/amr_nc_phase_field_2d.ups b/src/StandAlone/inputs/PhaseField/test/amr_nc_phase_field_2d.ups
deleted file mode 100644
index 93f80c13..00000000
--- a/src/StandAlone/inputs/PhaseField/test/amr_nc_phase_field_2d.ups
+++ /dev/null
@@ -1,59 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>AMR NC PhaseField test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>40.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>amr_nc_phasefield_2d.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-        <save label="psi_x" />
-        <save label="psi_y" />
-        <save label="grad_psi_norm2" />
-        <save label="A" />
-        <save label="A2" />
-        <save label="Bxy" />
-        <save label="refineFlag" />
-    </DataArchiver>
-<!--__________________________________-->
-    <AMR>
-        <Regridder type="Tiled">
-            <max_levels>3</max_levels>
-            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
-            <cell_stability_dilation>[2,2,0]</cell_stability_dilation>
-            <min_boundary_cells>[0,0,0]</min_boundary_cells>
-            <min_patch_size>[[4,4,1]]</min_patch_size>
-        </Regridder>
-   </AMR>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.075</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <refine_threshold>1e-7</refine_threshold>
-        <node_centered>true</node_centered>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-40.,-40.,-1.]</lower>
-                <upper>[ 40., 40., 1.]</upper>
-                <resolution>[20,20,1]</resolution>
-                <patches>[2,2,1]</patches>
-            </Box>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/test/amr_nc_phase_field_3d.ups b/src/StandAlone/inputs/PhaseField/test/amr_nc_phase_field_3d.ups
deleted file mode 100644
index a982f32c..00000000
--- a/src/StandAlone/inputs/PhaseField/test/amr_nc_phase_field_3d.ups
+++ /dev/null
@@ -1,63 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>AMR NC PhaseField test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>40.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>amr_nc_phasefield_3d.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-        <save label="psi_x" />
-        <save label="psi_y" />
-        <save label="psi_z" />
-        <save label="grad_psi_norm2" />
-        <save label="A" />
-        <save label="A2" />
-        <save label="Bxy" />
-        <save label="Bxz" />
-        <save label="Byz" />
-        <save label="refineFlag" />
-    </DataArchiver>
-<!--__________________________________-->
-    <AMR>
-        <Regridder type="Tiled">
-            <max_levels>3</max_levels>
-            <cell_refinement_ratio>[[2,2,1]]</cell_refinement_ratio>
-            <cell_stability_dilation>[2,2,0]</cell_stability_dilation>
-            <min_boundary_cells>[0,0,0]</min_boundary_cells>
-            <min_patch_size>[[4,4,1]]</min_patch_size>
-        </Regridder>
-   </AMR>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.075</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <refine_threshold>1e-7</refine_threshold>
-        <node_centered>true</node_centered>
-        <dimension>3</dimension>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-40.,-40.,-1.]</lower>
-                <upper>[ 40., 40., 1.]</upper>
-                <resolution>[20,20,1]</resolution>
-                <patches>[2,2,1]</patches>
-            </Box>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/test/cc_phase_field_2d.ups b/src/StandAlone/inputs/PhaseField/test/cc_phase_field_2d.ups
deleted file mode 100644
index 7e0dc3f5..00000000
--- a/src/StandAlone/inputs/PhaseField/test/cc_phase_field_2d.ups
+++ /dev/null
@@ -1,46 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>CC PhaseField test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>40.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_phasefield_2d.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-        <save label="psi_x" />
-        <save label="psi_y" />
-        <save label="grad_psi_norm2" />
-        <save label="A" />
-        <save label="A2" />
-        <save label="Bxy" />
-    </DataArchiver>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.075</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-40.,-40.,-1.]</lower>
-                <upper>[ 40., 40., 1.]</upper>
-                <resolution>[80,80,1]</resolution>
-                <patches>[2,2,1]</patches>
-            </Box>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/test/cc_phase_field_3d.ups b/src/StandAlone/inputs/PhaseField/test/cc_phase_field_3d.ups
deleted file mode 100644
index 14bfd362..00000000
--- a/src/StandAlone/inputs/PhaseField/test/cc_phase_field_3d.ups
+++ /dev/null
@@ -1,50 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>CC PhaseField test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>40.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.0001</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>cc_phasefield_3d.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-        <save label="psi_x" />
-        <save label="psi_y" />
-        <save label="psi_z" />
-        <save label="grad_psi_norm2" />
-        <save label="A" />
-        <save label="A2" />
-        <save label="Bxy" />
-        <save label="Bxz" />
-        <save label="Byz" />
-    </DataArchiver>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.075</delt>
-        <alpha>1.</alpha>
-        <R0>10.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <dimension>3</dimension>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-40.,-40.,-40.]</lower>
-                <upper>[ 40., 40., 40.]</upper>
-                <resolution>[20,20,20]</resolution>
-                <patches>[2,2,2]</patches>
-            </Box>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/test/nc_phase_field_2d.ups b/src/StandAlone/inputs/PhaseField/test/nc_phase_field_2d.ups
deleted file mode 100644
index 65c45292..00000000
--- a/src/StandAlone/inputs/PhaseField/test/nc_phase_field_2d.ups
+++ /dev/null
@@ -1,47 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>NC PhaseField test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>40.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>nc_phasefield_2d.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-        <save label="psi_x" />
-        <save label="psi_y" />
-        <save label="grad_psi_norm2" />
-        <save label="A" />
-        <save label="A2" /> 
-        <save label="Bxy" />
-    </DataArchiver>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.075</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <node_centered>true</node_centered>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-40.,-40.,-1.]</lower>
-                <upper>[ 40., 40., 1.]</upper>
-                <resolution>[80,80,1]</resolution>
-                <patches>[2,2,1]</patches>
-            </Box>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/test/nc_phase_field_3d.ups b/src/StandAlone/inputs/PhaseField/test/nc_phase_field_3d.ups
deleted file mode 100644
index ba4349e1..00000000
--- a/src/StandAlone/inputs/PhaseField/test/nc_phase_field_3d.ups
+++ /dev/null
@@ -1,51 +0,0 @@
-<Uintah_specification>
-    <Meta>
-        <title>NC PhaseField test</title>
-    </Meta>
-    <SimulationComponent type="phasefield" />
-<!--__________________________________-->
-    <Time>
-        <maxTime>40.0</maxTime>
-        <initTime>0.0</initTime>
-        <delt_min>0.01</delt_min>
-        <delt_max>1.</delt_max>
-        <timestep_multiplier>1.</timestep_multiplier>
-    </Time>
-<!--__________________________________-->
-    <DataArchiver>
-        <filebase>nc_phasefield_3d.uda</filebase>
-        <outputTimestepInterval>1</outputTimestepInterval>
-        <save label="psi" />
-        <save label="u" />
-        <save label="psi_x" />
-        <save label="psi_y" />
-        <save label="psi_z" />
-        <save label="grad_psi_norm2" />
-        <save label="A" />
-        <save label="A2" />
-        <save label="Bxy" />
-        <save label="Bxz" />
-        <save label="Byz" />
-    </DataArchiver>
-<!--__________________________________-->
-    <PhaseField>
-        <delt>0.05</delt>
-        <alpha>1.</alpha>
-        <R0>5.</R0>
-        <Delta>0.65</Delta>
-        <epsilon>0.05</epsilon>
-        <node_centered>true</node_centered>
-        <dimension>3</dimension>
-    </PhaseField>
-<!--__________________________________-->
-    <Grid>
-        <Level>
-            <Box label="1">
-                <lower>[-40.,-40.,-40.]</lower>
-                <upper>[ 40., 40., 40.]</upper>
-                <resolution>[80,80,80]</resolution>
-                <patches>[2,2,2]</patches>
-            </Box>
-        </Level>
-    </Grid>
-</Uintah_specification>
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d.m b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d.m
deleted file mode 100644
index 9cf11603..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d.m
+++ /dev/null
@@ -1,59 +0,0 @@
-XML = [
-    '<Uintah_specification>                                        \n', ...
-    ' <Meta>                                                       \n', ...
-    '  <title>CC PhaseField scalability test</title>               \n', ...
-    ' </Meta>                                                      \n', ...
-    ' <SimulationComponent type="phasefield" />                    \n', ...
-    ' <Scheduler type="%s" />                                      \n', ...
-    ' <Time>                                                       \n', ...
-    '  <maxTime>1000.0</maxTime>                                   \n', ...
-    '  <initTime>0.0</initTime>                                    \n', ...
-    '  <delt_min>0.01</delt_min>                                   \n', ...
-    '  <delt_max>1.</delt_max>                                     \n', ...
-    '  <timestep_multiplier>1.</timestep_multiplier>               \n', ...
-    ' </Time>                                                      \n', ...
-    ' <DataArchiver>                                               \n', ...
-    '  <filebase>%s.uda</filebase>                                 \n', ...
-    '  <outputTimestepInterval>0</outputTimestepInterval>          \n', ...
-    ' </DataArchiver>                                              \n', ...
-    ' <PhaseField>                                                 \n', ...
-    '  <delt>0.075</delt>                                          \n', ...
-    '  <alpha>1.</alpha>                                           \n', ...
-    '  <R0>5.</R0>                                                 \n', ...
-    '  <Delta>0.65</Delta>                                         \n', ...
-    '  <epsilon>0.05</epsilon>                                     \n', ...
-    ' </PhaseField>                                                \n', ...
-    ' <Grid>                                                       \n', ...
-    '  <Level>                                                     \n', ...
-    '   <Box label="1">                                            \n', ...
-    '    <lower>[%d, %d, 0.]</lower>                               \n', ...
-    '    <upper>[%d, %d, 1.]</upper>                               \n', ...
-    '    <patches>[%d,%d,1]</patches>                              \n', ...
-    '   </Box>                                                     \n', ...
-    '   <spacing>[1., 1., 1.]</spacing>                            \n', ...
-    '  </Level>                                                    \n', ...
-    ' </Grid>                                                      \n', ...
-    '</Uintah_specification>                                       \n'];
-
-core_patch_size = 6000;
-
-scheduler = {'MPI','DynamicMPI','Unified' };
-for s=1:3
-    for log4_cores=0:3
-        for load=0:log4_cores
-            cores = 4^log4_cores;
-            patches = [6, 4]*2^load;
-            lower = -patches/2 * core_patch_size;
-            upper = patches/2 * core_patch_size;
-            patches = [6, 4]*2^log4_cores;
-            
-            filename = sprintf('cc_weak_scalability_2d_%s_%d_%d', scheduler{s}, cores, load);
-            xml = sprintf(XML,scheduler{s},filename,lower(1),lower(2),upper(1),upper(2),patches(1),patches(2));
-            
-            fid = fopen ( [filename '.ups'], 'wt' );
-            fprintf(fid, xml);
-            fclose(fid);
-        end
-    end
-end
-
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_0.ups
deleted file mode 100644
index 19df5b3f..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_16_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_1.ups
deleted file mode 100644
index cf635dce..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_16_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_2.ups
deleted file mode 100644
index 0c38b52c..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_16_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_16_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-72000, -48000, 0.]</lower>                               
-    <upper>[72000, 48000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_1_0.ups
deleted file mode 100644
index f937e82f..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_1_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[6,4,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_4_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_4_0.ups
deleted file mode 100644
index 5587c847..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_4_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_4_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_4_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_4_1.ups
deleted file mode 100644
index 74daa7ae..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_4_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_4_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_0.ups
deleted file mode 100644
index 317c471b..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_1.ups
deleted file mode 100644
index 43c29a4c..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_2.ups
deleted file mode 100644
index 8201258d..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-72000, -48000, 0.]</lower>                               
-    <upper>[72000, 48000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_3.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_3.ups
deleted file mode 100644
index 6fd53cbf..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_DynamicMPI_64_3.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_DynamicMPI_64_3.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-144000, -96000, 0.]</lower>                               
-    <upper>[144000, 96000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_0.ups
deleted file mode 100644
index ef2bf545..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_16_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_1.ups
deleted file mode 100644
index a030d7a1..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_16_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_2.ups
deleted file mode 100644
index 77dc9801..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_16_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_16_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-72000, -48000, 0.]</lower>                               
-    <upper>[72000, 48000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_1_0.ups
deleted file mode 100644
index a8f11ef7..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_1_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[6,4,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_4_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_4_0.ups
deleted file mode 100644
index 2230ac59..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_4_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_4_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_4_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_4_1.ups
deleted file mode 100644
index 6d99d24d..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_4_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_4_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_0.ups
deleted file mode 100644
index 8822c14c..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_1.ups
deleted file mode 100644
index f934a7f5..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_2.ups
deleted file mode 100644
index ed624223..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-72000, -48000, 0.]</lower>                               
-    <upper>[72000, 48000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_3.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_3.ups
deleted file mode 100644
index 9563a977..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_MPI_64_3.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_MPI_64_3.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-144000, -96000, 0.]</lower>                               
-    <upper>[144000, 96000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_0.ups
deleted file mode 100644
index 67ffb3aa..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_16_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_1.ups
deleted file mode 100644
index 49719999..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_16_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_2.ups
deleted file mode 100644
index 7d25dae1..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_16_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_16_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-72000, -48000, 0.]</lower>                               
-    <upper>[72000, 48000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_1_0.ups
deleted file mode 100644
index 723ff734..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_1_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[6,4,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_4_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_4_0.ups
deleted file mode 100644
index e4bd0f21..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_4_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_4_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_4_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_4_1.ups
deleted file mode 100644
index 53a42ef7..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_4_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_4_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_0.ups
deleted file mode 100644
index c91b00f2..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-18000, -12000, 0.]</lower>                               
-    <upper>[18000, 12000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_1.ups
deleted file mode 100644
index 6dcbf47f..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-36000, -24000, 0.]</lower>                               
-    <upper>[36000, 24000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_2.ups
deleted file mode 100644
index 87bf4f78..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-72000, -48000, 0.]</lower>                               
-    <upper>[72000, 48000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_3.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_3.ups
deleted file mode 100644
index 60d63f79..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_2d_Unified_64_3.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_2d_Unified_64_3.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-144000, -96000, 0.]</lower>                               
-    <upper>[144000, 96000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d.m b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d.m
deleted file mode 100644
index 90d7e734..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d.m
+++ /dev/null
@@ -1,60 +0,0 @@
-XML = [
-    '<Uintah_specification>                                        \n', ...
-    ' <Meta>                                                       \n', ...
-    '  <title>CC PhaseField scalability test</title>               \n', ...
-    ' </Meta>                                                      \n', ...
-    ' <SimulationComponent type="phasefield" />                    \n', ...
-    ' <Scheduler type="%s" />                                      \n', ...
-    ' <Time>                                                       \n', ...
-    '  <maxTime>1000.0</maxTime>                                   \n', ...
-    '  <initTime>0.0</initTime>                                    \n', ...
-    '  <delt_min>0.01</delt_min>                                   \n', ...
-    '  <delt_max>1.</delt_max>                                     \n', ...
-    '  <timestep_multiplier>1.</timestep_multiplier>               \n', ...
-    ' </Time>                                                      \n', ...
-    ' <DataArchiver>                                               \n', ...
-    '  <filebase>%s.uda</filebase>                                 \n', ...
-    '  <outputTimestepInterval>0</outputTimestepInterval>          \n', ...
-    ' </DataArchiver>                                              \n', ...
-    ' <PhaseField>                                                 \n', ...
-    '  <delt>0.075</delt>                                          \n', ...
-    '  <alpha>1.</alpha>                                           \n', ...
-    '  <R0>5.</R0>                                                 \n', ...
-    '  <Delta>0.65</Delta>                                         \n', ...
-    '  <epsilon>0.05</epsilon>                                     \n', ...
-    '  <dimension>3</dimension>                                    \n', ...
-    ' </PhaseField>                                                \n', ...
-    ' <Grid>                                                       \n', ...
-    '  <Level>                                                     \n', ...
-    '   <Box label="1">                                            \n', ...
-    '    <lower>[%d, %d, %d]</lower>                               \n', ...
-    '    <upper>[%d, %d, %d]</upper>                               \n', ...
-    '    <patches>[%d, %d, %d]</patches>                           \n', ...
-    '   </Box>                                                     \n', ...
-    '   <spacing>[1., 1., 1.]</spacing>                            \n', ...
-    '  </Level>                                                    \n', ...
-    ' </Grid>                                                      \n', ...
-    '</Uintah_specification>                                       \n'];
-
-core_patch_size = 300;
-
-scheduler = {'MPI','DynamicMPI','Unified' };
-for s=1:3
-    for log8_cores=0:2
-        for load=0:log8_cores
-            cores = 8^log8_cores;
-            patches = [2, 3, 4]*2^load;
-            lower = -patches/2 * core_patch_size;
-            upper = patches/2 * core_patch_size;
-            patches = [2, 3, 4]*2^log8_cores;
-            
-            filename = sprintf('cc_weak_scalability_3d_%s_%d_%d', scheduler{s}, cores, load);
-            xml = sprintf(XML,scheduler{s},filename,lower(1),lower(2),lower(3),upper(1),upper(2),upper(3),patches(1),patches(2),patches(3));
-            
-            fid = fopen ( [filename '.ups'], 'wt' );
-            fprintf(fid, xml);
-            fclose(fid);
-        end
-    end
-end
-
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_1_0.ups
deleted file mode 100644
index c735938d..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_1_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_DynamicMPI_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[2, 3, 4]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_0.ups
deleted file mode 100644
index ed442a01..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_DynamicMPI_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_1.ups
deleted file mode 100644
index dd2d4be6..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_1.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_DynamicMPI_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_2.ups
deleted file mode 100644
index 07ddb79b..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_64_2.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_DynamicMPI_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-1200, -1800, -2400]</lower>                               
-    <upper>[1200, 1800, 2400]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_8_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_8_0.ups
deleted file mode 100644
index a23eba5e..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_8_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_DynamicMPI_8_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_8_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_8_1.ups
deleted file mode 100644
index 354bf211..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_DynamicMPI_8_1.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_DynamicMPI_8_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_1_0.ups
deleted file mode 100644
index ae970022..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_1_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_MPI_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[2, 3, 4]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_0.ups
deleted file mode 100644
index 2012be6e..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_MPI_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_1.ups
deleted file mode 100644
index 6d5bf63b..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_1.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_MPI_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_2.ups
deleted file mode 100644
index ad35ab10..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_64_2.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_MPI_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-1200, -1800, -2400]</lower>                               
-    <upper>[1200, 1800, 2400]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_8_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_8_0.ups
deleted file mode 100644
index 5c29130a..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_8_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_MPI_8_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_8_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_8_1.ups
deleted file mode 100644
index 6e20fb7c..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_MPI_8_1.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_MPI_8_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_1_0.ups
deleted file mode 100644
index cc92a747..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_1_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_Unified_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[2, 3, 4]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_0.ups
deleted file mode 100644
index 5b67327a..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_Unified_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_1.ups
deleted file mode 100644
index fa84910a..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_1.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_Unified_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_2.ups
deleted file mode 100644
index 4b839d4b..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_64_2.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_Unified_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-1200, -1800, -2400]</lower>                               
-    <upper>[1200, 1800, 2400]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_8_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_8_0.ups
deleted file mode 100644
index 076f634a..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_8_0.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_Unified_8_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_8_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_8_1.ups
deleted file mode 100644
index c6fa6a5d..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/cc_weak_scalability_3d_Unified_8_1.ups
+++ /dev/null
@@ -1,36 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>CC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>cc_weak_scalability_3d_Unified_8_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d.m b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d.m
deleted file mode 100644
index 58064ffa..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d.m
+++ /dev/null
@@ -1,59 +0,0 @@
-XML = [
-    '<Uintah_specification>                                        \n', ...
-    ' <Meta>                                                       \n', ...
-    '  <title>NC PhaseField scalability test</title>               \n', ...
-    ' </Meta>                                                      \n', ...
-    ' <SimulationComponent type="phasefield" />                    \n', ...
-    ' <Scheduler type="%s" />                                      \n', ...
-    ' <Time>                                                       \n', ...
-    '  <maxTime>1000.0</maxTime>                                   \n', ...
-    '  <initTime>0.0</initTime>                                    \n', ...
-    '  <delt_min>0.01</delt_min>                                   \n', ...
-    '  <delt_max>1.</delt_max>                                     \n', ...
-    '  <timestep_multiplier>1.</timestep_multiplier>               \n', ...
-    ' </Time>                                                      \n', ...
-    ' <DataArchiver>                                               \n', ...
-    '  <filebase>%s.uda</filebase>                                 \n', ...
-    '  <outputTimestepInterval>0</outputTimestepInterval>          \n', ...
-    ' </DataArchiver>                                              \n', ...
-    ' <PhaseField>                                                 \n', ...
-    '  <delt>0.075</delt>                                          \n', ...
-    '  <alpha>1.</alpha>                                           \n', ...
-    '  <R0>5.</R0>                                                 \n', ...
-    '  <Delta>0.65</Delta>                                         \n', ...
-    '  <epsilon>0.05</epsilon>                                     \n', ...
-    ' </PhaseField>                                                \n', ...
-    ' <Grid>                                                       \n', ...
-    '  <Level>                                                     \n', ...
-    '   <Box label="1">                                            \n', ...
-    '    <lower>[%d, %d, 0.]</lower>                               \n', ...
-    '    <upper>[%d, %d, 1.]</upper>                               \n', ...
-    '    <patches>[%d,%d,1]</patches>                              \n', ...
-    '   </Box>                                                     \n', ...
-    '   <spacing>[1., 1., 1.]</spacing>                            \n', ...
-    '  </Level>                                                    \n', ...
-    ' </Grid>                                                      \n', ...
-    '</Uintah_specification>                                       \n'];
-
-core_patch_size = 4000;
-
-scheduler = {'MPI','DynamicMPI','Unified' };
-for s=1:3
-    for log4_cores=0:3
-        for load=0:log4_cores
-            cores = 4^log4_cores;
-            patches = [6, 4]*2^load;
-            lower = -patches/2 * core_patch_size;
-            upper = patches/2 * core_patch_size;
-            patches = [6, 4]*2^log4_cores;
-            
-            filename = sprintf('nc_weak_scalability_2d_%s_%d_%d', scheduler{s}, cores, load);
-            xml = sprintf(XML,scheduler{s},filename,lower(1),lower(2),upper(1),upper(2),patches(1),patches(2));
-            
-            fid = fopen ( [filename '.ups'], 'wt' );
-            fprintf(fid, xml);
-            fclose(fid);
-        end
-    end
-end
-
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_0.ups
deleted file mode 100644
index c17c0be1..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_16_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_1.ups
deleted file mode 100644
index 0ddc8130..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_16_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_2.ups
deleted file mode 100644
index 41f95c8c..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_16_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_16_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-48000, -32000, 0.]</lower>                               
-    <upper>[48000, 32000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_1_0.ups
deleted file mode 100644
index 070a7c3c..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_1_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[6,4,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_4_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_4_0.ups
deleted file mode 100644
index 06ab2f54..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_4_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_4_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_4_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_4_1.ups
deleted file mode 100644
index 6880a6b5..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_4_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_4_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_0.ups
deleted file mode 100644
index 1c30dcde..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_1.ups
deleted file mode 100644
index a5bc8fa1..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_2.ups
deleted file mode 100644
index 7dba67d4..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-48000, -32000, 0.]</lower>                               
-    <upper>[48000, 32000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_3.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_3.ups
deleted file mode 100644
index 15fd882c..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_DynamicMPI_64_3.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_DynamicMPI_64_3.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-96000, -64000, 0.]</lower>                               
-    <upper>[96000, 64000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_0.ups
deleted file mode 100644
index eaaf40e4..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_16_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_1.ups
deleted file mode 100644
index 31ea869f..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_16_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_2.ups
deleted file mode 100644
index fe1f9257..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_16_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_16_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-48000, -32000, 0.]</lower>                               
-    <upper>[48000, 32000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_1_0.ups
deleted file mode 100644
index 12c707f3..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_1_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[6,4,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_4_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_4_0.ups
deleted file mode 100644
index 74559c12..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_4_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_4_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_4_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_4_1.ups
deleted file mode 100644
index ce9c08a2..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_4_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_4_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_0.ups
deleted file mode 100644
index 69270dec..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_1.ups
deleted file mode 100644
index 998c8e76..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_2.ups
deleted file mode 100644
index fbcdd06e..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-48000, -32000, 0.]</lower>                               
-    <upper>[48000, 32000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_3.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_3.ups
deleted file mode 100644
index 1da0e1bb..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_MPI_64_3.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_MPI_64_3.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-96000, -64000, 0.]</lower>                               
-    <upper>[96000, 64000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_0.ups
deleted file mode 100644
index 113cb8a6..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_16_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_1.ups
deleted file mode 100644
index 92401745..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_16_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_2.ups
deleted file mode 100644
index c440e8f6..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_16_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_16_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-48000, -32000, 0.]</lower>                               
-    <upper>[48000, 32000, 1.]</upper>                               
-    <patches>[24,16,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_1_0.ups
deleted file mode 100644
index 644e69e7..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_1_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[6,4,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_4_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_4_0.ups
deleted file mode 100644
index fdb213bf..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_4_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_4_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_4_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_4_1.ups
deleted file mode 100644
index 6926924c..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_4_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_4_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[12,8,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_0.ups
deleted file mode 100644
index e85317dc..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_0.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-12000, -8000, 0.]</lower>                               
-    <upper>[12000, 8000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_1.ups
deleted file mode 100644
index 7d1f04fb..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_1.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-24000, -16000, 0.]</lower>                               
-    <upper>[24000, 16000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_2.ups
deleted file mode 100644
index 8aa7f421..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_2.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-48000, -32000, 0.]</lower>                               
-    <upper>[48000, 32000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_3.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_3.ups
deleted file mode 100644
index 43b6cfc3..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_2d_Unified_64_3.ups
+++ /dev/null
@@ -1,35 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_2d_Unified_64_3.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-96000, -64000, 0.]</lower>                               
-    <upper>[96000, 64000, 1.]</upper>                               
-    <patches>[48,32,1]</patches>                              
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d.m b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d.m
deleted file mode 100644
index 2ece6337..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d.m
+++ /dev/null
@@ -1,61 +0,0 @@
-XML = [
-    '<Uintah_specification>                                        \n', ...
-    ' <Meta>                                                       \n', ...
-    '  <title>NC PhaseField scalability test</title>               \n', ...
-    ' </Meta>                                                      \n', ...
-    ' <SimulationComponent type="phasefield" />                    \n', ...
-    ' <Scheduler type="%s" />                                      \n', ...
-    ' <Time>                                                       \n', ...
-    '  <maxTime>1000.0</maxTime>                                   \n', ...
-    '  <initTime>0.0</initTime>                                    \n', ...
-    '  <delt_min>0.01</delt_min>                                   \n', ...
-    '  <delt_max>1.</delt_max>                                     \n', ...
-    '  <timestep_multiplier>1.</timestep_multiplier>               \n', ...
-    ' </Time>                                                      \n', ...
-    ' <DataArchiver>                                               \n', ...
-    '  <filebase>%s.uda</filebase>                                 \n', ...
-    '  <outputTimestepInterval>0</outputTimestepInterval>          \n', ...
-    ' </DataArchiver>                                              \n', ...
-    ' <PhaseField>                                                 \n', ...
-    '  <delt>0.075</delt>                                          \n', ...
-    '  <alpha>1.</alpha>                                           \n', ...
-    '  <R0>5.</R0>                                                 \n', ...
-    '  <Delta>0.65</Delta>                                         \n', ...
-    '  <epsilon>0.05</epsilon>                                     \n', ...
-    '  <node_centered>true</node_centered>                         \n', ...
-    '  <dimension>3</dimension>                                    \n', ...
-    ' </PhaseField>                                                \n', ...
-    ' <Grid>                                                       \n', ...
-    '  <Level>                                                     \n', ...
-    '   <Box label="1">                                            \n', ...
-    '    <lower>[%d, %d, %d]</lower>                               \n', ...
-    '    <upper>[%d, %d, %d]</upper>                               \n', ...
-    '    <patches>[%d, %d, %d]</patches>                           \n', ...
-    '   </Box>                                                     \n', ...
-    '   <spacing>[1., 1., 1.]</spacing>                            \n', ...
-    '  </Level>                                                    \n', ...
-    ' </Grid>                                                      \n', ...
-    '</Uintah_specification>                                       \n'];
-
-core_patch_size = 300;
-
-scheduler = {'MPI','DynamicMPI','Unified' };
-for s=1:3
-    for log8_cores=0:2
-        for load=0:log8_cores
-            cores = 8^log8_cores;
-            patches = [2, 3, 4]*2^load;
-            lower = -patches/2 * core_patch_size;
-            upper = patches/2 * core_patch_size;
-            patches = [2, 3, 4]*2^log8_cores;
-            
-            filename = sprintf('nc_weak_scalability_3d_%s_%d_%d', scheduler{s}, cores, load);
-            xml = sprintf(XML,scheduler{s},filename,lower(1),lower(2),lower(3),upper(1),upper(2),upper(3),patches(1),patches(2),patches(3));
-            
-            fid = fopen ( [filename '.ups'], 'wt' );
-            fprintf(fid, xml);
-            fclose(fid);
-        end
-    end
-end
-
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_1_0.ups
deleted file mode 100644
index 9ba87cfe..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_1_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_DynamicMPI_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[2, 3, 4]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_0.ups
deleted file mode 100644
index 6117849e..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_DynamicMPI_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_1.ups
deleted file mode 100644
index ad16ab63..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_1.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_DynamicMPI_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_2.ups
deleted file mode 100644
index 4f558cbd..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_64_2.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_DynamicMPI_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-1200, -1800, -2400]</lower>                               
-    <upper>[1200, 1800, 2400]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_8_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_8_0.ups
deleted file mode 100644
index 530e403e..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_8_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_DynamicMPI_8_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_8_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_8_1.ups
deleted file mode 100644
index 2360e239..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_DynamicMPI_8_1.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="DynamicMPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_DynamicMPI_8_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_1_0.ups
deleted file mode 100644
index 3d67d6a2..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_1_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_MPI_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[2, 3, 4]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_0.ups
deleted file mode 100644
index af3e1aed..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_MPI_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_1.ups
deleted file mode 100644
index 32979ebb..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_1.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_MPI_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_2.ups
deleted file mode 100644
index 3ac3c69e..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_64_2.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_MPI_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-1200, -1800, -2400]</lower>                               
-    <upper>[1200, 1800, 2400]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_8_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_8_0.ups
deleted file mode 100644
index 76bc31b0..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_8_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_MPI_8_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_8_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_8_1.ups
deleted file mode 100644
index 8bce0380..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_MPI_8_1.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="MPI" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_MPI_8_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_1_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_1_0.ups
deleted file mode 100644
index cf5ba77e..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_1_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_Unified_1_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[2, 3, 4]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_0.ups
deleted file mode 100644
index 580dba8d..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_Unified_64_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_1.ups
deleted file mode 100644
index 73738248..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_1.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_Unified_64_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_2.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_2.ups
deleted file mode 100644
index 56a3b17b..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_64_2.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_Unified_64_2.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-1200, -1800, -2400]</lower>                               
-    <upper>[1200, 1800, 2400]</upper>                               
-    <patches>[8, 12, 16]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_8_0.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_8_0.ups
deleted file mode 100644
index ec6746bd..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_8_0.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_Unified_8_0.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-300, -450, -600]</lower>                               
-    <upper>[300, 450, 600]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_8_1.ups b/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_8_1.ups
deleted file mode 100644
index 8e5c6254..00000000
--- a/src/StandAlone/inputs/PhaseField/weak_scalability/nc_weak_scalability_3d_Unified_8_1.ups
+++ /dev/null
@@ -1,37 +0,0 @@
-<Uintah_specification>                                        
- <Meta>                                                       
-  <title>NC PhaseField scalability test</title>               
- </Meta>                                                      
- <SimulationComponent type="phasefield" />                    
- <Scheduler type="Unified" />                                      
- <Time>                                                       
-  <maxTime>1000.0</maxTime>                                   
-  <initTime>0.0</initTime>                                    
-  <delt_min>0.01</delt_min>                                   
-  <delt_max>1.</delt_max>                                     
-  <timestep_multiplier>1.</timestep_multiplier>               
- </Time>                                                      
- <DataArchiver>                                               
-  <filebase>nc_weak_scalability_3d_Unified_8_1.uda</filebase>                                 
-  <outputTimestepInterval>0</outputTimestepInterval>          
- </DataArchiver>                                              
- <PhaseField>                                                 
-  <delt>0.075</delt>                                          
-  <alpha>1.</alpha>                                           
-  <R0>5.</R0>                                                 
-  <Delta>0.65</Delta>                                         
-  <epsilon>0.05</epsilon>                                     
-  <node_centered>true</node_centered>                         
-  <dimension>3</dimension>                                    
- </PhaseField>                                                
- <Grid>                                                       
-  <Level>                                                     
-   <Box label="1">                                            
-    <lower>[-600, -900, -1200]</lower>                               
-    <upper>[600, 900, 1200]</upper>                               
-    <patches>[4, 6, 8]</patches>                           
-   </Box>                                                     
-   <spacing>[1., 1., 1.]</spacing>                            
-  </Level>                                                    
- </Grid>                                                      
-</Uintah_specification>                                       
diff --git a/src/StandAlone/inputs/UPS_SPEC/ups_spec.xml b/src/StandAlone/inputs/UPS_SPEC/ups_spec.xml
index a3120d49..e642f246 100644
--- a/src/StandAlone/inputs/UPS_SPEC/ups_spec.xml
+++ b/src/StandAlone/inputs/UPS_SPEC/ups_spec.xml
@@ -954,6 +954,13 @@
       <patches_per_level_per_proc       spec="OPTIONAL DOUBLE 'positive'" need_applies_to="type Tiled" />
 
     </Regridder>
+
+    <FineCoarseInterfaces               spec="OPTIONAL NO_DATA">
+      <FCIType                          spec="MULTIPLE NO_DATA"
+                                        attribute1="id        OPTIONAL STRING '0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,all'"
+                                        attribute2="var       REQUIRED STRING 'FC0,FCSimple,FCLinear,FCBilinear,FC1'"
+                                        attribute3="label     REQUIRED STRING " />
+    </FineCoarseInterfaces>
   </AMR>
   
   <!--__________________________________-->
@@ -1146,20 +1153,20 @@
     <verbosity                spec="OPTIONAL INTEGER '0,4'"/>
   </FDHeat>
 
-  <PhaseField spec="OPTIONAL NO_DATA" >
+  <PhaseField spec="OPTIONAL NO_DATA"
+        attribute1="type REQUIRED STRING 'pure_metal'">
     <delt                     spec="REQUIRED DOUBLE" />
-    <alpha                    spec="REQUIRED DOUBLE" />
-    <R0                       spec="REQUIRED DOUBLE" />
-    <Delta                    spec="REQUIRED DOUBLE" />
-    <epsilon                  spec="REQUIRED DOUBLE" />
-    <phi0                     spec="OPTIONAL DOUBLE" />
-    <refine_threshold         spec="OPTIONAL DOUBLE" />
+    <dim                      spec="OPTIONAL INTEGER '1,3'"/>
+    <var                      spec="OPTIONAL STRING 'cc, nc'"/>
+    <verbosity                spec="OPTIONAL INTEGER '0,4'"/>
+    <alpha                    spec="OPTIONAL DOUBLE" />
+    <R0                       spec="OPTIONAL DOUBLE" />
+    <Delta                    spec="OPTIONAL DOUBLE" />
+    <epsilon                  spec="OPTIONAL DOUBLE" />
     <gamma_psi                spec="OPTIONAL DOUBLE" />
     <gamma_u                  spec="OPTIONAL DOUBLE" />
-    <node_centered            spec="OPTIONAL BOOLEAN"/>
-    <dimension                spec="OPTIONAL INTEGER"/>
-    <verbosity                spec="OPTIONAL INTEGER"/>
-    <ws_test                  spec="OPTIONAL BOOLEAN"/>
+    <refine_threshold         spec="OPTIONAL DOUBLE" />
+    <test                     spec="OPTIONAL BOOLEAN" />
   </PhaseField>
   
   <UnifiedSchedulerTest       spec="OPTIONAL NO_DATA" >
